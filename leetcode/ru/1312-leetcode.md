-
Оригинальное название: LeetCode 1312: Minimum Insertion Steps to Make a String Palindrome
описание: владелец
дата: 2025-09-21
Категории: []
Автор: Moses
теги: []
Скриншоты: True
-
## Мастер ЛитКод 1312 — «Минимальные вставные шаги для создания струнного палиндрома»
(Полное, готовое к интервью руководство для Java, Python и C++) *

-

### TL,DR
**Проблема**: При наличии строки 's' верните *минимум* количество вставок, необходимое для придания ей палиндрома.
- ** Оптимальный подход**: самая длинная палиндромная последовательность (LPS) → «minInsertions = |s | — LPS».
- **Сложности**: 'O(n2)' время, 'O(n2)' пространство (может быть сведено к 'O(n)') Если вам комфортно.
Почему это важно: это классическая проблема DP, которая показывает, что вы можете уменьшить проблему манипулирования строками до LCS / LPS. Рекрутеры любят это.

-

##1️Возвращение проблемы

текст
Ввод: s = "мбадм"
Результат: 2

Пояснение:
«mbadm» → «mbdadbm» (вставить «d» после «b», «a» перед «d»)
Достаточно двух вставок, и вы можете доказать, что они минимальны.
'' пункт

- Длина 's': '1 ≤ |s | ≤ 500'
- Только английские буквы.

-

## 2️ Почему LPS работает

Вставка только добавляет символы; она никогда не удаляет и не изменяет существующие.
Самая длинная последовательность, которая уже является палиндромом, может оставаться нетронутой - нам нужно только вставить недостающие символы.
Таким образом:

текст
minInsertions = |s | - long_of_longest_palindromic_subsequence(s)
'' пункт

Нахождение LPS идентично нахождению LCS между «s» и его реверсом («rev(s)»).
Вот почему мы используем классическую DP**.

-

## 3️ ДП рецидив

Пусть 'dp[i][j]' будет длиной LCS 's[0...i-1]' и 'rev[0...j-1]'.

'' пункт
если s[i-1] == rev[j-1] → dp[i][j] = 1 + dp[i-1][j-1]
dp[i][j] = max(dp[i-1][j], dp[i][j-1])
'' пункт

Ответ: 'n - dp[n][n]', где 'n = s.length()'.

-

##4️Сложность

Метричность | Сложность
[скрыто] [скрыто] [скрыто] [скрыто] [скрыто]
| Время | 'O(n2)' ('n ≤ 500' → 250 k операций, тривиальный для любого языка)
| Пространство | таблица DP «O(n2)» (≈ 250 кт ≈ 1 Мб) |
Опциональное сокращение пространства до «O(n)» (не показаны ниже для ясности). !

-

##5️ Case Краевые случаи и общие подводные камни

Pitfall - Исправить
[скрыто] [скрыто] [скрыто] [скрыто]
Забудьте перевернуть строку | 'StringBuilder(s.reverse()'' (Ява), 's [::-1]' (Питон), 'обратный()' (C++)
| Отдельная индексация в циклах DP | Используйте 'i <= n', 'j <= n' и доступ 's[i-1] !
! Большое использование памяти на 2-D массиве | 'vector<vector<int>> dp(n+1, vector<int>(n+1, 0));' прекрасно подходит для n ≤ 500 |

-

##6️ Code Реализация кода

>   ** Все три версии используют одну и ту же логику DP — только синтаксические изменения. **

### 6.1 Java

Джава
Общественный класс Решение {
public int minInsertions (String s)
int n = s.length();
String rev = новый StringBuilder(s).reverse().toString();

int[][] dp = new int[n + 1][n + 1];

для (int i = 1; i <= n; i++) {
для (int j = 1; j <= n; j++) {
если (s.charAt(i - 1) == rev.charAt(j - 1)) {
dp[i][j] = dp[i — 1][j — 1] + 1;
Другое дело
dp[i][j] = Math.max(dp[i — 1][j], dp[i][j — 1]);
?
?
?
Возвращение n — dp[n][n];
?
?
'' пункт

### 6.2 Python

«Питон»
Классное решение:
def minInsertions(self, s: str) -> Инт:
n = len(s)
rev = s[::-1]
dp = [0] * (n + 1) для _ в диапазоне (n + 1)

для i в диапазоне (1, n + 1):
для j в диапазоне (1, n + 1):
если s[i — 1] == rev[j — 1]:
dp[i][j] = dp[i — 1][j — 1] + 1
другое:
dp[i][j] = max(dp[i — 1][j], dp[i][j — 1])

Возвращение n - dp[n][n]
'' пункт

### 6.3 C++

cpp
Классное решение {
общественность:
int minInsertions (струна s)
int n = s.size();
s.rbegin(), s.rend());
вектор <vector<int>> dp(n + 1, вектор <int>(n + 1, 0));

для (int i = 1; i <= n; ++i) {
для (int j = 1; j <= n; ++j) {
если (s[i — 1] == rev[j — 1])
dp[i][j] = dp[i — 1][j — 1] + 1;
другой
dp[i][j] = max(dp[i — 1][j], dp[i][j — 1]);
?
?
Возвращение n — dp[n][n];
?
}
'' пункт

-

##7️Тестирование вашего решения

! Тест | Ввод | Ожидаемый |
[скрыто] [скрыто] [скрыто] [скрыто] [скрыто]
| 1 | 'zzazz' | '0' |
| 2 | "мбадм" | "2" |
| 3 | "leetcode" | "5" |
| 4 | 'a' | '0' |
| 5 | 'ab' | '1' |
| 6 | 'abca' | '1' |
| 7 | "abcda" | "2" |

Запустите предоставленные модульные тесты в вашем IDE или онлайн-редакторе LeetCode для проверки правильности.

-

## 8️ Реально-мировая значимость

**Текст-редакторы и IDE**: движки автозаполнения и проверки орфографии должны сравнивать строки с минимальными правками.
**Секвенирование ДНК**: Поиск палиндромных последовательностей имеет важное значение для анализа генома.
** Компиляторы**: Палиндромные паттерны помогают в выделении синтаксиса и проверке синтаксиса.

-

##9️‐Взять Домашние уроки

Хороший, плохой, отвратительный
[скрыто] [скрыто] [скрыто] [скрыто] [скрыто]
*  the Чистое * * уменьшение проблемы * *: LPS → LCS → DP |  the Некоторые решения используют *brute-force* или *recursive* подходы, которые взрываются экспоненциально |  the Забывание *обратной * строки или индексирование одним вызывает неправильные ответы |
Модульный код **: Отдельный метод «minInsertions», многоразовый в интервью |  a Over-engineering: использование «HashMap» или «LinkedList», где достаточно простого массива |  a Использование рекурсии без запоминания приводит к переполнению стека |
* * * Оптимизированный для космоса вариант **: одномерный DP (если его спросить) |  the Смешивание языков в одном и том же репо без четкого разделения |  the Ненужные заявления печати / отладки, которые захламляют журналы |

-

Бонус: Space-Optimized (O(n)) Python

«Питон»
def minInsertions(s: str) -> Инт:
rev = s[::-1]
n = len(s)
prev = [0] * (n + 1)
для i в диапазоне (1, n + 1):
cur = [0] * (n + 1)
для j в диапазоне (1, n + 1):
cur[j] = prev[j — 1] + 1 если s[i-1] == rev[j-1] else max(prev[j], cur[j-1])
Prev = Cur
Возвращение n - prev[n]
'' пункт

-

###Почему блог помогает найти работу

** Богатый ключевыми словами контент**: «LeetCode 1312», «минимальный палиндром вставок», «интервью по динамическому программированию», «подготовка интервью инженера-программиста».
**Чистая структура**: Введение → Интуиция → ДП → Код → Тесты → Выводы.
** Действующий код**: готовые к копированию фрагменты для Java, Python, C++.
- **Профессиональный тон**: Демонстрирует глубокое понимание алгоритмических понятий.

> ✔ **Хотите больше готовых интервью? ** Подписывайтесь на нашу рассылку или ознакомьтесь с полной серией на * Динамическое программирование, графики и структуры данных *.

-

Оригинальное название: Final Code Cheat Спецификация

Джава
// Java
Классное решение {
public int minInsertions (String s) {/* DP as above */ }
?
'' пункт

«Питон»
# Python
Классное решение:
def minInsertions(self, s: str) -> Оригинальное название: #DP as above
'' пункт

cpp
// C++
Классное решение {
общественность:
int minInsertions(string s) {/* DP as above */ }
}
'' пункт

Копируйте, вставляйте, запускайте, и вы готовы к следующему вопросу интервью. Счастливого кода