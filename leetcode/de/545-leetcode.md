---
Titel: LeetCode 545. Boundary of Binary Tree -
Beschreibung: Platzhalter
Datum: 2025-09-21
Kategorien: []
Verfasser: moses
Schlagworte: []
verstecktToc: wahr
---
üìå LeetCode 545 ‚Äì Boundary of Binary Tree
**Medium | Binary Tree | DFS / Recursion | Time O(n) | Space O(h)*

Hier finden Sie voll funktionsf√§hige L√∂sungen in **Java, Python und C++**.
Nach dem Code haben wir einen kurzen ‚Äûblog‚Äêstyle‚Äú Artikel geschrieben, der den Algorithmus erkl√§rt, das Gute, das B√∂se und das h√§ssliche hervorhebt und mit SEO-optimierten Keywords geschrieben wird, die Rekrutierer gerne in Ihrem Portfolio oder GitHub README sehen.

---

### 1. Java L√∂sung

``java
java.util importieren. ArrayList;
java.util importieren. Liste

/** Definition f√ºr einen bin√§ren Baumknoten. *
Volksklasse TreeNode {
int val;
TreeNode links;
TreeNode rechts;
TreeNode(int x) { val = x; }
}

Public class L√∂sung {\cHFFFF}

√ñffentliches Gebiet vonBinaryTree(TreeNode Wurzel) {
Liste<Integer> Ergebnis = neue ArrayList<>>();
wenn (root == null) R√ºcklaufergebnis;

wenn (!isLeaf(root) result.add(root.val)

// 1. linke Begrenzung (ohne Bl√§tter)
TreeNode cur = root.left;
w√§hrend (kur != null) {
wenn (!isLeaf(cur)) result.add(cur.val);
cur = (cur.left != null) ? cur.left : cur.right;
}

// 2. Alle Bl√§tter (links bis rechts)
addLeaves(root, Ergebnis);

// 3. Rechte Begrenzung (ohne Bl√§tter) in umgekehrter Richtung
List<Integer> rightBounding = new ArrayList<>;
cur = root.right;
w√§hrend (kur != null) {
wenn (!isLeaf(cur)) rechtBoundary.add(cur.val)
cur = (cur.right != null) ? cur.right: cur.left;
}
f√ºr (int i = rightBoundary.size() - 1; i >= 0; --i)
result.add(rightBoundary.get(i));

R√ºckgabeergebnis;
}

Private Leere addLeaves(TreeNode node, List<Integer> out) {
wenn (node == null) zur√ºckkehrt;
wenn (isLeaf(node)) {\cHFFFF}
aus.add(node.val)
zur√ºck;
}
addLeaves(node.left, out);
addLeaves(node.right, out);
}

Privat boolean isLeaf(TreeNode node) {
zur√ºckgeben. = null &&-Knoten. = null;
}
}
`` `

---

### 2. Python L√∂sung

```python
aus der Einfuhr Liste, Optional

# Definition f√ºr einen bin√§ren Baumknoten.
Klasse TreeNode:
def __init__(self, val: int = 0, links: 'TreeNode' = None, right: 'TreeNode' = None):
selbst.val = val
selbst.left = links
selbst.right = rechts

Klasse L√∂sung:
Def Grenze VonBinaryTree(self, root: Optional[TreeNode]) -> Liste[int]:
wenn nicht root: return []

= []

# Root (falls kein Blatt)
wenn nicht selbst._is_leaf(root):
res.append(root.val)

# linke Grenze (ohne Bl√§tter)
Node = root.left
w√§hrend Knoten:
wenn nicht selbst._is_leaf(node):
res.append(node.val)
node = node.left if node. links anderen Knoten. Recht

# Leaves
selbst._add_leaves(root, res)

# Rechte Grenze (ohne Bl√§tter) ‚Äì Sammeln Sie dann umgekehrt
Recht_gebunden = [
node = root.right
w√§hrend Knoten:
wenn nicht selbst._is_leaf(node):
Rechts_boundary.append(node.val)
node = node.right wenn node. - Ja. links
res.extend(reversed(right_boundary))

zur√ºck

def _add_leaves(self, node: Optional[TreeNode], out: List[int]) -> Keine
wenn nicht Knoten:
zur√ºck
wenn selbst._is_leaf(node):
aus.append(node.val)
zur√ºck
selbst._add_leaves(node.left, out)
selbst._add_leaves(node.right, out)

@staticmethod
def _is_leaf(node: TreeNode) -> bool:
zur√ºckgeben. links ist None und Knoten. Recht ist Keine
`` `

---

### 3. C++ L√∂sung

```cpp
#include <vector>
mit Namespace std;

/* Definition f√ºr einen bin√§ren Baumknoten. *
TreeNode {
int val;
TreeNode *links;
TreeNode *right;
TreeNode(int x) : val(x), links(nullptr), rechts(nullptr) {}
};

Klasse L√∂sung {
√∂ffentlich:
Vektor<int> vonBinaryTree(TreeNode* Wurzel) {
vektor<int> an;
wenn (!root) Ans zur√ºckgibt;

wenn (!isLeaf(root)) ans.push_back(root>val)

// linke Begrenzung (ohne Bl√§tter)
TreeNode* cur = root->left;
w√§hrend (kur)
wenn (!isLeaf(cur)) ans.push_back(cur->val)
cur = (cur->left)
}

// Bl√§tter
addLeaves(root, ans);

// Rechte Grenze (ohne Bl√§tter) ‚Äì Sammeln Sie dann umgekehrt
Vektor<int> RechtsB;
cur = root->right;
w√§hrend (kur)
wenn (!isLeaf(cur)) rightB.push_back(cur->val)
= (kur->right)
}
f√ºr (auto it = rightB.rbegin(); it != rightB.rend(); ++it)
ans.push_back(*it);

R√ºckgabe ans;
}

privat:
bool isLeaf(TreeNode* node) {
zur√ºck-Knoten->left == Nullptr && node->right == nullptr;
}

Leere addLeaves(TreeNode* node, vector<int>& out) {
wenn (!node) zur√ºckkehrt;
wenn (isLeaf(node)) {\cHFFFF}
out.push_back(node->val);
zur√ºck;
}
addLeaves(node->left, out);
addLeaves(node->right, out);
}
};
`` `

> **Tip:** In allen drei Sprachen ist die Kernidee gleich ‚Äì *DFS mit drei P√§ssen*:
> 1. linke Begrenzung (oben-zu-unt, √ºberspringen Bl√§tter)
> 2. Alle Bl√§tter (links bis rechts)
> 3. Rechte Begrenzung (oben-zu-unten, √ºberspringen Bl√§tter) aber in umgekehrter Reihenfolge hinzugef√ºgt

---

üìñ Blog‚ÄêStyle Write‚Äêup: ‚ÄûBoundary of Binary Tree ‚Äì Good, Bad & Ugly‚Äú

> **Keywords**: *LeetCode 545, Boundary of Binary Baum, bin√§re Baumtransversal, DFS, Interview-Algorithmus, Software-Ingenieur-Interview, Codierung Interview, Zeitkomplexit√§t, Raumkomplexit√§t, Job-Interview-Tipps. *

---

### 1Ô∏è‚É£ Das Gute

| Warum dieser Algorithmus gl√§nzt | Was Rekrutierer sehen |
------------------------------------------------------------
| **Simplicity** ‚Äì Die L√∂sung ist nur ein paar Schleifen und ein wiederkehrender Blattkollektor. Keine zus√§tzliche Zustandsmaschine oder Fahnenlogik. | *Klar, lesbarer Code* |
| **Linear Time** ‚Äì Jeder Knoten wird maximal einmal besucht ‚Üí **O(n)**. Perfekt f√ºr gro√üe B√§ume. | *Efficiency Claim* |
| **Low Auxiliary Space* ‚Äì Nur Recursionstiefe (`O(h)`) und ein paar Zusatzlisten (`O(h)`). | *Space-optimiert*
| **Extensible** ‚Äì Sie k√∂nnen diese Routine in jedes Interview oder Produktionssystem einf√ºgen, das eine ‚ÄûStra√üenperipherie‚Äú-Ansicht ben√∂tigt. | * Wiederverwendbares Codemuster* |
| **No Double‚ÄêCounting** ‚Äì Bl√§tter werden nur einmal hinzugef√ºgt, ob sie an einer Grenze erscheinen oder nicht. | *Bug-freie Garantie* |

> **Recruiter-freundlicher Takeaway**: *‚ÄúIch kann saubere, O(n) Baum-Traversal-Code produzieren, der h√§ufige Fallstricke wie Doppel-Folgebl√§tter vermeidet.‚Äú*

---

### 2Ô∏è‚É£ Das B√∂se

H√§ufige Schmerzpunkte | Fix / Vermeiden Sie |
|----------------------------
| **Nullwurzel* ‚Äì Die Problemerkl√§rung garantiert eine Wurzel, aber eine defensive Kodierung ist immer noch klug. | √úberpr√ºfen Sie `root == null` fr√ºh. |
| **Single‚Äêchild-Grenzknoten* ‚Äì Ein Knoten mit nur einem Kind muss noch als Teil der Grenze betrachtet werden. Verwenden Sie das ‚Äûwenn es noch rechts gibt‚Äú (und umgekehrt f√ºr die rechte Grenze). |
| **Root ist ein Blatt* ‚Äì In diesem Fall ist die Grenze nur `[root.val]`. | Skip addieren `root`, wenn es ein Blatt ist. |
| **Language quirks* ‚Äì In Python kann die Recursionsgrenze `sys.setrecursionlimit` treffen, in C++ m√ºssen die Pointer-Checks vorsichtig sein. | Halten Sie die Rekursionstiefe im Auge, oder wechseln Sie zu einem iterativen Stack, wenn `h` k√∂nnte riesig sein. |

---

### 3Ô∏è‚É£ Die Ugly

| Wenn der Code wie ein Spaghetti Monster aussieht |
|-------------------------------------------------------------
| Over‚ÄêEngineering mit ‚ÄúFlag‚Äù Ganzzahlen (1 = links, 2 = rechts, 3 = andere) und mehrere Helfer-Methoden nur um die Spur von ‚Äúwo wir sind‚Äù zu halten ist **unn√∂tig** f√ºr dieses Problem. Es macht den Code h√§rter zu lesen und mehr fehleranf√§llig. |
| Die Verwendung eines globalen `vector<int>` und die Mutation von der tiefen Rekursion kann knifflig sein, vor allem in C++, wo die manuelle Speicherverwaltung beteiligt ist. |
| Das Vergessen, Bl√§tter beim Hinzuf√ºgen der linken/rechts Grenze zu √ºberspringen, f√ºhrt oft zu Duplikatwerten in der Endliste. Ein ‚Äûsimple‚Äêfirst‚Äú Ansatz, der die Wurzel, linke Grenze, Bl√§tter, rechte Grenze ‚Äì und dann de‚Äêdupliziert ‚Äì hinzuf√ºgt, ist sauberer. |

> **Take‚Äêaway**: *Schreiben Sie die einfachste DFS, die die Begrenzungsregeln erf√ºllt. Vermeiden Sie versteckte Fahnen oder State-Maschinen, es sei denn, das Interview erfordert sie ausdr√ºcklich. *

---

### 4Ô∏è‚É£ SEO‚ÄêOptimierte Zusammenfassung

Wenn Sie ein GitHub README, eine Portfolio-Seite, oder eine **LeetCode L√∂sung Set** zur Beeindruckung von Einstellungsmanagern erstellen, verwenden Sie die folgenden Meta-Tags, √úberschriften und Keyword-dense S√§tze:

- #LeetCode545`, `#BoundaryOfBinaryTree`, `#BinaryTreeTraversal`, `#DFS`, `#Recursion`, `#InterviewAlgorithm`, `#SoftwareEngineer`, `#CodingInterview`, `#JobInterview`, `#AlgorithmDesign`, `#TimeComplexity`, `#SpaceComplexity `

**Sampling README Snippet**

```markdown
# Boundary of Binary Tree ‚Äì LeetCode 545

- **Problem**: Berechnen Sie die Grenze eines bin√§ren Baumes (linke Grenze, Bl√§tter, rechte Grenze) in O(n) Zeit.
- **Sprachen*: Java, Python, C++.
- **Komplexit√§ten*: `O(n)` Zeit, `O(h)` Hilfsraum (`h` = Baumh√∂he).
- **Warum es geht**: Demonstriert Tiefen-erste Suche, Edge-Case-Handling und sauberen Code ‚Äì Schl√ºsselfertigkeiten f√ºr ein Software-Ingenieur-Interview.
`` `

> **Warum ist das wichtig f√ºr Ihre Jobsuche* *
> Recruiter suchen nach Kandidaten, die ** klassische Baumprobleme l√∂sen** schnell und mit sauberem Code. Indem Sie dieses Problem (LeetCode 545) zu Ihrem √∂ffentlichen Repo hinzuf√ºgen und einen Blog-Post schreiben, der *gute, schlechte, h√§ssliche* Einsichten erkl√§rt, zeigen Sie:
> * Probleme l√∂sende F√§higkeiten
> * Code Lesbarkeit und Aufrechterhaltungsf√§higkeit
* Verst√§ndnis von Zeit- und Raumfahrt-Ausfl√ºgen
> * F√§higkeit, komplexe Ideen in einem verdaulichen Format zu kommunizieren

---

### 5Ô∏è‚É£ Schnelltest-Harness (Optional)

``java
√∂ffentliche statische Leerstelle (String[] args) {
/* Konstruieren Sie den folgenden Baum
1
/ \
Artikel 3
/ \
4 5 7
*
TreeNode root = new TreeNode(1);
root.left = new TreeNode(2);
root.right = new TreeNode(3);
root.left.left = new TreeNode(4);
root.left.right = new TreeNode(5);
root.right.right = new TreeNode(7);

L√∂sungssol = neue L√∂sung();
System.out.println(sol.boundaryOfBinaryTree(root)); // -> [1, 2, 4, 5, 7, 3]
}
`` `

---

### üéØ Wie verwenden Sie diese L√∂sungen in Ihrem Interview Portfolio

ANHANG ** Laden Sie die drei Quelldateien** (`Solution.java`, `solution.py`, `solution.cpp`) auf ein √∂ffentliches GitHub Repo.
2. F√ºgen Sie den **blog Artikel* als `README.md` oder eine separate `blog.md`-Datei hinzu.
3. In Ihrer LinkedIn oder Portfolio-Seite, Link zum Repo und Erw√§hnen *‚ÄúSolved LeetCode 545 ‚Äì Boundary of Binary Tree with O(n) DFS‚Äú*.
4. Wenn Sie sich bewerben, f√ºgen Sie den folgenden Snippet zu Ihrem Titelbrief oder LinkedIn hinzu:

> *‚ÄúW√§hrend meines letzten Interviews habe ich LeetCode angegriffen 545 ‚Äì Boundary of Binary Tree, Implementierung einer sauberen, linear-time L√∂sung in Java, Python und C++. Der Algorithmus zeigt meine F√§higkeit, DFS auf bin√§ren B√§umen durchzuf√ºhren, Edge-case-Logik zu verwalten und produktionsbereiten Code zu produzieren.‚Äú*

---

**Happy Codierung & viel Gl√ºck Landung, dass n√§chste Software-Engineering Rolle!** üöÄ