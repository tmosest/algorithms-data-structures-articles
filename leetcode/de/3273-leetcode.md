---
Titel: LeetCode 3273. Mindestbetrag Schadensersatz an Bob -
Beschreibung: Platzhalter
Datum: 2025-09-21
Kategorien: []
Verfasser: moses
Schlagworte: []
verstecktToc: wahr
---
# üõ°Ô∏è Mindestbetrag Schadensersatz an Bob ‚Äì LeetCode 3273
**Ein kompletter Durchlauf (Java / Python / C++ + Blog Post)**

---

Inhaltsverzeichnis
ANHANG [Problem-Erkl√§rung](#Problem-Erkl√§rung)
2. [Warum dieses Problem betrifft](#war-dies-Problem-matters)
3. [Core Insight: Weighted Completion Time](#core-insight-weighted-completion-time)
4. [Greedy Solution (Smith‚Äôs Rule)](#greedy-solution-smiths-rule)
5. [Komplexit√§tsanalyse](#Komplexit√§tsanalyse)
6. [Edge‚ÄêCase & Pitfalls](#edge-case-pitfalls)
7. [Code Snippets](#code-snippets)
* Java
* Python
* C++
7. [Das Gute, das B√∂se und die Ugly](#the-good-the-bad-and-the-ugly)
8. [Alternate Ans√§tze & Varianten](#alternate-approaches-variants)
ANHANG [Take‚Äêaway for Interviews & Your Job Hunt](#take-away-for-interviews--your-job-hunt)
10. [Abschluss](#Abschluss)

---

oder 1. Problemerkl√§rung <a name="Problemsetzung">/a>

> **Mindestbetrag Schadensersatz an Bob**
> * Schwierigkeitsgrad: Mittel*

Sie erhalten:
- `power` ‚Äì die Anzahl der Gesundheitspunkte Bob kann pro Sekunde mit einem Angriff entfernen.
- Arrays `damage[i]` und `health[i]`` (Gr√∂√üe **n*, `1 ‚â§ n ‚â§ 105`).

Jede Sekunde Bob kann angreifen ** ein** Feind und entfernt `power` Gesundheitspunkte von diesem Feind.
Nach jeder Sekunde, jeder *alive* Feind behandelt Schaden gleich seinem `damage[i]` zu Bob.

**Goal**: Finden Sie den Gesamtschaden**** Bob kann nehmen, wenn Sie optimal spielen.

**Return type*: `long` / `long long` / Python `int` (weil die Antwort bis zu 1013 sein kann).

---

oder 2. Warum dieses Problem den Namen "Warum diese Probleme">/a>

| ‚úÖ ‚úÖ |
|----------
| **Common Interview Frage* ‚Äì LeetCode 3273 ist ein beliebtes ‚ÄûInterview‚Äêprep‚Äú-Problem auf Plattformen wie **LeetCode*, **HackerRank** und **CodeSignal**. | **Greedy + sorting** Die L√∂sung ist eine Lehrbuchanwendung von **Smith‚Äôs Rule** f√ºr die Schieduling, eine elegante Br√ºcke zwischen Algorithmen und real‚Äêworld Problemen. | **Beware overflow** ‚Äì Obwohl Zw√§nge klein aussehen, kann die kumulative Summe 1013 erreichen; eine 32-Bit-Inte explodiert. |
| Hilft Ihnen Praxis **Vergleicher / individuelle Sortierung** (Java, C++), **functools.cmp_to_key** (Python) und **int arithmetic** (Pythons ungebundene Ints). | Geben Sie Vertrauen in die Vernunft √ºber **gewichtete Abschlusszeit** ‚Äì ein Muster, das in vielen Interview-Fragen erscheint. | Interleaving-Angriffe (z.B. schaltende Feinde mid‚Äêattack) ist *never* besser ‚Äì viele Anf√§nger versuchen dies und bleiben fest. |

**Keywords f√ºr SEO*
- LeetCode 3273
- Mindestbetrag Schadensersatz an Bob
- gewichtete Fertigzeitalgorithmus
- Smiths Regel gierige Planung
- Codierung von Interview-Algorithmus
- Java Python C++ L√∂sung
- Interview Codierung Herausforderung
- Bewerbungsgespr√§ch Tipps

---

oder 3. Core Insight: Weighted Completion Time <a name="core-insight-weighted-completiontime">/a>

Lassen Sie uns die Situation formalisieren:

| Enemy `i` | Gesundheit `hi` | Schaden pro Sekunde `di` | Angriffszeit erforderlich (Sekunden) `ti` |
--------------------------------------------------------------------------------------------------------------------
| `hi` / `power` (ceil) | `hihi / power`` | ‚Äì | ‚Äì |

** Reservierung* *
Bob kann einen Feind beenden, bevor er ohne Verlust der Optimit√§t zum n√§chsten kommt.
Wenn Sie verz√∂gern, den Feind `x` zu beenden, w√§chst die *Vervollst√§ndigungszeit* `Cx` und erh√∂ht den Gesamtschaden `dx ¬∑ Cx`.
Alle Feinde, die sp√§ter kommen, werden auch verz√∂gert, so ist es nie n√ºtzlich, um zu wechseln.

So reduziert sich das Problem auf:
> **Sequenz die Feinde in einer einzigen Reihenfolge. **
> Jeder Feind `i` wird nacheinander f√ºr `ti` Sekunden angegriffen, dann stirbt er.
> Der Gesamtschaden ist

[...]
\text{Gesamt} = \sum_{i} d_i C
\)

wo `C_i` die Fertigstellungszeit ist (wenn der Feind `i` stirbt).

---

oder 4. Greedy Solution (Smith‚Äôs Rule) <a name="greedy-solution-smiths-rule">/a>

Das Problem ist genau das **gewichtete Fertigstellungsproblem* auf einer einzigen Maschine:

- **Prozesszeit** = `ti` (Sekunden, die erforderlich sind, um Feinde zu beenden `i`).
- **Gewicht** = `di` (Schaden pro Sekunde).

Smiths Regel (auch bekannt als *Ratioregel*) sagt:

> *Order-Jobs durch Abnehmen `Gewicht / Verarbeitung_Zeit`.*

F√ºr unsere Variablen:

[...]
)
\)

Wenn wir Feinde nach diesem Verh√§ltnis sortieren ** absteigen*, erhalten wir einen optimalen Zeitplan.
Bei Krawatten ist jede Bestellung fein (der Produktvergleich wird gleich sein).

### Warum die Regel funktioniert
- Wenn der Job `A` ein h√∂heres Verh√§ltnis hat als der Job `B`, spart das Finishing `A` fr√ºher mehr gewichtete Zeit als das Finish `B` zuerst.
- Swapping jedes benachbarte Paar, das die Verh√§ltnisreihenfolge verletzt, erh√∂ht das Ziel streng.
- Ja. Somit ist die sortierte Bestellung global optimal.

---

oder 5. Komplexit√§tsanalyse <a name="Komplexit√§tsanalyse">/a>

Schritt | Operation | Zeit | Raum |
|---------------------------------
| Compute `ti` (Zeil-Division) | O(n) | O(n) (Array of ints) |
| Sortierindizes nach Verh√§ltnis | O(n log n) | O(n) (Indizes) |
| Beschleunigte Antwort | O(n) | O(1) zus√§tzliche |

**Overall**
- **Zeit**: **O(n log n)**
- **Space**: **O(n)** (zur Speicherung von `ti` und einem Index-Array)

Die numerischen Grenzen sind winzig (`damage`, `health`, `power` ‚â§ 104) aber die kumulative Zeit `t` kann `109` erreichen.
Verwenden Sie 64-bit ganze Zahlen (`long long` / `long` / Pythons `int`), um √úberlauf zu vermeiden.

---

oder 6. Edge‚ÄêCase & Pitfalls <a name="edge-case-pitfalls">/a>

| Fall | Fix |
|---------
| ***Integer-√úberlauf im Vergleich** | Verwenden Sie 64‚ÄêBit (`long long` / `long`) bei der Berechnung von `d[a] * t[b] und `d[b] * t[a]`. |
| **Ceiling Division** | `(h + power - 1) / power` ist der Standardtrick. |
| **Sortierung nach Verh√§ltnis in Python*** | Vermeiden Sie Floating-Point-Vergleich; verwenden Sie `functools. cmp_to_key`. |
| **Ties in ratio** | Jede Bestellung funktioniert; wenn eine deterministische Ausgabe erforderlich ist, Bruchbindungen nach Index. |
| **Large n** | Speichernutzung niedrig halten; Speichern Sie nicht mehr als O(n) ganze Zahlen. |

---

oder 7. Code Snippets (Java / Python / C++) <a name="code-snippets">/a>

### Java (Java 17)

``java
Import java.util.*;

Klasse L√∂sung {
√∂ffentliche lange minDamage(int power, int[] damage, int[] health) {
int n = Besch√§digung.L√§nge;
int[] time = new int[n];
f√ºr (in i = 0; i < n; i++) {
Zeit[i] = (Gesundheit[i] + Leistung - 1) / Leistung; // Schleier
}

Integer[] idx = neuer Integer[n];
f√ºr (int i = 0; i < n; i++) idx[i] = i;

Arrays.sort(idx, (a, b)) ->
L√§nge links = (lang) Besch√§digung[a] * Zeit[b];
lang rechts = (langer) Schaden[b] * Zeit[a];
wenn (link == rechts) 0 zur√ºckgeben;
zur√ºck nach links > rechts? -1 : 1; // absteigende Reihenfolge
})

Gesamtl√§nge = 0;
lange CurTime = 0;
f√ºr (int id : idx) {
CurTime += Time[id];
Gesamt += (lang) Schaden[id] * CurTime;
}
Gesamtsumme;
}
}
`` `

---

### Python (Python 3)

```python
aus functools import cmp_to_key

def minDamage(Strom, Schaden, Gesundheit):
n = len(besch√§digt)
Zeiten = [(h + power - 1) // Leistung f√ºr h in der Gesundheit] # Schleier

def cmp(a, b):
links = Schaden[a] * mal[b]
Recht = Schaden[b] * mal[a]
wenn links == rechts:
R√ºckkehr 0
zur√ºck -1 wenn links > rechts sonst 1 # Abw√§rtsverh√§ltnis

Ordnung = sortiert(Bereich(n), Schl√ºssel=cmp_to_key(cmp))

Gesamt, Cur_time = 0, 0
f√ºr i in Ordnung:
Cur_time += mal[i]
Insgesamt Schaden[i] * cur_time
Gesamt
`` `

---

C++ (C++17)

```cpp
#include <bits/stdc++.h>
mit Namespace std;

Klasse L√∂sung {
√∂ffentlich:
lange minDamage(int power, vector<int>& damage, vector<int>ind>>& health) {
int n = Besch√§digung.size();
Vektor<int> t(n)
f√ºr (in i = 0; i < n; ++i)
t[i] = (Gesundheit[i] + Macht - 1) / Macht; // Schleier

vektor<int>>
iota(idx.begin(), idx.end(), 0)

Art(idx.begin(), idx.end(), [&](int a, int b)
lange links = 1LL * Schaden[a] * t[b];
lange rechts = 1LL * Schaden[b] * t[a];
zur√ºck nach links > rechts; // absteigendes Verh√§ltnis
})

lange ans = 0, cur = 0;
f√ºr (int id : idx) {
= t[id];
ans += 1LL * Schaden[id] * Cur;
}
R√ºckgabe ans;
}
};
`` `

---

oder 8. Das Gute, das Schlechte und das Ugly <a name="the-good-the-bad-and-the-ugly">/a>

### The Good
- **Simplicity**: Sobald Sie erkennen, dass es sich um ein gewichtetes Schieduling-Problem handelt, ist die L√∂sung ein einziger `O(n log n)`-Typ.
**Reusability**: In vielen Interviewproblemen erscheinen kundenspezifische Komparatoren.
- **Deterministisch**: Die Antwort ist garantiert optimal; keine R√ºckverfolgung erforderlich.

### Das B√∂se
- **Sorting-Kosten**: F√ºr riesige `n` dominiert der Schritt `O(n log n)`, aber es gibt keinen Weg um ihn herum (es sei denn, Sie verwenden Bucket‚Äêsort Tricks, die selten erwartet werden).
- **Postielle Verwirrung**: Anf√§nger k√∂nnten denken, dass sie Feinde schneller beenden k√∂nnen, indem sie zwischen ihnen ‚ÄúSchalten‚Äù und f√ºhren zu exponentiellen Komplexit√§t.

### Die Ugly
- **Over-Optimierungsversuche*:
*Switching Feinde mid-attack* ‚Üí Sie enden, ein riesiges DP zu schreiben, das nie bezahlt.
*Die Verwendung von Priorit√§tswarten* ‚Üí √ºberkompliziert die L√∂sung.

Der Schl√ºssel besteht darin, ** die Ordnung nach dem Anlegen der Verh√§ltnisregel nach unten zu sperren und dann einfach die Angriffe zu simulieren.

---

oder 9. Alternate Approaches & Variants <a name="alternate-approaches--variants">/a>

| Ansatz | Wenn es n√ºtzlich ist |
|---------------------------
| **DP auf sortierter Bestellung** | Wenn Einschr√§nkungen klein waren (n ‚â§ 20), k√∂nnten Sie Kraft brechen oder DP auf Permutationen verwenden. |
| **Greedy mit min‚Äêheap*** Wenn Feinde variable `power` oder dynamische Gesundheit haben k√∂nnen; Sie m√ºssen das Verh√§ltnis nach jedem Angriff neu bewerten. |
| **Bucket-Sortung** | Wenn `Schaden / t`-Verh√§ltnis durch eine kleine ganze Zahl (z.B. ‚â§ 10) begrenzt ist, k√∂nnen Sie in O(n) bucket‚Äêsortieren. |
| **Parallel-Angriffe** | Nicht anwendbar hier; aber wenn Bob mehrere Feinde pro Sekunde angreifen k√∂nnte, √§ndert sich das Modell an *multi-prozessor scheduling*. |

---

oder 10. Take‚Äêaway for Interviews & Your Job Hunt <a name="take-away-for-interviews--your-job-hunt">/a>

ANHANG **Identifizieren Sie das Muster* ‚Äì Die gewichtete Abschlusszeit erscheint in Planung, Jobplanung und vielen ‚ÄûMindestkosten‚Äú-Problemen.
2. **Erkl√§ren Sie Ihre Argumentation** ‚Äì Sprechen Sie durch, warum der Abschluss eines Gegners vor einem anderen immer optimal ist.
3. **Zeigen Sie den Komparator** ‚Äì Schreiben Sie einen benutzerdefinierten Vergleich in Java/C++ oder verwenden Sie `cmp_to_key` in Python.
4. **H√§ndle gro√üe Zahlen** ‚Äì Stellen Sie immer Fragen zu den Datentypen, zeigen Sie das Bewusstsein f√ºr √úberlauf.
5. ** Zeit- und Raumkomplexit√§t* ‚Äì Halten Sie die Diskussion pr√§zise; Interviewer lieben zu sehen, k√∂nnen Sie quantifizieren.

Wenn Sie dieses Problem l√∂sen, schreiben Sie nicht nur Code ‚Äì Sie zeigen den Interviewer, dass Sie k√∂nnen:

- Erkennen Sie eine klassische algorithmische Vorlage.
- Bewerben Sie es mit sorgf√§ltigem Umgang mit Zw√§ngen.
- Liefern Sie eine saubere, effiziente L√∂sung in mehreren Sprachen.

---

11. Fazit < a name="conclusion">/a>

LeetCode 3273 ist ein gl√§nzendes Beispiel von **algorithmischer Eleganz*: ein einfaches, real-world-Szenario, das in das klassische *gewichtete Vervollst√§ndigungszeit*-Problem destilliert wird.
Von:

ANHANG Die Angriffszeit `ti` f√ºr jeden Feind.
2. Sortieren von Feinden nach dem Verh√§ltnis `di / ti`.
3. Beaufschlagung des Schadens mit einem einzigen Durchgang,

Sie erhalten die optimale Antwort in **O(n log n)** Zeit.

Denken Sie daran, 64-Bit-Integer zu verwenden, unn√∂tige Floating‚ÄêPoint-Arbeit zu vermeiden und nie Angriffe zu interleave ‚Äì ohne dass Sie etwas tun * falsch*.

Mit diesem Verst√§ndnis, Sie werden die Frage auf **LeetCode**, beeindrucken Sie Ihre Einstellung Manager und bewegen einen Schritt n√§her, um Ihren Traumjob zu landen! üöÄ

---

*Happy Codierung!* üë© üíª üíª