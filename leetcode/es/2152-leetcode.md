-...
T√≠tulo: LeetCode 2152. N√∫mero m√≠nimo de l√≠neas a puntos de cobertura -
descripci√≥n: Titular
Fecha: 2025-09-21
categor√≠as: []
autor: muses
tags: []
HideToc: verdadero
-...
# üöÄ ‚ÄúMinimum Number of Lines to Cover Points‚Äù ‚Äì LeetCode 2152
## üìö Problema general
TENIDO ANTERIOR ANTERIOR ANTERIOR
Silencio...
Silencioso **LeetCode ID**
Silencioso **Dificultad**
Silencio **T√≠tulo** Silencio N√∫mero M√≠nimo de L√≠neas a Puntos de Cubierta
Silencio **Core Idea** Silencio Encuentra el conjunto m√°s peque√±o de l√≠neas rectas que cubren todos los puntos dados en un plan XY. Silencio
tenci√≥n **Constraints** tenci√≥n `1 ‚â§ puntos.length ‚â§ 10`, `puntos[i] = [xi, yi]`, todos los puntos √∫nicos, `-100 ‚â§ xi, yi ‚â§ 100`. Silencio

‚ñ† ** Objetivo**: Devuelve el n√∫mero m√≠nimo de l√≠neas rectas necesarias para cubrir cada punto.

-...

##  Settlement Why You should Master This Problem

* **Interview staple** ‚Äì Muchas empresas tecnol√≥gicas piden esto para probar la optimizaci√≥n combinatoria, la recursi√≥n, el mordisco y las habilidades de DP.
* **Versatilidad ling√º√≠stica** ‚Äì Existen soluciones en **Java, Python y C++**. La demostraci√≥n de la competencia entre los idiomas muestra flexibilidad a los administradores de contrataci√≥n.
* ** Profundidad de algoritmo* Aprender√°s a cambiar brute‚Äêforce vs. memoization, y c√≥mo manejar el estado con m√°scaras de bit.

-...

Estrategias de alto nivel

TENIDO TERRIENTE Complejidad ANTERIOR Cuando se utiliza
Silencio----------------------------
Silencio **Recursivo + Brute‚ÄêForce** Silencio `O(n^3)` (caso peor) TENIDO Small `n` (‚â§ 10) ‚Äì simple de c√≥digo
tenci√≥n **DFS + Bitmask DP** Silencioso `O(n^3 * 2^n)` ‚Üê Comercio equilibrado para `n` ‚â§ 10
Silencio **Recuperaci√≥n Memoizada** Silencio Mismo que DP, pero a menudo m√°s f√°cil de entender Silencio Cuando usted desea evitar tablas expl√≠citas DP

‚ñ† **La mejor elecci√≥n**: Para `n ‚â§ 10`, el DFS + bitmask DP es eficiente y f√°cil de implementar.
‚ñ† **El mejor lugar**: 10 puntos ‚Üí 1024 estados ‚Üí perfectamente bien.

-...

## üì¶ Code Implementations

A continuaci√≥n encontrar√° soluciones totalmente adaptadas en **Java, Python y C+**.
Cada fragmento de c√≥digo incluye:

* Un peque√±o arn√©s de prueba (m√©todo opcional `main` / `if __name_ == "__main__":`).
* Firmas de funciones claras que coinciden con el estilo LeetCode.
* Inline comments explaining each step.

-...

#### 1down‚É£ Java (Bitmask + DFS)

``java
importar java.util*;

Clase Soluci√≥n {
// M√°scara de blanco: todos los puntos cubiertos
blanco privado M√°scara;
// Mapa de la memoria: clave - confianza L√≠neas m√≠nimas
mapa privado: Integer, Integer memo;

public int minimumLines(int[][] points) {
int n = puntos. longitud;
objetivo M√°scara = (1 < > >
memo = nuevo HashMap garantizado();
dfs(0, puntos);
}

// DFS sobre estado de bitmask
int privado dfs(inmascara, int[] puntos) {
si (mask == targetMask) retorno 0; // todos los puntos cubiertos
si (memo.containsKey(mask))) devuelve memo.get(mask);

// Encontrar el primer punto descubierto
int first = 0;
(m√∫sica) (m√∫sica) 0) primero++;

int best = Integer.MAX_VALUE;

// Trate de dibujar una l√≠nea que pasa por 'primero' y alg√∫n otro punto
para (int i = 0; i) i++) {
si (i == primera tenci√≥n involuntaria (mask > (1 > ) 0) continuar;
int newMask = mascara ¬¶ (1 ◊ô se hizo primero)

doble pendiente = pendiente (puntos [primer], puntos[i]);

// Incluir todos los puntos en esta l√≠nea
para (int j = 0; j)
si (j ==primer TENIDO TENIDO J == i) contin√∫an;
si (mask " (1 " ) 0) continuar;
si (Double.compare(slope, slope(points[first], points[j])) == 0)
newMask tenci√≥n= (1 iere escrito j);
}
mejor = Math.min(best, 1 + dfs(newMask, points));
}

// Caso de borde: todos los puntos restantes son collinear con 'primero '
si (mejor == entero. MAX_VALUE) best = 1;

memo.put(mask, best);
devolver mejor;
}

doble pendiente privada(int[] a, int[] b) {
// Evite la divisi√≥n por cero: l√≠nea vertical - t√≠tulo Infinity
si (a[0] == b[0]) devolver Doble. POSITIVE_INFINITY;
(doble)(b[1] - a[1]) / (b[0] - a[0]);
}

// -------- Arn√©s de prueba...
public static void main(String[] args) {
Soluci√≥n sol = nueva soluci√≥n ();
int[][] points1 = {0,1},{2,3},{4,5},{4,3};
int[][] points2 = {0,2},{-2,-2},{1,4};
System.out.println("Ejemplo 1: " + sol.minimumLines(puntos1)); // 2
System.out.println("Ejemplo 2: " + sol.minimumLines(puntos2)); // 1
}
}
`` `

-...

Python (Bitmask + DFS)

``python
desde functools import lru_cache
de la importaci√≥n Lista

Soluci√≥n de clase:
m√≠nimo L√≠neas(auto, puntos: List[List[int]]) - int:
n = len(puntos)
objetivo = (1  se realiz√≥ n) - 1

def slope(a, b):
si a[0] == b[0]:
# l√≠nea vertical #
(b[1] - a[1]) / (b[0] - a[0])

@lru_cache(None)
def dfs(mask: int) - t√≠tulo int:
si m√°scara == objetivo:
retorno 0
# Find first uncovered point
primero = 0
mientras que la m√°scara " (1
primero += 1

mejor = flotante('inf')
para i en rango(n):
si == primero o mascara " (1 " )
continuar
new_mask = mascara tenci√≥n (1 iere primero)
sl = pendiente(puntos [primer], puntos[i])

para j en rango(n):
si j in (primero, i) o mascara " (1 " )
continuar
si abs(sl - pendiente(puntos [primer], puntos[j])) 1e-9:
new_mask TENIDO= (1 ANTE 10)

mejor = min(mejor, 1 + dfs(new_mask)

retorno 1 si mejor == flotante('inf') mejor

devolver dfs(0)

# -------- Arn√©s de prueba...
si __name_ == "__main__":
sol = Soluci√≥n()
print(sol.minimumLines([0,1],[2,3],[4,5],[4,3]]) # 2
print(sol.minimumLines([0,2],[-2,-2],[1,4])) # 1
`` `

-...

### 3down‚É£ C++ (Bitmask + DFS)

``cpp
#include ◊ôbits/stdc++.h
usando std namespace;

Clase Soluci√≥n {
public:
int minimumLines(vector seleccionadovector fielint estrecho puntos) {
int n = points.size();
int target = (1 " identificados " ) - 1;
vector implicado memo(1  se realiz√≥ n, -1);
dfs(0, puntos, objetivo, memo);
}

privado:
doble pendiente(cont vector identificadoint limitada a, const vector implicado
si (a[0] == b[0]) devuelve numeric_limites obtenidosdouble t√≠tulo::infinity(); // vertical
retorno est√°tico_cast observadodouble(b[1] - a[1]) / (b[0] - a[0]);
}

int dfs(int mask, const vector seleccionadovector identificadoint cuanto usa pts, int target, vector interpretadoint
si (mask == target) retorno 0;
si (memo[mask] != -1) memo de retorno;

// Encontrar el primer punto descubierto
int first = 0;
mientras que (mask " (1 " se hizo primero) " ;

int best = INT_MAX;
para (int i = 0; i) ++i) {
si (i == primera tenci√≥n infligida (mask " (1  obtenidos i)))) contin√∫an;
int newMask = mascara ¬¶ (1 ◊ô se hizo primero)
doble sl = pendiente(pts[first], pts[i]);

para (int j = 0; j) ++j) {
si (j == first TENIDO EN SUPERVISI√ìN J == i ANTERIVADA (mask " (1 " identificados j))) contin√∫an;
si (abs(sl - slope(pts[first], pts[j]))
newMask tenci√≥n= (1 iere escrito j);
}
mejor = min(mejor, 1 + dfs(newMask, pts, target, memo));
}

si (mejor == INT_MAX) mejor = 1; // Todos los puntos restantes collinear con el primero
memo[mask] = best;
devolver mejor;
}
};

// -------- Arn√©s de prueba...
int main() {}
Soluci√≥n s;
vector de vectores pts1 = {0,1},{2,3},{4,5},{4,3}};
vector de vectores pts2 = {0,2},{-2,-2},{1,4};
cout se realiz√≥ s.minimumLines(pts1)
cout se realiz√≥ s.minimumLines(pts2)
retorno 0;
}
`` `

-...

## üìä Complexity Breakdown

TEN TERRITOR SON TEN ANTERIOR ANTERIOR ANTERIOR TERRITORIO ANTERIOR ANTERIOR ANTERIOR ANTERIOR
Silencio------Prince--------
Silencio **C√°lculo de la pendiente**
Silencio **Las transiciones estatales de las Fuerzas de Defensa**
Silencio **N√∫mero de estados** Silencio `2^n` Silencio ‚â§ 1024 Silencio
tenci√≥n **Total** Silencioso `O(n^3 * 2^n)` Silencio ‚â§ `10^5` operaciones, > 1 ms en la pr√°ctica

¬øPor qu√© no?
‚ñ† 1. Elija el primer punto descubierto (`n`).
‚ñ† 2. Parla con cualquier otro punto descubierto (`n`).
‚ñ† 3. Escanear el resto para recoger puntos collineales (`n`).

‚ñ† **Espacio** ‚Äì Memo tabla del tama√±o `2^n` (‚â§ 1024 enteros).

-...

## üîÑ Alternative: Pure Brute‚ÄêForce (Recursive)

Si prefieres una soluci√≥n ** "no-memo"** para la m√°xima legibilidad, el siguiente esqueleto Python funciona para 'n ‚â§ 10'.

``python
def brute_force(puntos):
n = len(puntos)
mejor = n

def helper(descubierto):
no local mejor
si no se descubre: # todos los puntos cubiertos
retorno 0
si len(descubierto) lo mejor: # podando
mejor

primero = descubierto[0]
por segundo en descubierto[1:]:
line_points = [p for p in uncovered if on_same_line(first, second, p)]
new_uncovered = [p for p in uncovered if p not in line_points]
mejor = min(best, 1 + helper(new_uncovered)
mejor

helper(puntos)
`` `

‚ñ† **Drawback** ‚Äì Sin memoizaci√≥n, pero a√∫n as√≠ se hicieron permutaciones.

-...

## üéØ Take‚ÄêAway Checklist (Entreview)

1. ** Representaci√≥n del Estado* *
* Use una m√°scara de bits (`int mask`) ‚Äì cada bit representa si un punto ya est√° cubierto.
2. **Recursivo DFS**
* Escoge el primer punto descubierto, empareja con otro punto, construye una l√≠nea, y recurre a la nueva m√°scara.
3. **Memoizaci√≥n / DP**
* Resultados de cach√© para cada m√°scara (`lru_cache` en Python, `unordered_map` o vector en Java/C++).
4. **Manejo de pendiente**
* L√≠neas verticales con `Infinity ' o `numeric_limits realizadasdouble::infinity()`.
* Use una tolerancia (`1e‚Äê9`) al comparar las pendientes de punto flotante.

5. ** Casos de emergencia**
* Todos los puntos restantes collinear con el primer punto descubierto ‚Üí utilizar una l√≠nea.

-...

## üìà Big‚ÄêO Summary (DFS + Bitmask)

TEN TERRITOR TEN TEN ANTE
Silencio...
Silencio ** Tiempo** Silencioso `O(n^3 * 2^n)` Silencio
tenci√≥n **Espacio** Silencioso `O(2^n)` para la memoizaci√≥n + pila de recursi√≥n (`‚â§ 10` niveles). Silencio
Silencio **Pr√°ctico** Silencio Para `n = 10` ‚Üí 1024 estados, ‚ô• 5 √ó 105 operaciones - se ejecuta en

-...

## üõ† Qu√© mostrar en su resumen

Esqu√≠a en la vida √∫til Silencio
Silencio...
Silencio ** Algorithm Design** ‚Üê ‚ÄúSolved LeetCode 2152 usando DFS con bit-mask DP para minimizar las l√≠neas que cubren hasta 10 puntos‚Äù. Silencio
Silencio ** An√°lisis de la complejidad** Silencioso ‚ÄúConseguido `O(n3¬∑2n) ` tiempo y `O(2n) ` espacio; demostr√≥ la memoizaci√≥n completa.‚Äù Silencio
Silencio **Multilingual** Silencioso ‚ÄúSoluciones ampliadas en **Java, Python y C+**, mostrando fluidez en el lenguaje cruzado‚Äù. Silencio
"Us√≥ este problema para conseguir un papel en XYZ Tech ‚Äì entrevista comentarios elogi√≥ mi clara estrategia de codificaci√≥n estatal". Silencio

‚ñ† **Tip**: Al responder preguntas de entrevista, comience con la traducci√≥n **problema-transformaci√≥n** (bitmask, DP, recursion), luego explique el **state** y **transiciones**. Muestra tu an√°lisis de complejidad para probar que entendiste las operaciones.

-...

##  inaceptable Bonus ‚Äì Quick‚ÄêStart Playground

Si desea experimentar localmente, simplemente copiar el fragmento de idioma elegido en un archivo y ejecutarlo. La secci√≥n incluida `main`/`if __name_ == "__main__":` imprimir√° las salidas esperadas:

``bash
Soluci√≥n de javac. java " java Solution
Ejemplo 1: 2
Ejemplo 2: 1

Soluci√≥n de $ pit√≥n3. py
2
1

$ ./a.out
2
1
`` `

-...

## üéØ Final Take‚Äê Away

* Para LeetCode 2152, **DFS + Bitmask DP** es el lugar dulce: elegante, r√°pido y ling√º√≠stico-agn√≥stico.
* Master the **state‚Äêencoding** (caras bit) y **memoization** patrones ‚Äì son √∫tiles para una amplia variedad de problemas de entrevista (por ejemplo, ‚ÄúSet Cover‚Äù, ‚ÄúMaximum Subsequence‚Äù, ‚ÄúStickers to Spell Word‚Äù).
* Pr√°ctica que explica el algoritmo, la complejidad y los casos de borde ‚Äì comunicaci√≥n clara es la mitad de la entrevista gana!

Buena suerte, y feliz codificaci√≥n! üöÄ

-...

‚ñ† **Meta Descripci√≥n** ‚Äì ‚ÄúSolve LeetCode 2152: N√∫mero m√≠nimo de l√≠neas a puntos de cubierta. Obtenga las soluciones √≥ptimas Java, Python y C+++, an√°lisis algor√≠tmico y consejos de entrevista para llegar a su pr√≥xima entrevista de trabajo. ‚Äù