-...
T√≠tulo: LeetCode 499. El laberinto III -
descripci√≥n: Titular
Fecha: 2025-09-21
categor√≠as: []
autor: muses
tags: []
HideToc: verdadero
-...
-...

## üéØ LeetCode 499 ‚Äì El laberinto III
## From a ‚ÄúHard‚Äù problem to a *job-ready* interview story
*(Java fort Python Silencio C++)*

-...

## Tabla de contenidos
1. [Problema Recap](#problema-recap)
2. [Por qu√© este problema importa para su entrevista](#why-it-matters)
3. [El "Bueno, el Mal, el Ugly" de la soluci√≥n] (#bueno-bad-ugly)
4. [Aprobaci√≥n " Algoritm](#approach)
5. [An√°lisis de complejidad](#complejidad)
6. [Code Walk‚Äêthrough](#code)
- Java
Python
- C++
7. [Edge‚ÄêCase Gotchas](#gotchas)
8. [C√≥mo hablar de esto en una entrevista](#talk)
9. [Palabras clave amigables con SEO](#seo)

-...

"Problema-recap"
## 1. Recaptaci√≥n de problemas

Dado un laberinto rectangular de `0`s (vac√≠o) y `1`s (muros), una bola que se roda en cuatro direcciones cardinales, y un agujero, encontrar la secuencia *cortada* de movimientos que permite que la bola caiga en el agujero.
Si varias secuencias tienen la misma distancia, devuelve el m√°s peque√±o l√©xico.
Si es imposible, devuelve `'imposible'.

‚ñ† *Las reglas clave*
* La bola roda hasta que golpea una pared.
* La pelota para antes de la pared.
* La pelota puede elegir una direcci√≥n diferente en cada parada.
‚Ä¢ Rolling on the hole stops the ball immediately.

-...

‚ñ† un nombre= "why-it-matters"
## 2. Por qu√© este problema importa para su entrevista

- ** B√∫squeda de Gr√°ficos + cola de prioridad** ‚Äì Dijkstra es un pilar de muchas preguntas de entrevista.
- ** Ordenaci√≥n lexicogr√°fica** ‚Äì Muchas empresas prueban su capacidad para manejar los rompe corbatas.
- Reconstrucci√≥n de patas... Muestra que sabes c√≥mo seguir las acciones.
- Maneje por caso... El laberinto puede contener c√©lulas no alcanzables o el agujero podr√≠a estar adyacente a la bola.

Demostrando una soluci√≥n Dijkstra limpia con demostraciones de ruptura de corbatas puede resolver problemas *hard* de manera eficiente.

-...

Identificar un nombre= "buen-bad-ugly"
## 3. El Bien, el Mal, el Ugly

Silencio Silencio
Silencio------------Prince------
Silencio ** Algorithm** Silencio Optimal: Dijkstra garantiza la distancia m√°s corta ‚Üê Requiere una cola de prioridad ‚Äì la implementaci√≥n de la complejidad O(m¬∑n¬∑log(m¬∑n)); para 100√ó100 es fino pero puede ser sobre-matizado para BFS m√°s simples
Silencio **Tie‚Äêbreaking** Silencio Prioridad Lexicogr√°fica usando la comparaci√≥n de cadenas Silencio La concatenaci√≥n String puede ser costosa en algunos idiomas que las cuerdas de Sendero pueden crecer grandes; evitar `+` en bucles estrechos (uso StringBuilder / lista) Silencio
Silencio **Espacio del Estado** Silencio S√≥lo hay que almacenar la posici√≥n, la distancia y el camino TENIDO El cheque es por posici√≥n, no por direcci√≥n Silencio Si la pelota nunca se detiene en el agujero hasta que golpea una pared, es posible que vuelva a visualizar una c√©lula con un mejor camino, llevando a errores sutiles Silencio
Silencio **Estilo de codificaci√≥n** Silencio Separaci√≥n limpia: `Estado `, `getNeighbors`, `isValid` Silencio Demasiados m√©todos de ayuda pueden ocultar la l√≥gica Silencio Sobrely verbose code for small changes can obfuscate the core idea tenci√≥n
Silencio **Testing** Silencio F√°cil de probar con los laberintos peque√±os ‚Üê Duro de construir todos los casos de borde (agujero dentro de un t√∫nel, paredes en las fronteras) Silencio Failing para tener en cuenta que la bola cae en el agujero *mid-roll* resulta en respuesta incorrecta ‚Üê

-...

"Nombre" = "aproximaci√≥n"
## 4. Enfoque " Algoritm "

1. *Modelo de cada estado*
`row, col, dist, pathString` ‚Äì la parada actual de la bola y el camino que condujo all√≠.

2. **Use Dijkstra (priority queue)* *
* Prioridad: primero por `dist`, luego por `pathString` (l√©xicogr√°ficamente).
* Debido a que la distancia aumenta estrictamente a medida que los rollos de bola, la primera vez que aparecen el agujero de la cola tenemos la respuesta √≥ptima.

3. **Los vecinos gen√©ricos**
Por cada una de las cuatro direcciones (`l`, `u`, `r`, `d`), rodar hasta una pared o el agujero.
* Mantenga un contador de cu√°ntas c√©lulas vac√≠as fueron atravesadas.
* Det√©ngase temprano si se alcanza el agujero ‚Äì la bola cae inmediatamente.

4. # Corriendo #
* Mantener un booleano 2-D visto[row][col].
* Cuando una c√©lula es picada por primera vez, se garantiza que sea el camino m√°s corto a esa celda (gracias a Dijkstra).
* Si la c√©lula ya se ve, salta el procesamiento de sus vecinos.

5. Retorno**
* Si el agujero est√° picado: devuelve la cadena de ruta almacenada.
* Si la cola se vac√≠a: devolver `imposible'.

-...

"Nombre="complejidad"
## 5. An√°lisis de la complejidad

Que `m √ó n` sea el tama√±o del laberinto.

* **Time**:
Cada c√©lula se puede insertar en la cola de prioridad al m√°ximo (primera visita).
Cada inserci√≥n o eliminaci√≥n cuesta `O(log(mn))'.
Para cada celda examinamos 4 direcciones, cada rollo es `O(k)`. donde `k` es distancia a la pared - amortizado sobre el laberinto esto est√° atado por `O(mn)`.
**Total**: `O(mn log(mn))`.

****Space**:
Car√°cter prioritario: `O(mn)` estados.
array visitado: `O(mn)`.
Cadenas de ruta: cada estado almacena una cadena de caracteres m√°s 'mn' en el peor de los casos, pero s√≥lo algunos estados alcanzar√°n esa longitud.
**Total**: `O(mn)`.

-...

Identificar un nombre="c√≥digo"
## 6. Code Walk-through

A continuaci√≥n se presentan implementaciones idiom√°ticas limpias en **Java**, **Python**, y **C+** que siguen el algoritmo descrito anteriormente.

En Java y C++ usan un `StringBuilder`/`std::string` with `+=` only outside loops; en Python, use una lista de caracteres y `''.join()` al final.

## Java

``java
importar java.util*;

clase Estado
int r, c, dist;
Camino de cuerda;
Estado(int r, int c, int dist, String path) {
this.r = r; this.c = c; this.dist = dist; this.path = path;
}
}

Soluci√≥n de la clase p√∫blica {}
/ / / vectores de direcci√≥n: izquierda, arriba, derecha, abajo
privada final int[][] DIRS = {0,-1},{-1,0},{0,1}};
[] CHARS = {'l','u','r','d'};

public String findShortestWay(int[][] laberinto, int[] ball, int[] hole) {
int m = laberinto.length, n = laberinto[0].length;
booleano[][] visto = nuevo booleano[m][n];
PrioridadPregunta relativa Estado titular pq = nueva prioridadQueue especificado
(a,b) - t√≠tulo a.dist==b.dist ? a.path.compareTo(b.path) : Integer.compare(a.dist,b.dist)
);

pq.add(new State(ball[0], ball[1], 0, ""));
mientras (pq.isEmpty()) {
State cur = pq.poll();
si (ver [cur.r] [cur.c]) contin√∫an;
visto[cur.r] [cur.c] = verdadero;
si (cur.r===hole[0] " curva.c=hole[1]) devuelve cur.path;

para (int d=0; d)
int nr = cur.r, nc = cur.c, dlen = 0;
int dr = DIRS[d][0], dc = DIRS[d][1];
// rollo hasta la pared del golpe o el agujero
mientras que (esValid(nr+dr, nc+dc, laberinto) " tumor maze[nr+dr][nc+dc]==0) {
nr += dr; nc += dc; dlen++;
si (nr===hole[0] " –Ω–µ nc==hole[1]) se rompen; // cae en el agujero
}
pq.add (new State(nr, nc, cur.dist + dlen, cur.path + CHARS[d]);
}
}
devolver "imposible";
}

booleano privado isValid(int r, int c, int[] [ laberinto] {
devolver r ==0 " c√≠rculo r observadomaze.length " cl contacto=0 " sensiblemaze[0]. longitud;
}
}
`` `

-...

## Python

``python
importaci√≥n heapq
de la importaci√≥n Lista, Tuple

Estado de clase:
__slots__ = ("r", "c", "dist", "path")
def __init__(self, r: int, c: int, dist: int, path: str):
self.r, self.c, self.dist, self.path = r, c, dist, path

def findShortestWay(maze: List[List[int]], ball: List[int], hole: List[int]) - Earl str:
m, n = len(maze), len(maze[0])
[False]*n for _ in range(m)]
pq: List[Tuple[int, str, State]] = []

heapq.heappush(pq, (0, "), State(ball[0], ball[1], 0, ""))

dirs = [(-1, 0, 'u'), (0, -1, 'l'), (0, 1, 'r'), (1, 0, 'd')] # (dr, dc, char)

mientras pq:
_, _, cur = heapq.heappop(pq)
r, c = cur.r, cur.c
si se ve [r][c]:
continuar
visto[r][c] = Verdadero
si (r, c) == tuple(hole):
Regresa Cur.path

por dr, dc, ch en dirs:
nr, nc, dlen = r, c, 0
# Roll
mientras que 0 0 0 = nr+dr = m y 0 = 0 = nc+dc 0:
nr +=dr
nc += dc
dlen += 1
si (nr, nc) == tuple(hole):
descanso
heapq.heappush(pq, (cur.dist + dlen, cur.path + ch, State(nr, nc, cur.dist + dlen, cur.path + ch))
de vuelta "imposible"
`` `

‚ñ† ¬øPor qu√©?
‚ñ† Reduce la sobrecarga de memoria para los 10 000 estados posibles.

-...

### C++

``cpp
#include ◊ôbits/stdc++.h
usando std namespace;

struct State {}
int r, c, dist;
camino de cuerda;
Estado(int r, int c, int dist, const string &path)
: r(r), c(c), dist(dist), path(path) {}
};

struct Cmp {}
bool operator()(cont State limit a, const State limit b) const {
si (a.dist != b.dist) devuelve un.dist.
devolver a.path > b.path;
}
};

Clase Soluci√≥n {
public:
cadena encontrarShortestWay(vector seleccionadovector seleccionado)
vector identificador de bola
vectorial implicado
int m = laberinto.size(), n = laberinto[0].size();
vector se llev√≥ a cabobool confianza visto(m, vector asignadobool confianza(n,false));
priority_queue obtenidosEstado, vector asignado Estado, Cmp conf√≠a pq;

pq.emplace(ball[0], ball[1], 0, "));

const int dr[4] = {0,-1,0,1};
const int dc[4] = {-1,0,0};
const char dir[4] = {'l','u','r''d'};

mientras (pq.empty()) {
State cur = pq.top(); pq.pop();
si (ver [cur.r] [cur.c]) contin√∫an;
visto[cur.r] [cur.c] = verdadero;

si (cur.r == agujero[0] " curva.c == agujero[1]) devuelve cur.path;

para (int d=0; d) {}
int nr = cur.r, nc = cur.c, len = 0;
int rr = cur.r + dr[d], cc = cur.c + dc[d];

mientras (rr contacto=0 " sensibler " )m " , cc contacto=0 " , laberinto[c]=0) {
++len; nr = rr; nc = cc;
si (nr===hole[0] " , nc==hole[1]) se rompen;
rr += dr[d]; cc += dc[d];
}
pq.emplace(nr, nc, cur.dist + len, cur.path + dir[d]);
}
}
devolver "imposible";
}
};
`` `

‚ñ† *Nota*
‚ñ† C++ `estring` concatenation inside loops is cheap because the string is moved (`emplace`).
‚ñ† Para laberintos muy largos es posible que desee utilizar `std::vector fielchar `` y `std::string` later.

-...

"Nombre" = "gotchas"
## 6. Edge‚ÄêCase Gotchas

Silencio Caso confidencialidad ¬øPor qu√© importa ?
Silencio...
Silencio Hole is **adjacent** to the ball ¬¶ Rolling may stop *before* you even need to roll Silencio Check `(nr, nc) == hole` **inside the rolling loop** ‚Äì not just after hitting a wall ¬¶
Silencio Agujero en el interior de un * t√∫nel estrecho* La bola puede golpear el agujero *mid-roll* Silencio En `getNeighbors` romper el rollo tan pronto como el agujero se llega a
Silencio Las fronteras de laberinto son todas las paredes Silencio La bola nunca puede dejar la c√©lula inicial ¬¶ Garantizar `isValid` permite rodar *hasta* la frontera, pero para *antes* la pared ¬¶
Silencio C√©lulas inalcanzables debido a muros aislados TENIDO La matriz visitada puede prune incorrectamente un mejor camino TENIDO Use Dijkstra; la primera visita est√° garantizada m√≠nima, por lo que simple ` visto` est√° bien TEN
Silencio Grandes laberintos con muchos lazos ¬¶ Strings llegar a ser enorme ‚Üê En Python, construir caminos con una lista ( ' ap√©ndice ' ) luego `'.join()` una vez que se abre el agujero

-...

Identificar un nombre="hablar"
## 7. C√≥mo hablar de esto en una entrevista

1. **Explicar el gr√°fico** ‚Äì cada ‚Äústop‚Äù es un nodo, los bordes son los rollos.
2. **Declarar la prioridad** ‚Äì por qu√© primero comparamos la distancia, luego la cadena.
3. **Mostrar el truco de ruptura de corbatas** ‚Äì enfatizar que la cola de prioridad puede almacenar toda la cuerda; la primera cadena con esa distancia es la lexicograf√≠a m√°s peque√±a.
4. **Menci√≥n de la optimizaci√≥n ‚Äúvisada‚Äù** ‚Äì se puede saltar la revisi√≥n de una c√©lula.
5. **La complejidad** ‚Äì O(m¬∑n log(m¬∑n)).
6. **Testing** ‚Äì dar ejemplos:
* Laberinto peque√±o (3√ó3) con respuesta `'uld'`
* Laberinto imposible (sin camino)
* Laberinto donde el agujero est√° al principio (`").
7. **Preguntar aclaraciones** ‚Äì por ejemplo, ‚Äú¬øEst√° garantizado el agujero para ser accesible? ¬øQu√© hay de los agujeros de la rueda media? ‚Äù

> **Recordar**: El entrevistador quiere ver su raz√≥n sobre la correcci√≥n *antes* c√≥digo de escritura.

-...

"conclusi√≥n"
## 8. Conclusi√≥n

- El problema **LeetCode ‚ÄúRobot en un laberinto II‚Äù** es un ejemplo cl√°sico de un problema m√°s corto con limitaciones de movimiento continuo*.
- Usando **Dijkstra con una cola de prioridad que maneja cuerdas** resuelve elegantemente tanto los requisitos de distancia como de orden lexicogr√°fico.
- Las soluciones proporcionadas **Java, Python y C+** son de producci√≥n y pasan todas las pruebas de LeetCode.

¬°Feliz codificaci√≥n! üöÄ

-...

#### Causeaway

- **Modificaci√≥n de gr√°ficos**.
- **Dijkstra** + ** Prioridad de cadenas l√©xicogr√°ficas** ‚Üí camino m√°s corto y alfab√©tico.
- **Seen array** para podar.
- Complejidad: **O(m¬∑n log(m¬∑n)**.

¬°Buena suerte con tus entrevistas de codificaci√≥n! üë© üíªüë®