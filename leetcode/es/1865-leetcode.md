-...
T√≠tulo: LeetCode 1865. Encontrar parejas con un determinado sumo -
descripci√≥n: Titular
Fecha: 2025-09-21
categor√≠as: []
autor: muses
tags: []
HideToc: verdadero
-...
## üìö 1865 ‚Äì Encontrar parejas con cierto sumo
**Medium ‚ãÖ LeetCode ‚Üê Data‚ÄêStructure Design**

*‚ÄúQuiero mostrar a los reclutadores que puedo convertir un problema complicado en c√≥digo limpio y reutilizable.‚Äù*
‚ñ† Aqu√≠ hay un paseo completo:
* Problemas "
* Soluci√≥n elegante (marco de frecuencia basado en jash)
* Java / Python / C++ implementaciones
* Un art√≠culo *blog-ready* que destaca el **bueno, el malo y el feo** ‚Äì perfecto para LinkedIn, Medium, o su cartera personal.

-...

### 1. Recaptaci√≥n de problemas

Silencio . .
Silencio...
Silencio **Crear una estructura de datos** que apoye dos operaciones en dos arrays enteros `nums1` y `nums2`: Silencio
1. `add(index, val)` ‚Äì add `val` to `nums2[index]`. Silencio
Silencio 2. `contra(tot)` ‚Äì devolver el n√∫mero de pares `(i, j)` con `nums1[i] + nums2[j] == tot`. Silencio

TENIDO üìå FORMULADA CONTRATADOS
Silencio...
Silencioso `nums1.length ‚â§ 1 000`
Silencioso `nums2.length ‚â§ 105` Silencio
TENIDO `1 ‚â§ nums1[i], nums2[i] ‚â§ 105 ` (excepto `nums1[i] puede ser hasta `109`) Silencio
Silencio `add` ' ' llamado ‚â§ 1 000 veces cada uno. Silencio
TENIDO `0 ‚â§ √≠ndice Silencio
TENIDO `1 ‚â§ val ‚â§ 105` Silencio
√ò 109 " Silencio

El objetivo es mantener cada operaci√≥n r√°pida ‚Äì idealmente *O(1)* para `add` y *O(n1)* para `contra`, donde *n1* = `nums1.length`.

-...

### 2. Intuici√≥n

1. **Static vs. Dynamic**
*`nums1`* nunca cambia ‚Äì podemos iterar sobre √©l en cada `contra`.
*`nums2`* cambios ‚Äì necesitamos una manera r√°pida de saber cu√°ntas veces se produce un valor particular.

2. ** Mapa de frecuencia**
Mantenga un hash-map ( " valor ‚Üí cont " ) para `nums2`.
- **add**: decrementar el recuento del antiguo valor, a√±adir el recuento del nuevo valor.
- **cuenta**: por cada `x` en `nums1`, mira hacia arriba `tot - x` en el mapa y a√±ade su frecuencia.

3. *Por qu√© funciona*
Cada b√∫squeda en el hash‚Äêmap es *O(1)* en promedio.
`contra` toca cada elemento de `nums1` una vez ‚Üí *O(n1)*, que est√° bien porque `n1 ‚â§ 1 000`.
`add` is *O(1)*.
Memoria: almacenar frecuencias de los m√°s `105` n√∫meros diferentes ‚Üí *O(n2)*.

-...

### 3. C√≥digo - 3 idiomas

##### 3.1 Java

``java
importa java.util. HashMap;
importa java.util. Mapa;

clase p√∫blica FindSumPairs {
int privado final[] nums1;
int privado final[] nums2;
mapa final privado realizadoInteger, Integer confianza freq; // mapa de frecuencia de nums2

public FindSumPairs(int[] nums1, int[] nums2) {
este.nums1 = nums1;
este.nums2 = nums2;
este.freq = nuevo HashMap Quer√≠a();

para (int val : nums2) {
freq.put(val, freq.getOrDefault(val, 0) + 1);
}
}

* A√±adir +val a nums2[index] y actualizar el mapa de frecuencia. */
public void add(int index, int val) {
int old = nums2[index];
freq.put(old, freq.get(old) - 1); // decrement old count

nums2[index] += val;
int newVal = nums2[index];
freq.put(newVal, freq.get OrDefault(newVal, 0) + 1); // incremento de cuenta nueva
}

* Devuelve el n√∫mero de pares (i, j) donde nums1[i] + nums2[j] == tot. */
public int count(int tot) {}
int ans = 0;
para (int a : nums1) {}
int need = tot - a;
ans += freq.getOrDefault(necesidad, 0);
}
devolver los ans;
}
}
`` `

###### 3.2 Python

``python
de las importaciones de colecciones Contrato
de la importaci√≥n Lista

class FindSumPairs:
def __init__(self, nums1: List[int], nums2: List[int]):
self.nums1 = nums1
auto.nums2 = nums2
auto.freq = Counter(nums2) # mapa de frecuencia de nums2

def add(self, index: int, val: int) - Conf Ninguno.
viejo = self.nums2[index]
self.freq[old] -= 1 # Decremento antiguo valor

auto.nums2[index] += val
new_val = self.nums2[index]
self.freq[new_val] += 1 # Aumento de nuevo valor

def count(self, tot: int) - t√≠tulo int:
volver suma (self.freq[tot - a] para un auto.nums1)
`` `

##### 3.3 C++

``cpp
Incluido el t√≠tulo
#include ‚ñ†unordered_map Conf

class FindSumPairs {
public:
FindSumPairs(std::vector efectuadoint t√≠tulo nums1, std::vector fielint nums2)
: nums1(std::move(nums1)), nums2(std::move(nums2)) {
para (int v : este- rationums2) freq[v]++; // construir mapa de frecuencia
}

vacio a√±adir(indice, int val) {
int old = nums2[index];
--freq[old]; // decremento viejo cuenta

nums2[index] += val;
int newVal = nums2[index];
++freq[newVal]; // aumento de cuenta nueva
}

int count(int tot) {}
int ans = 0;
para (int a : nums1) {}
int need = tot - a;
auto = freq.find(neced);
if (it != freq.end()) ans += it- conf√≠asecond;
}
devolver los ans;
}

privado:
std::vector obtenidosint titulada nums1;
std::vector seleccionado noms2
std::unordered_map seleccionadaint, int confianza freq; // value ‚Üí count
};
`` `

Las tres soluciones comparten el mismo O(1) *add* y O(`nums1.length`) *contra* tiempo, haci√©ndolos ideales para los l√≠mites de LeetCode.

-...

### 4. Blog Art√≠culo ‚Äì ‚ÄúEl bien, el mal‚Äù

‚ñ† **Target audience**: reclutadores, entrevistadores y compa√±eros en LinkedIn/Medium.
‚ñ† **Palabras clave amigables de SEO**: *LeetCode 1865*, *FindSumPairs*, *data‚Äêstructure interview*, *hash map solution*, *O(1) add*, *job interview coding*, *Python Counter*, *C++ unordered_map*, *Java HashMap*.

-...

##### 4.1 Title > Meta

`` `
Identificar el t√≠tulo 1865 ‚Äì Design a Frequency‚ÄêBased FindSumPairs Data Structure
Contenido "Master LeetCode 1865 (FindSumPairs). Aprende un Java limpio, Python, soluci√≥n C++, an√°lisis de complejidad y consejos de entrevista. Perfecto para entrevistas de codificaci√≥n y escaparate de cartera."
`` `

#### 4.2 Tabla de contenidos (para legibilidad)

1. [El problema](El problema)
2. [Por qu√© el truco Hash-Map es la salsa secreta] (#hash-map-sauce)
3. [Algorithm & Complexity](#complexity)
4. [C√≥digo Completo](#code)
5. [The Good, The Bad & The Ugly](#pros-cons-ugly)
6. [Consejos de Interview](#interview-tips)
7. [Conclusi√≥n " Siguientes pasos](#conclusi√≥n)

-...

##### 4.3 El Bien

TENIDO TENIDO ANTERIOR Lo que amaba
Silencio...
TEN **Simplicidad** ‚Äì un mapa de frecuencia + dos lazos directos. Silencio
Silencio **Informaci√≥n** ‚Äì *O(1)* `add`, *O(n1)* `contra`. Silencio
tenci√≥n **Idioma Agnostic** ‚Äì la misma idea funciona en Java, Python, C++, Rust, Vamos, etc. Silencio
‚Üê **M√≥mory Footprint** ‚Äì s√≥lo cuenta de 'nums2` se almacenan, no todo el array. Silencio
TEN **Reusabilidad** ‚Äì se puede adaptar a otros problemas de ‚Äúfrecuencia dinamica + radio est√°tica‚Äù. Silencio

##### 4.4 The Bad

ANTE NOVEDAD ANTE LAS POTENCIAS Potenciales
Silencio.
Silencio **Large Frequency Map** ‚Äì si el `nums2` contiene muchos valores √∫nicos, el unordered_map/Counter puede utilizar hasta ~200 KB por entrada √∫nica, que todav√≠a est√° bien para los n√∫meros '105' pero vale la pena notar para entradas realmente masivas. Silencio
Silencio **Zero‚ÄêCount Keys** ‚Äì decremos cuenta pero nunca eliminamos las claves cuando el conteo alcanza cero. En un sistema del mundo real es posible que desee prune para mantener el mapa inclinado, pero la sobrecarga extra es insignificante dadas las limitaciones. Silencio
Silencio **Repetici√≥n Llamadas** ‚Äì iterating over `nums1` en cada llamada es *O(n1)*. Si `nums1` fuera m√°s grande, usted necesitar√≠a pre-computar algo m√°s (por ejemplo, una suma prefijo 2-D). Los l√≠mites del problema lo mantienen aceptable, pero el entrevistado debe mencionar este intercambio. Silencio

#### 4.5 The Ugly

Silencio üëø Silencio Casos Edge > Gotchas ocultas
Silencio.
Silencio **Desbordamiento entero** ‚Äì `t` puede ser hasta `109`. La adici√≥n de dos ints en C++/Java puede rebosar si utilizas tipos firmados de 32 bits; el uso de 'long' o 'long' para la suma intermedia es m√°s seguro en idiomas que no tienen ints de precisi√≥n arbitraria (JavaScript, C). En este problema las sumas permanecen dentro de 32 bits, pero siempre vigilan los l√≠mites. Silencio
tenci√≥n **Multiple Updates to the Same Index** ‚Äì Si `add` se llama repetidamente en el mismo √≠ndice, aseg√∫rese de que el mapa de frecuencia permanezca en sincron√≠a con el array subyacente. Un error com√∫n es olvidar actualizar el array despu√©s de decrementar el antiguo conteo. Silencio
¬øN√∫meros negativos?** ‚Äì Las restricciones oficiales proh√≠ben los valores negativos, pero si se ajusta el problema para permitirlos, el algoritmo todav√≠a funciona porque el hash‚Äêmap puede almacenar claves negativas. S√≥lo recuerda usar un tipo de entero *signed*. Silencio

-...

#### 4.6 Interview‚ÄêReady Pseudocode

``text
class FindSumPairs:
freq = mapa de los valores nums2

init(nums1, nums2):
construir freq de nums2

add(idx, val):
freq[nums2[idx]...
nums2[idx] += val
freq[nums2[idx]]++

Contando.
res = 0
para x en nums1:
res += freq[tot - x]
retorno
`` `

‚ñ† **Por qu√© es un ‚Äúshow‚Äêoff‚Äù para los reclutadores* *
* El entrevistador puede ver al instante que utiliz√≥ un *hash mapa* para convertir un array din√°mico en una mesa de b√∫squeda est√°tica.
* Usted explic√≥ la *amortizada* *O(1)* actualizaci√≥n, la consulta *O(n1)* y el intercambio espacial.
* Usted mostr√≥ m√©todos limpios y testables, listos para una API de grado de producci√≥n.

-...

### 5. Poni√©ndolo en su cartera

1. **Embed the Code** ‚Äì copy the Java, Python, and C++ snippets into a README or a GitHub Gist.
2. **Agregue un README** que incluya:
- Declaraci√≥n de problemas (copia de LeetCode)
- Arn√©s de prueba (pruebas individuales para los tres idiomas)
- ‚ÄúPon esto para ver la salida esperada‚Äù bloque.
3. **Link It** ‚Äì en tu enlace In article or on your personal site, add a link: `https://github.com/yourusername/leetcode-1865-findsumpairs`.
4. **Compartir en Medium** ‚Äì publicar el blog con los encabezados arriba. Tag with `#LeetCode`, `#CodingInterview`, `#DataStructures`, `#AlgorithmDesign`.

-...

### 6. Conclusi√≥n

- **LeetCode 1865** es un problema cl√°sico de ‚Äúdesign‚Äêa‚Äêdata‚Äêstructure‚Äù que prueba su capacidad de equilibrar **time-complexity** y **memory‚Äêefficiency**.
- El truco de frecuencia **hash‚Äêmap** es la soluci√≥n can√≥nica: actualizaciones O(1), consultas O(n1).
- Las implementaciones en **Java, Python, y C+** son directas y demuestran competencia en lenguaje cruzado.
- The **blog article** above is SEO‚Äêoptimized and ready to share‚Äîcomplete with keywords that recruiters love (`LeetCode 1865`, `FindSumPairs`, `Java HashMap`, `Python Counter`, `C++ unordered_map`, `job interview coding`).

Óåå **Siguiente paso:**
A√±ade tus propias pruebas de unidad, empuja el repo a GitHub y comienza un post de LinkedIn: *‚ÄúSolved LeetCode 1865 en Java, Python y C++ ‚Äì aprende c√≥mo dise√±√© una estructura de datos eficiente‚Äù*

Feliz codificaci√≥n, y la mejor suerte de aterrizar en la pr√≥xima entrevista! üöÄ