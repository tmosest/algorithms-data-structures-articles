-...
T√≠tulo: LeetCode 1942. El n√∫mero de la silla m√°s peque√±a ocupada -
descripci√≥n: Titular
Fecha: 2025-09-21
categor√≠as: []
autor: muses
tags: []
HideToc: verdadero
-...
Ll√°mame 1942. El n√∫mero de la silla m√°s peque√±a ocupada ‚Äì Soluci√≥n en **Java, Python & C++* *

A continuaci√≥n encontrar√° una implementaci√≥n limpia y lista para la producci√≥n del cl√°sico problema LeetCode ‚ÄúSmallest Unoccupied Chair‚Äù en tres idiomas.
Todas las soluciones utilizan **dos colas prioritarias (saltos)** ‚Äì una para sillas disponibles y una para sillas ocupadas ordenados por el tiempo de salida ‚Äì dando un **O(n log n)** tiempo y **O(n)** complejidad espacial.

-...

## Problema Recap

‚ñ† Est√°s en una fiesta con **n** amigos (√≠ndices basados en 0).
‚ñ† Hay infinitamente muchas sillas numeradas 0...‚àû.
‚ñ† Cuando llega un amigo, toman la silla inocupada.
‚ñ† Cuando un amigo sale de la silla se libera inmediatamente y puede ser tomado por alguien que llega al mismo tiempo.
[arrival_i, departure_i]` (Los tiempos de llegada son distintos).
‚ñ† Devuelve el n√∫mero de silla que **targetFriend** ocupar√°.

-...

## 1. Python 3 ‚Äì 9 l√≠neas (dos montones)

``python
importaci√≥n heapq
de la importaci√≥n Lista

Soluci√≥n de clase:
def m√°s peque√±o Chair(self, times: List[List[int]], targetFriend: int) - t√≠tulo int:
# 1 Ordenar amigos por hora de llegada
orden = orden(range(len(times)), key=lambda i: times[i][0])

# 2‚É£ Montaje de sillas libres (inicialmente 0...n-1), mont√≥n de sillas ocupadas (departamento, asiento)
libre, ocupado = lista(range(len(times))), []

para idx en orden:
llegar, salir = tiempos[idx]

# 3Ô∏è Libere todas las sillas cuyo propietario ha dejado por el tiempo de llegada
mientras que ocupado y ocupado [0] [0]
heapq.heappush(gratis, heapq.heappop(ocupado)[1])

# 4Ô∏è Coge la silla libre m√°s peque√±a
silla = heapq.heappop(gratuito)

si idx == objetivo Amigo: # üéØ Found the answer
silla de retorno

# 5Ô∏è Silla de la marca como ocupada hasta 'leave '
heapq.heappush(ocupado, (leave, chair))
`` `

**Por qu√© funciona* *
- El mont√≥n " libre " siempre contiene todas las sillas que actualmente est√°n vac√≠as.
- El mont√≥n 'ocupado' se ordena por el tiempo de salida; el elemento superior es la silla que liberar√° lo m√°s pronto.
- Al aparecer repetidamente de 'ocupado' cuando su tiempo de salida ‚â§ la llegada actual, mantenemos `libre' actualizado.
- La silla libre m√°s peque√±a est√° siempre en la parte superior de `libre`, por lo que podemos asignarlo en O(log n).

-...

## 2. Java ‚Äì `PriorityQueue` versi√≥n

``java
importar java.util*;

Clase Soluci√≥n {
p√∫blico m√°s peque√±o Presidente(int[][] times, int targetFriend) {}
int n = times.length;

// 1 / ‚É£ Ordenar √≠ndices de amigos por hora de llegada
Integer[] order = nuevo Integer[n];
para (int i = 0; i)
Arrays.sort(order, Comparator.comparingInt(i - t√≠tulo times[i][0]));

// 2Get‚É£ Min‚Äêheap of free chairs
Prioridad B√∫squedas realizadasInteger libremente = nueva prioridadQueue correspondi√≥();
para (int i = 0; i)

// 3Œ©‚É£ Min‚Äêheap of occupied chairs: pair(departure, seat)
PriorityQueue madeint[] ocupado = nuevo PriorityQueue asignado(Comparator.comparingInt(a - t√≠tulo a[0]));

para (int idx : order) {
int arrive = times[idx][0];
int leave = times[idx][1];

// 4down Sillas de liberaci√≥n cuyo propietario dej√≥
mientras (!occupied.isEmpty() " ocupado.peek()[0] " )
free.offer(occupied.poll()[1]);
}

// 5down Tome la silla libre m√°s peque√±a
silla int = libre.poll();

si (idx == targetFriend) silla de retorno;

// 6 millas ‚É£ Silla de marca como ocupada hasta 'salir '
ocupado.offer(nueva int[]{leave, chair});
}
retorno -1; // no alcanzable - objetivo de garant√≠a de entrada El amigo existe
}
}
`` `

-...

## 3. C++ ‚Äì `priority_queue` + `vector `

``cpp
Incluido el t√≠tulo
#include >
#include >

Clase Soluci√≥n {
public:
m√°s peque√±o Chair(std:::vector obtenidosstd:::vector seleccionadoint implicados iguales veces, int targetFriend) {}
int n = times.size();

// 1 / ‚É£ Ordenar √≠ndices por hora de llegada
std::vector seleccionado(n)
std::iota(order.begin(), order.end(), 0);
std::sort(order.begin(), order.end(),
[](int a, int b){ return times[a][0] [b] [0]; }

// 2Get‚É£ Min‚Äêheap of free chairs
std:::priority_queue obtenidosint, std::vector fielint, std::greater interpretadoint t√≠tulo libre;
para (int i = 0; i)

// 3Œ©‚É£ Min‚Äêheap of occupied chairs: pair(departure, seat)
std::priority_queue corresponding
std::pair obtenidos,int
std::vector seleccionados::pair seleccionado,int
std::greater obtenidosstd::pair obtenidosint,int
- Ocupado;

para (int idx : order) {
int arrive = times[idx][0];
int leave = times[idx][1];

// 4down Gratis todas las sillas cuyo propietario se fue ahora
mientras (!occupied.empty() " ocupado.top().
free.push (ocupied.top().second);
ocupados.pop();
}

// 5 Cambios  Grab Tome la silla libre m√°s peque√±a
silla int = libre.top(); libre.pop();

si (idx == targetFriend) silla de retorno;

// 6 Cambios  chair Silla de marca ocupada hasta la salida '
ocupado.emplace(leave, chair);
}
retorno -1; // nunca debe suceder
}
};
`` `

-...

## üéØ Por qu√© estas soluciones ganan entrevistas

Silenciosos en el futuro Python Silencio en Java
Silencio--------------------------
Silencio **Readability** Silencio 9 l√≠neas + comentarios Silencio Compacto, tipo seguro Silencio Conciso, estructuras de datos expl√≠citas
Silencio ** Complejidad en el tiempo** Silencio O(n log n) Silencio O(n log n)
Silencio ** Complejidad del espacio** Silencio O(n) Silencio O(n) Silencio
Silencio **Key Insight** Silencio Dos colas prioritarias: libre " ocupado Silencio Dos `PrioridadQueue`s vivir Dos `prioridad_queue`s con la comparaci√≥n personalizada
Silencio **Edge Cases Handled** tenci√≥n Releases at same timestamp, target friend at first or last

-...

Art√≠culo del blog optimizado

‚ñ† **T√≠tulo**: "LeetCode 1942 ‚Äì La m√°s peque√±a silla ocupada: Una profunda inmersi√≥n en soluciones de dos saltos (Java, Python & C++)‚Äù

-...

Introducci√≥n
- Gancho: ‚ÄúImagina una fiesta donde cada nuevo invitado debe sentarse en la silla vac√≠a *smallest*. ¬øC√≥mo haces un seguimiento de la siempre cambiante alineaci√≥n de sillas? ‚Äù
- Establece el problema, enlace con LeetCode, mencionar las limitaciones (n ‚â§ 104).
- SEO palabras clave: *LeetCode 1942*, *Smallest Unoccupied Chair*, *Interview Question*, *Two Heaps*, *Priority Queue*, *Java*, *Python*, *C+*.

### #2# Problema de desintegraci√≥n
- Diagrama visual de llegadas & salidas.
- Clarify ‚Äúpresidencia se vuelve libre al instante‚Äù y ‚Äúlos tiempos de llegada son distintos‚Äù.
- ¬øPor qu√© una simulaci√≥n ingenua (arriba de sillas) es O(n2) e impr√°ctica.

#### 3down‚É£ Na√Øve vs. Optimal Approaches
TENCI√ìN TENIDO Complejidad ANTERIEDARES ANTERIOR Cuando se utiliza
Silencio--------------------------------------------------------------
‚Üê Brute Force Array Silencioso O(n2) ‚Üê Memoria pesada, tiempo fuera TENIDO PEQUE√ëO
Silencio Eventos clasificados + TreeSet ‚Üê O(n log n) Silencio Ligeramente m√°s c√≥digo Silencio Cuando usted est√° c√≥modo con las operaciones establecidas ¬¶
Silencio Dos saltos (recomendados) Silencio O(n log n) Silencio m√°s simple Óåì **

#### 4down‚É£ The Two‚ÄêHeap Strategy (The Good)
- **Salta de silla gratuita**: siempre tiene la silla m√°s peque√±a disponible.
- **Ocupado Presidente Heap**: ordenados por tiempo de salida.
- L√≥gica de liberaci√≥n: pop de ocupado mientras la salida ‚â§ actual llegada ‚Üí silla de empuje de nuevo en libre.
- Asignaci√≥n: abrir la parte superior de la libre, empujar hacia ocupado con su partida.
- Det√©ngase temprano cuando el amigo objetivo est√© sentado.

#### Code Walk‚Äêthrough (Python)
- Explicaci√≥n paso a paso con comentarios en l√≠nea (la soluci√≥n de 9 l√≠neas).
- Destaca el bucle que libera sillas.
- Mostrar c√≥mo la salida temprana ahorra trabajo.

#### 5down‚É£ Traducci√≥n a Java & C++ (El Ugly)
- Discuss language-specific quirks:
- Java `PriorityQueue` es un min‚Äêheap por default? (No, es un min-heap pero necesita la comparaci√≥n).
- C++ `priority_queue` es max‚Äêby-default ‚Üí uso `greater seleccionado... `` comparador.
- Mostrar c√≥mo guardar parejas (partida, silla) de forma segura.
- Dificultades comunes: olvidando el pop despu√©s de los errores de los √≠ndices.

#### 6down‚É£ Edge‚Äê Lista de verificaci√≥n de casos (El Mal)
Silencio Caso Edge Silencioso Qu√© ver para Silencio
Silencio...
Silencio amigo Target llega el √∫ltimo Silencio Asegurar los procesos de bucle todas las llegadas. Silencio
Silencio M√∫ltiples salidas al mismo tiempo tenci√≥n Liberar todo antes de asignar. Silencio
El tiempo de llegada es igual a la salida anterior tenci√≥n Release primero (seg√∫n la llegada) para que la silla pueda ser reutilizada. Silencio
Silencio Muy grande n (104) Silencio Dos montones guardan memoria O(n). Silencio

### 7 carreras Performance Tuning Tips
- Use `heapq`s `heappush`/`heappop ' (Python) - no hace falta manual `push/pop`.
- En Java, pre-poblar el mont√≥n libre con 'IntStream.range(0, n).porCada(gratuito::offer)` para legibilidad.
- En C+++, utilice el `std::vector asignadoint ' para el mont√≥n libre si desea evitar el `push/pop` overhead para los primeros elementos n.

### 8Ô∏è Variaciones " Extensiones
- ¬øY si los tiempos de llegada no eran distintos? Agregue una regla de ruptura de corbata (por ejemplo, ID de amigo).
- ¬øC√≥mo manejar√≠as un n√∫mero finito de sillas? Utilice un contador para el caso ‚Äúsin silla disponible‚Äù.
- Use un √°rbol de segmentos o un √°rbol indexado binario para las consultas m√≠nimas de rango si desea practicar diferentes estructuras de datos.

#### 9Œ©‚É£ Conclusion > Final Takeaway
- Summarize por qu√© la soluci√≥n de dos saltos es el *sweet spot* para LeetCode 1942.
- Alentar a los lectores a practicar mediante la implementaci√≥n de las tres versiones, probar contra los insumos aleatorios ( " Unidosttest " / JUnit / Google Test).
- Invitar comentarios: ‚Äú¬øCon qu√© otros problemas de entrevista est√°s luchando? ‚Äù

Recursos adicionales
- Enlace a los hilos de discusi√≥n de soluci√≥n LeetCode.
- GitHub repo con las tres implementaciones.
- Video walkthrough en YouTube para estudiantes visuales.

-...

## üöÄ Final Thought

Con estos **tres implementaciones concisas y eficientes** y la explicaci√≥n **estructurada de entrevistas**, podr√°s abordar con confianza a LeetCode 1942 e impresionar a los entrevistadores con velocidad y claridad. ¬°Feliz codificaci√≥n!

-...

‚ñ† *No dude en dejar las preguntas en los comentarios ‚Äì ¬°hagamos que cada nuevo invitado se sienta como en casa! *