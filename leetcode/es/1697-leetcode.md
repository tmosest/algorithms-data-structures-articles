-...
T√≠tulo: LeetCode 1697. Comprobaci√≥n de la existencia de bordes largos Senderos limitados -
descripci√≥n: Titular
Fecha: 2025-09-21
categor√≠as: []
autor: muses
tags: []
HideToc: verdadero
-...
## üìö LeetCode 1697 ‚Äì Checking Existence of Edge‚ÄêLength Limited Paths
### The Good, The Bad, and The Ugly Blog de buceo para Job‚ÄêSeekers

‚ñ† **Etiqueta palabra clave**: *LeetCode 1697 soluci√≥n* ‚Äì *union‚Äêfind* ‚Äì *edge‚Äêlength limited paths* ‚Äì *hard problem* ‚Äì *coding interview*

Si usted est√° cazando para ese problema ‚Äúhard‚Äù LeetCode que har√° que los reclutadores sentarse y notar, usted querr√° dominar **1697. Verificaci√≥n de la Existencia de la Longitud del borde Senderos limitados**.
A continuaci√≥n encontrar√°:

Silencio Lo que aprender√°s Silencio üîç Por qu√© importa
Silencio...
Silencio La estrategia √≥ptima **union‚Äêfind** (disjoint-set)  durable O(E+Q) log(E+Q)) es lo suficientemente r√°pida para 105 bordes & consultas ‚Üê
Silencio Ordenar trucos para mantener las respuestas en el orden original ‚Üê Evita el procesamiento de consultas O(Q2)
‚Üê Manipulaci√≥n multi-edges & grandes l√≠mites enteros ‚Üê Previene errores sutiles en los casos de prueba de LeetCode
tenci√≥n Clean, language‚Äêagnostic implementation ‚Üê Show recruiters usted puede c√≥digo en Java, Python, C++

-...

## 1. Recaptaci√≥n de problemas

‚ñ† *Given*
" n ' nodes (0-based).
* `edgeList[i] = [ui, vi, disi]` ‚Äì borde no dirigido con distancia `disi`.
[pj, qj, limitj] ‚Äì preguntar si existe un camino de `pj` a `qj` **con todos los bordes < limitj**.

‚ñ† **Retorno** " respuesta de la comunidad " - un valor por consulta.

**Constraints** (caso peor)

* `2 ‚â§ n ‚â§ 105`
* `1 ‚â§ edgeList.length, queries.length ‚â§ 105 `
* `1 ‚â§ disi, limitj ‚â§ 109 `
* Pueden existir m√∫ltiples bordes entre el mismo par de nudos.

-...

## 2. Why a Union‚ÄêFind (Disjoint‚ÄêSet Union) Works

Piense en cada borde como un ‚Äúpuente‚Äù que se pone disponible cuando su distancia es **strictamente menor** que el `limit` de la consulta actual.
Si procesamos todos los bordes en **aumentando el orden de distancia**, podemos ‚Äúconectar‚Äù incrementalmente el gr√°fico:

1. **Sorta** todos los bordes por distancia.
2. **Sorta** todas las consultas por `limit ' .
(Recuerde el √≠ndice original para poner la respuesta m√°s adelante.)
3. Mantener una estructura del ESD sobre los nudos.
4. Mientras que la distancia del borde siguiente `seg√∫ntele el l√≠mite de la consulta actual', sintetice sus dos puntos finales.
5. Despu√©s de que todos los bordes aplicables se fusionan, los dos nodos de la consulta est√°n conectados si pertenecen al mismo conjunto DSU.

Debido a que procesamos consultas en el `limit` ascendente, cada borde se considera **una vez** ‚Äì dando una complejidad general de
**O(E + Q) log (E + Q)** for sorting plus **O(E Œ±(n))** for DSU operations (`Œ±` = inverse Ackermann, practically constant).

-...

## 3. El Bien, El Mal, El Mal

Silencio Silencio
Silencio------------Prince------
Silencio ** Algorithm** Silencio O(E+Q) log (E+Q)) ‚Üí r√°pido para 105 Silencio Ninguno Silencio ‚Äì Silencio
Silencio **DSU Implementaci√≥n** Silencioso de compresi√≥n + uni√≥n-por-rank ‚Üí casi-constant amortized Silencio Requiere cuidadoso manejo de √≠ndices (0-basado) Silencio Olvidar actualizar 'parente' en 'find' conduce a bucles infinitos
Silencio **Sorting Queries** Silencio Mantiene respuestas en orden original ‚Üê Requiere memoria extra para el √≠ndice Silencio Si usted ordena por `limit` pero olvida almacenar el √≠ndice original, usted devolver√° las respuestas incorrectas
Silencio **Multiple Edges** Silencio Handled automatically ‚Äì nosotros s√≥lo procesamos todos Silencio No se necesita un manejo especial Silencio Si usted err√≥neamente deduplica los bordes, usted pierde la informaci√≥n
tenci√≥n **Edge " Limit Size** tenci√≥n 32‚Äêbit ints sufficient, but use `long ' if you‚Äôre paranoid peru Ninguno viv Utilizar `int` cuando la suma exceda 2‚àí31‚Äê1 puede causar desbordamiento en otros problemas

-...

## 4. C√≥digo completo ‚Äì Java, Python, C++

‚ñ† Las tres implementaciones utilizan la misma l√≥gica.
‚ñ† Cada archivo es autocontenido, incluye las importaciones necesarias, y est√° listo para pegar en su entorno IDE o LeetCode.

#### 4.1 Java

``java
importar java.util*;

// ------------ DSU (Disjoint Set Union) ----------
Clase DSU {}
int privado final[] parent;
int final privado[] rango; // uni√≥n por rango

DSU(int n) {
padre = nuevo int[n];
rango = nuevo int[n];
para (int i = 0; i)
}

int find(int x) {
// Compresi√≥n del camino
(parent[x] != x) parent[x] = find(parent[x]);
devolver padre[x];
}

uni√≥n de vac√≠o(int x, int y) {
int rx = find(x);
int ry = find(y);
si (rx == ry) regresa;

// Uni√≥n por rango
si (rank[rx] Identifica rango [ry]) padre [rx] = ry;
[ry] [ry] = rx;
otra vez
parent[ry] = rx;
rango[rx]+;
}
}
}

// -------- Soluci√≥n principal --------
Soluci√≥n de la clase p√∫blica {}
boolean[] distanceLimited PathsExist(int n,
int[][] borde Listo,
int[][] consultas) {
// Adjuntar √≠ndices originales a las consultas
int m = consultas. longitud;
int[][] qWithIdx = nuevo int[m][4];
para (int i = 0; i) {}
qWithIdx[i][0] = consultas[i][0];
qWithIdx[i][1] = consultas[i][1];
qWithIdx[i][2] = consultas[i][2];
qWithIdx[i][3] = i; // posici√≥n original
}

// Ordenar bordes por distancia
Arrays.sort(edgeList, Comparator.comparingInt(a - t√≠tulo a[2]));

// Ordenar consultas por l√≠mite
Arrays.sort(qWithIdx, Comparator.comparingInt(a - t√≠tulo a[2]));

DSU dsu = nuevo DSU(n);
boolean[] ans = nuevo boolean[m];
int eIdx = 0; // puntero sobre bordes ordenados

para (int[] q : qWithIdx) {
l√≠mite de entrada = q[2];
// A√±adir todos los bordes con la distancia
mientras (eIdx) se observ√≥ bordeList.length " borde List[eIdx][2] , l√≠mite hecho) {
dsu.union(edgeList[eIdx][0], edgeList[eIdx][1]);
eIdx++;
}
// Si ambos nodos est√°n conectados, la respuesta es verdadera
ans[q[3]] = dsu.find(q[0]) == dsu.find(q[1]);
}
devolver los ans;
}
}
`` `

‚ñ† *C√≥mo correr*
‚ñ† *Paste la clase `Solution` en LeetCode, luego llama `distanceLimitedPathsExist(...)`. *

-...

### 4.2 Python (Python 3)

``python
de la importaci√≥n Lista

# ---------- DSU...
clase DSU:
def __init__(self, n: int):
self.parent = list(range(n))
self.rank = [0] * n

def find(self, x: int) - t√≠tulo int:
si yo. parent[x]!= x:
self.parent[x] = self.find(self.parent[x]) # Compresi√≥n del camino
Vu√©lvete. parent[x]

def union(self, x: int, y: int) - t√≠tulo Ninguno.
xr, yr = self.find(x), self.find(y)
si xr == yr: retorno
si auto.rank[xr] se auto.rank[yr]:
self.parent[xr] = yr
elif self.rank[xr] > self.rank[yr]:
self.parent[yr] = xr
m√°s:
self.parent[yr] = xr
auto.rank[xr] += 1

# -------- Principal...
Soluci√≥n de clase:
def distance LimitedPathsExist(
auto, n: int, edgeList: List[List[int], consultas: List[List[int]]
) List[bool]:
# Attach original index to each query
q_with_idx = [q + [i] for i, q in enumerate(queries)]

# Sort edges " queries
edgeList.sort(key=lambda x: x[2])
q_with_idx.sort(key=lambda x: x[2])

dsu = DSU(n)
as = [False] * len(queries)
e_idx = 0

para q en q_with_idx:
l√≠mite = q[2]
mientras que e_idx se hizo len(edgeList) y edgeList[e_idx][2]
dsu.union(edgeList[e_idx][0], edgeList[e_idx][1])
e_idx += 1
ans[q[3]] = dsu.find(q[0]) == dsu.find(q[1])

Retorno
`` `

‚ñ† *Run*
‚ñ† * Sube la clase 'Solution' a LeetCode y corre. *

-...

### 4.3 C++ (C+17)

``cpp
#include ◊ôbits/stdc++.h
usando std namespace;

--------- DSU...
Clase DSU {}
public:
vector:
DSU(int n) : parent(n), rnk(n, 0) {
iota(parent.begin(), parent.end(), 0);
}
int find(int x) {
volver padre[x] == x ? x : parent[x] = encontrar(parent[x]); // path compresi√≥n
}
vac√≠o unite(int x, int y) {
int xr = find(x), yr = find(y);
si (xr == yr) regresa;
si (rnk[xr] se hac√≠a [yr]) padre [xr] = yr;
si (rnk[xr] > rnk[yr]) padre [yr] = xr;
otra vez
parent[yr] = xr;
++rnk[xr];
}
}
};

// -------- Principal...
Clase Soluci√≥n {
public:
vector asignadobool confianza distanciaLimited PathsExist(int n,
vector de vectores borde Listo,
vector asignador implicados iguales consultas) {}
int m = consultas.size();
// guardar consultas como [u, v, limit, original_idx]
vector realizador realizado, 4 t√≠tulos qs
qs.reserve(m);
para (int i = 0; i)
qs.push_back({queries[i][0], queries[i][1], queries[i][i], i});

(edgeList.begin(), edgeList.end(),
[](cont auto ' , const auto &b){ devolver a [2]  obtenidos b[2]; });

(qs.begin(), qs.end(),
[](cont auto ' , const auto &b){ devolver a [2]  obtenidos b[2]; });

DSU dsu(n);
vector:
size_t eIdx = 0;

para (auto &q : qs) {
l√≠mite de entrada = q[2];
mientras (eIdx) se observ√≥ bordeList.size() " curva edgeList[eIdx][2]
dsu.unite(edgeList[eIdx][0], edgeList[eIdx][1]);
+ eIdx;
}
ans[q[3]] = (dsu.find(q[0]) == dsu.find(q[1]));
}
devolver los ans;
}
};
`` `

‚ñ† Compile**
* " g+ " -std=c+17 -O2 solution.cpp "

-...

## 5. C√≥mo funciona el programa juzgar√° su presentaci√≥n

1. **La calidad de los fondos* Los tres idiomas usan nombres claros, comentarios en l√≠nea, y ninguna constante m√°gica.
2. ** Maneje por caso electr√≥nico** ‚Äì Las soluciones manejan correctamente **multi-edges** y ** l√≠mites grandes** (sin flujo de entero).
3. *La complejidad del tiempo* La entrevista notar√° que no est√°s haciendo una ingenua BFS/DFS para cada consulta.
4. **La lengua versatilidad** ‚Äì Puede presentar las tres soluciones en una entrevista o prueba t√©cnica.

-...

## 6. Siguientes pasos: Pulsa tus habilidades de entrevista

Silencio ‚Üë Recibir recursos ‚ùå Sugerido para leer
Silencio...
* algoritmos de gr√°fico* Silencio *Union‚ÄêFind* en *Cracking the Coding Interview* Silencio
*LeetCode discusi√≥n* Silencio Thread on *1697 hard* para casos de borde extra
TENIDO *C++ STL* ANTE `iota`, `sort`, `vector` Silencio
Silencio *Python* Silencio `functools.lru_cache` para la memoizaci√≥n de `encontrar' si prefieres la recursi√≥n
*Java* Silencioso `Arrays.sort` + `Comparador.comparing Int` Silencio

-...

#### üéØ Final Thought

Con esta soluci√≥n **union‚Äêfind**, puedes resolver LeetCode 1697 en un segundo en la entrada m√°s dura.
Mostrar reclutadores puede traducir un algoritmo deslizante en c√≥digo limpio en **Java, Python, C++**, y usted ser√° un paso m√°s cerca de esa entrevista de sue√±os.

Buena suerte, y feliz codificaci√≥n! üöÄ

-...

**No dude en copiar/pasar cualquiera de las tres implementaciones anteriores, ejecutarlas localmente, y presumir en su d√≠a de entrevista!**