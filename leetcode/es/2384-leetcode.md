-...
T√≠tulo: LeetCode 2384. N√∫mero Palindromic m√°s grande -
descripci√≥n: Titular
Fecha: 2025-09-21
categor√≠as: []
autor: muses
tags: []
HideToc: verdadero
-...
‚ô™ ‚ô™ ‚ô™ ‚ô™‚ô™ 2384 ‚Äì N√∫mero Palindromico m√°s grande
** Tipo de problema:** Pendiente / Hash‚ÄêTable / Greedy
**Dificultad:**

-...

Problema Recap

Dado una cadena `num' que consiste s√≥lo en d√≠gitos decimales, usted puede:

* **re-orden** los d√≠gitos arbitrariamente,
* **omit** cualquier subconjunto de d√≠gitos (pero mantenga al menos uno).

Devuelve el n√∫mero ** m√°s grande** posible entero palindromico (como cadena) que se puede formar.
El resultado debe **no** contener ceros l√≠deres.

‚ñ† *Ejemplos*
> `num = "444947137" ‚Üí `"7449447"
> `num = "00009" ‚Üí `"9"

-...

## üìö 2. Algoritm Overview

Silencio Lo que hacemos _ Por qu√© funciona
...------------------------
Silencio **1. Contando frecuencias** Silencio Construir un array `cnt[10]` donde `cnt[d]` es el n√∫mero de veces d√≠gito `d` aparece. Silencio Un solo paso O(n). Silencio
tenci√≥n **2. Construir la mitad izquierda** TENIENDO d√≠gitos Iterate de `9` abajo a `0`. Para cada d√≠gito " d ": obtenidosbr confianza‚Ä¢ Si `cnt[d] ‚â• 2 ' append `d ' exactamente `cnt[d] / 2 ` times to a `StringBuilder` `izquierda`. Silencio Escoger los d√≠gitos m√°s grandes garantiza primero el n√∫mero total es maximizado. Silencio
Silencio **3. Elija el d√≠gito medio** Silencio Realice un seguimiento del d√≠gito * m√°s grande* que aparece un **odd** n√∫mero de veces (o es un candidato de una sola casualidad). Silencio S√≥lo una posici√≥n puede estar en el centro; el mayor d√≠gito extra√±o produce el m√°ximo medio. Silencio
tenci√≥n **3. Assemble the palindrome** ¬¶ Concatenate: `left + middle(optional) + reverse(left)`. La propiedad palindrome permanece. Silencio
Silencio **4. Persecuencias** TENIDO ANTERIENTIO DE EJERES INICIOTodos los ceros ‚Üí respuesta `"0" > > > > Identificar cero despu√©s de la construcci√≥n de la mitad izquierda ‚Üí devolver el d√≠gito medio (si lo hay) o `"0" > > Silencio Maneja el requisito de ‚Äúsin ceros l√≠deres‚Äù. Silencio

‚ñ† *Probabilidad grave*
‚ñ† El valor del palindromo est√° determinado por el *orden* de su lado izquierdo; el lado derecho es una imagen de espejo.
‚ñ† Cualquier desviaci√≥n de orden descendente reemplazar√≠a a un d√≠gito principal m√°s grande con uno m√°s peque√±o, disminuyendo el valor.
‚ñ† La √∫nica libertad es el d√≠gito central ‚Äì elegimos el d√≠gito de cuenta impar m√°s grande* porque produce la contribuci√≥n media m√°xima mientras mantiene al lado izquierdo maximizado.

-...

## ‚è±–ü–ª—å 3. Complejidad

* **Tiempo: ** `O(n)` - un paso a contar, un paso (constant 10 iterations) para construir la respuesta.
* **Espacio:** `O(1)` para el array de frecuencia + `O(n)` para la cadena de salida (impl√≠cita en el constructor).

-...

## üöÄ 3. Implementaci√≥n ‚Äì Java, Python, C++

‚ñ† *Las tres versiones comparten la misma l√≥gica. Si√©ntete libre de copiar el fragmento que coincide con tu idioma preferido. *

-...

## Java 17

``java
importar java.util*;

Soluci√≥n de la clase p√∫blica {}
public String largestPalindromic(String num) {
// 1 / ‚É£ Contando frecuencias
int[] cnt = nuevo int[10];
para (char ch : num.toCharArray()) cnt[ch - '0']+;

// 2 Cambios  Build Construye el lado izquierdo con avidez
StringBuilder left = new StringBuilder();
int middle = -1; // mayor d√≠gito de cuenta impar

para (int d = 9; d 0; d--) {
int c = cnt[d];
(c == 0) continuar;

// Skip leading ceros
si (izquierda) == 0 " d " = 0) continuar;

// A√±adir pares a la mitad izquierda
pares int = c / 2;
para (int i = 0; i) pares; i++) left.append(char) ('0' + d));

// Si este d√≠gito ocurre extra√±amente, compite para el medio
si (c % 2 == 1) medio = Math.max(middle, d);
}

// 3Œ©‚É£ Assemble final string
StringBuilder ans = nuevo StringBuilder();
si (izquierda) == 0 ' media == -1) devolver "0"; // todos los ceros

as.append(izquierda);
si (medio!= -1) ans.append(char) ('0' + middle));
ans.append(left.reverse()); // espejo la mitad izquierda

:: Guardia contra los ceros principales restantes
(ans.charAt(0) == '0') return String.valueOf(char) ('0' + middle));

devolver ans.toString();
}
}
`` `

-...

## Python 3

``python
Soluci√≥n de clase:
def mayorPalindromic(self, num: str) - confiar str:
# 1 Cuenta de frecuencia
cnt = [0] * 10
para ch en num:
cnt[int(ch)] += 1

# 2‚É£ Construye la mitad izquierda
izquierda = []
media = 1
para d en rango(9, -1, -1):
c = cnt[d]
si c == 0: continuar
si len(left) == 0 y d == 0: continue # avoid leading ceros

# add pairs
izquierda.extend([str(d)] * (c // 2))
# extra√±a ocurrencia - # candidato para el medio
si c % 2 == 1:
media = max(middle, d)

si no se deja y medio == -1:
todos los d√≠gitos eran cero

# 3Ô∏è Par√°ndrome de assemble
res = ''.join(left)
si el medio!= -1:
res += str(middle)
res += ''.join(reversed(left))
retorno
`` `

-...

## C++ (GNU‚ÄêC+17)

``cpp
Clase Soluci√≥n {
public:
cadena m√°s grandePalindromic(estring num) {
// 1 / ‚É£ Contando frecuencias
vector implicado cnt(10, 0);
para (char ch : num) cnt[ch - '0']++;

// 2 carreras Build Construir la mitad izquierda
cuerda izquierda;
int middle = -1;
para (int d = 9; d 0; --d) {
int c = cnt[d];
(c == 0) continuar;
if (left.empty() ' d == 0) continuar; // no hay ceros principales

// Agregar pares
left.append(c / 2, char('0' + d));
(c % 2 == 1) medio = m√°ximo (medio, d);
}

// Edge: todos los ceros
si (izquierda) " media == -1) devolver "0";

// 3Œ©‚É£ Assemble final string
cadena res = izquierda;
si (medio!= -1) res.push_back(char('0' + middle));
inversa(izquierda.begin(), left.end());
res += izquierda;
restituci√≥n;
}
};
`` `

Los tres snippets funcionan en tiempo **O(n)** y **O(1)** espacio auxiliar (el array de frecuencia de 10 tama√±os). Recopilan en los √∫ltimos est√°ndares de idiomas (`Java 17`, `Python 3.8+`, `C+17`).

-...

## üß© 3. Edge‚ÄêCase Mastery (Good, Bad & Ugly)

Silencio Categor√≠a Silencio Qu√© ver para Silencio Consejos
Silencio------------------
Silencio **Bien** Silencio - La construcci√≥n de Greedy garantiza la √≥ptimaza. *Dile al entrevistador que est√° usando una tabla de frecuencias y un solo pase.* Silencio
Silencio **Bad** Silencio - Manejo de ceros**: un palindrome que comienza con `0` es inv√°lido. Puedes saltar todos los ceros s√≥lo si la mitad izquierda est√° vac√≠a. *Siempre saltar `0` cuando el lado izquierdo todav√≠a est√° vac√≠o.* Silencio
Silencio **Ugly** Silencio - Decidir el ** d√≠gito medio**: si varios d√≠gitos aparecen un n√∫mero extra√±o de veces, usted debe elegir el ** m√°s grande** entre ellos. Cuando la entrada es "0" o todos los ceros, la respuesta correcta es "0" (no una cadena vac√≠a). *Tenga cuidado de regresar `'" ‚Äì que no es una cadena de entero v√°lida.* Silencio

**Ca√≠das comunes* *

Por qu√© falla en la vida
Silencio...
TENIDO Utilizando `StringBuilder.reverse()` en toda la cadena ** despu√©s** a√±adir el d√≠gito medio TEN Usted revertir√° el d√≠gito medio tambi√©n ‚Üí palindrome roto. Silencio
Silencio No manipular `"0000" ‚Üí devuelve `" Silencio Los entrevistadores te atrapar√°n; debes devolver `"0"`. Silencio
Silencio No escabullirse liderando `0` cuando la mitad izquierda est√° vac√≠a ¬¶ Returns `"00...0" 'que viola la regla de ‚Äúno liderar ceros‚Äù. Silencio

-...

## üìà 4. C√≥digo de entrevistas

A continuaci√≥n encontrar√° implementaciones limpias y concisas para **Java**, **Python**, y **C+** ‚Äì lista para pegar en una presentaci√≥n de LeetCode o su cartera de codificaci√≥n personal.

### Java (Java 17)

``java
Soluci√≥n de la clase p√∫blica {}
public String largestPalindromic(String num) {
int[] cnt = nuevo int[10];
para (char ch : num.toCharArray()) cnt[ch - '0']+;

StringBuilder left = new StringBuilder();
int middle = -1;

para (int d = 9; d 0; d--) {
int c = cnt[d];
(c == 0) continuar;
si (izquierda) == 0 " d " = 0) continuar; // evitar liderar cero

// Ap√©ndice pares
left.append(String.valueOf(char) ('0' + d)).repeat(c / 2));

// Posibilidad de registro para el medio
si (c % 2 == 1) medio = Math.max(middle, d);
}

// Caso de borde: todos los d√≠gitos son cero
si (izquierda) == 0 ' media == -1) devolver "0";

StringBuilder res = nuevo StringBuilder (izquierda);
si (medio!= -1) res.append(char) ('0' + middle));
re.append(new StringBuilder(left).reverse());
devolver res.toString();
}
}
`` `

### Python 3 (Python 3.8+)

``python
Soluci√≥n de clase:
def mayorPalindromic(self, num: str) - confiar str:
cnt = [0] * 10
para ch en num:
cnt[ord(ch) - 48] += 1

izquierda = []
media = 1
para d en rango(9, -1, -1):
c = cnt[d]
si c == 0:
continuar
si no se deja y d == 0:
continuar # evitar liderar cero

izquierda.extend([str(d)] * (c // 2))
si c % 2 == 1:
media = max(middle, d)

si no se deja y medio == -1:
todos los ceros

res = ''.join(left)
si el medio!= -1:
res += str(middle)
res += ''.join(reversed(left))
retorno
`` `

## C++ (GNU C+17)

``cpp
Clase Soluci√≥n {
public:
cadena m√°s grandePalindromic(estring num) {
vector implicado cnt(10, 0);
para (char ch : num) cnt[ch - '0']++;

cuerda izquierda;
int middle = -1;
para (int d = 9; d 0; --d) {
int c = cnt[d];
(c == 0) continuar;
if (left.empty() ' d == 0) continuar; // evitar liderar cero

left.append(c / 2, char('0' + d));
(c % 2 == 1) medio = m√°ximo (medio, d);
}

si (izquierda) " media == -1) devolver "0";

cadena res = izquierda;
si (medio!= -1) res.push_back(char('0' + middle));
inversa(izquierda.begin(), left.end());
res += izquierda;
restituci√≥n;
}
};
`` `

-...

## üéØ 5. Why This Matters

* escalabilidad* soluciona el problema para los l√≠mites m√°ximos de LeetCode (`n ‚â§ 10^4`).
* **Mantenibilidad* Una tabla de frecuencias es un patr√≥n de dise√±o* que se puede reutilizar para problemas como ‚Äúrearrange string‚Äù o ‚Äúfind longest palindrome‚Äù.
* **Comunicaci√≥n** El algoritmo es una de las pocas soluciones ‚Äúlook‚Äêand‚Äêfeel‚Äêoptimal‚Äù que se pueden explicar en menos de 5 minutos ‚Äì una gran victoria en una entrevista t√©cnica.

-...

## üìö 4. Seguimiento sugerido

1. **An√°lisis de complejidad Q—éA** ‚Äì estar listo para discutir el array de frecuencias de `O(1)` vs. hashing din√°mico.
2. **Variantes** ‚Äì por ejemplo, *‚Äú¬øY si necesitas el palindrome m√°s peque√±o?‚Äù* ‚Äì revierte el orden de selecci√≥n de d√≠gitos.
3. **Memory-heavy inputs** ‚Äì show how you can stream the string (no pre-allocation) while still using the frequency table.

-...

‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™ ‚ô™

*Su soluci√≥n es elegante, eficiente y pasa todos los casos de prueba. *
Recuerde resaltar la racionalidad avaricia, manejar los bordes con cuidado, y explicar su toma de decisiones cuando se presenta a los entrevistadores. ¬°Buena suerte! üöÄ

-...

**Tags:** `Java`, `Python`, `C++`, `String`, `Greedy`, `HashMap`, `FrequencyTable`, `Palindrome`, `Algorithm`, `LeetCode`.

-..