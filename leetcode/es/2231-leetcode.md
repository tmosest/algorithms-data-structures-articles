-...
T√≠tulo: LeetCode 2231. N√∫mero m√°s grande despu√©s de las gotas de d√≠gito por la Paridad -
descripci√≥n: Titular
Fecha: 2025-09-21
categor√≠as: []
autor: muses
tags: []
HideToc: verdadero
-...
# 2231. N√∫mero m√°s grande despu√©s de las gotas de d√≠gito por la Paridad ‚Äì C√≥digo + Entrevista Listo Blog

**LeetCode ID:** 2231
*Dificultad* F√°cil
**Tags:** Array, Greedy, Sorting, Priority Queue, String, Interview Question, Java, Python, C++

-...

## üìå Problema Resumen

Se le da un entero positivo 'num'.
Puedes cambiar los dos d√≠gitos que tengan la * misma paridad* (ambos o ambos impares).
Despu√©s de cualquier n√∫mero de swaps, devuelve el ** m√°s grande posible entero** que puedes formar.

‚ñ† *Ejemplo*
> `num = 1234 ‚Üí 3412`
" a√±o = 65875 ‚Üí 87655 "

‚ñ† **Constraints**
" 1 " = num " = 10^9 "

-...

## üß† Key Insight

El orden relativo de los d√≠gitos *odd* y los *even* d√≠gitos nunca cambian ‚Äì s√≥lo puede reordenar d√≠gitos **en cada clase de paridad**.
As√≠ que la estrategia √≥ptima es:

1. **Extraer** los d√≠gitos extra√±os e incluso por separado.
2. **Sorta** cada lista en orden **descendiente** (as√≠ que los d√≠gitos m√°s grandes son los primeros).
3. **Recompilado** el n√∫mero reemplazando cada d√≠gito original por el siguiente d√≠gito m√°s grande de la misma paridad.

El resultado est√° garantizado para ser el m√°ximo entero posible.

-...

Complejidad

Silencio Silencio Silencio Silencio
Silencio----------------
TENIDO EXtract + sort TENIDO `O(d log d)` (d = #digits, ‚â§ 10) TENIDO `O(d)` Silencio
Silencio Silencio

Con 'd ‚â§ 10' la soluci√≥n es trivial en el tiempo y la memoria.

-...

## üéØ Code Implementations

A continuaci√≥n se encuentran soluciones limpias y de producci√≥n en **Java**, **Python**, y **C+**.

‚ñ† **Tip** ‚Äì Las tres soluciones convierten el n√∫mero a una cadena para trabajar con d√≠gitos, que mantiene el c√≥digo legible y evita los bucles manual modulo/division.

-...

### 1Œ©‚É£ Java (Java 17)

``java
importar java.util*;

Clase Soluci√≥n {
m√°s grande Integer(int num) {
// Convertir en char array para facilitar el intercambio
char[] digits = String.valueOf(num).toCharArray();

// Greedy: para cada posici√≥n encontrar el mayor d√≠gito de la misma paridad a la derecha
para (int i = 0; i) i++) {
para (int j = i + 1; j) j++) {
si (digits[j] "
(digits[j] - digitos[i]) % 2 == 0) {
// swap
char tmp = digits[i];
d√≠gitos[i] = d√≠gitos[j];
d√≠gitos [j] = tmp;
}
}
}
integer.parseInt(new String(digits));
}
}
`` `

‚ñ† *Por qu√© funciona esto*
‚ñ† El doble bucle garantiza que cada vez que miramos hacia la derecha colocamos el mayor d√≠gito posible de la misma paridad en la posici√≥n actual. Esto es efectivamente lo mismo que clasificar cada grupo de paridad en orden descendente.

-...

Python (Python 3.11)

``python
Soluci√≥n de clase:
def mayor Integer(self, num: int) - t√≠tulo int:
s = list(str(num))
n = len(s)

para i en rango(n):
para j en rango(i + 1, n):
(int(s[j]) - int(s[i]) % 2 == 0:
s[i], s[j] = s[j], s[i]

volver int("".join(s))
`` `

‚ñ† *Nota pit√≥nica*
‚ñ† El enfoque codicioso de dos vueltas es muy legible. Para entradas m√°s grandes puede utilizar el m√©todo *sort‚Äêbyparity*, pero con la mayor√≠a de 10 d√≠gitos la soluci√≥n simple es perfecta.

-...

### 3down‚É£ C++ (C+17)

``cpp
Clase Soluci√≥n {
public:
m√°s grande Integer(int num) {
cadena s = to_string(num);
int n = s.size();

para (int i = 0; i) {}
para (int j = i + 1; j)
si (s[j] ‚àö‚â• s[i] " (s[j] - s[i]) % 2 == 0)
swap(s[i], s[j]);
}
}
}
devolver stoi(s);
}
};
`` `

‚ñ† **C++ 17** ‚Äì Usa `std::to_string`, `std::stoi`, and `std::swap`.
‚ñ† El modulo trick `(s[j] - s[i] % 2` funciona porque los caracteres `'0'`-`'9'` difieren por la misma cantidad que sus valores num√©ricos.

-...

## üìö Blog Article ‚Äì ‚ÄúLargest Number After Digit Swaps by Parity: The Good, The Bad, and the Ugly‚Äù

### Title

‚ñ† **Largest Number After Digit Swaps by Parity ‚Äì Master the Interview Problem (Java, Python, C++)* *

## Meta Descripci√≥n

‚ñ† Solve LeetCode 2231 ‚Äì Mayor n√∫mero despu√©s de los desv√≠os por Parity ‚Äì con soluciones Java, Python y C++. Entender la estrategia avaricia, las trampas y los consejos de entrevista. ¬°Anota tu puntuaci√≥n de la entrevista de codificaci√≥n!

-...

#### Introduction

Si est√°s buscando un problema de entrevista *real-world* que prueba tus habilidades ** de manipulaci√≥n de rayos** y tu intuici√≥n **algor√≠tmica**, no busques m√°s que LeetCode 2231: ** N√∫mero mayor despu√©s de las gotas de d√≠gito por Paridad**. Es un problema ‚Äúf√°cil‚Äù en la plataforma, pero esconde matices sutiles que pueden tropezar incluso programadores experimentados.

En este art√≠culo, nos sumergimos profundamente en:

- La estrategia codictiva b√°sica que garantiza el n√∫mero m√°ximo.
- Errores comunes (el ‚Äúmalo‚Äù y el ‚Äúmuy‚Äù).
- Tres soluciones de producci√≥n (Java, Python, C++).
- C√≥mo explicar la soluci√≥n en un entorno de entrevista.

¬°Vamos a romperlo!

-...

### The Good ‚Äì Why It's Elegant

Por qu√© funciona
Silencio----------
Silencio **Greedy** Silencio Cada swap es local: siempre ponemos el mayor d√≠gito posible (de la misma paridad) al lugar m√°s disponible. Silencio
Silencio **Parity Preservation** TEN La restricci√≥n de paridad mantiene el problema solvable con un simple enfoque de tipo por grupo. Silencio
Silencio **O(d log d)** Silencio Con 'd ‚â§ 10' d√≠gitos, el algoritmo es esencialmente constante-tiempo. Silencio
Silencio **No se necesita un gran entero** Silencio El resultado final encaja dentro de un entero firmado de 32 bits (`‚â§ 10^9`). Silencio

La elegancia reside en reconocer que cambiar d√≠gitos de la misma paridad es equivalente a clasificar independientemente los d√≠gitos extra√±os e incluso en orden descendente y luego volver a montarlos de acuerdo con el patr√≥n de paridad original.

-...

### The Bad ‚Äì Pitfalls You should avoid

1. *Asumiendo que puedes cambiar cualquier cosa*
‚ùå Swapping a `1` (odd) with a `4` (even) is illegal ‚Äì many startner solutions wrongnly do this.

2. **Using Integer Arithmetic En lugar de String**
‚ùå Trabajar directamente con d√≠gitos enteros (`num % 10`) puede llevar a errores cuando intenta cambiar d√≠gitos en su lugar.

3. *Ignorando ceros principales*
Si bien el problema garantiza `num —é= 1`, usted podr√≠a pensar en los n√∫meros que comienzan con `0`. Un algoritmo codicioso que s√≥lo reordena d√≠gitos puede crear inadvertidamente un cero l√≠der si no tienes cuidado.

4. **Optimizing for Larger Numbers**
Debido a que `num' est√° capped en '10^9`, no hay necesidad de un mont√≥n o un tipo de conteo. La ingenier√≠a excesiva puede hacer que su soluci√≥n sea m√°s dif√≠cil de entender.

-...

### Las trampas de la complejidad

- **Recursivo/Backtracking**
Algunos enfoques ingenuos intentan explorar cada permutaci√≥n de swaps extra√±os/inclusos, lo que lleva a tiempo exponencial (`O(d!)`). Esto es *terrible* para incluso `d = 10`.

- Usando BigInteger
Un error com√∫n es analizar la cadena final de nuevo en "BigInteger" para evitar el desbordamiento, pero las limitaciones lo hacen innecesario, y "BigInteger" es m√°s lento.

* Comprobaci√≥n de paridad rota* *
Utilizando `(digit1 + digit2) % 2 == 0` es *incorrecto* para la comparaci√≥n de paridad. La prueba correcta es `(digit1 - digit2) % 2 == 0` o `digit1 % 2 == digit2 % 2`.

-...

### Interview‚ÄêReady Explanation

‚ñ† **‚ÄúPrimero se separan los d√≠gitos en dos listas‚Äîdedos e inclusos. Luego ordeno cada lista descendiendo para que los d√≠gitos m√°s grandes est√©n en la parte delantera. Finalmente, paso por el n√∫mero original, reemplazando cada d√≠gito por el siguiente d√≠gito m√°s grande de la misma paridad de la lista correspondiente. El resultado es el entero m√°s grande posible.‚Äù* *

Explique que el algoritmo es *verde* porque en cada paso escogemos la opci√≥n localmente √≥ptima (el mayor d√≠gito de paridad a la izquierda), y debido a los grupos de paridad independientes este √≥ptimo local es tambi√©n global.

-...

## Code Walkthrough

##### Java

``java
char[] digits = String.valueOf(num).toCharArray();
para (int i = 0; i) i++)
para (int j = i + 1; j) j++)
si (digits[j] "
(digits[j] - digitos[i]) % 2 == 0) {
t = d√≠gitos[i];
d√≠gitos[i] = d√≠gitos[j];
d√≠gitos [j] = t;
}
integer.parseInt(new String(digits));
`` `

* Por qu√© est√° limpio:* Dos bucles anidados, un simple cheque de paridad, y un intercambio en el lugar.

#### Python

``python
s = list(str(num))
para i en rango(len(s)):
para j en rango(i+1, len(s)):
(int(s[j]) - int(s[i]) % 2 == 0:
s[i], s[j] = s[j], s[i]
volver int("".join(s))
`` `

*Retorno pit√≥nico:* Utilizando la sintaxis s[i], s[j] = s[j], s[i].

###### C++

``cpp
cadena s = to_string(num);
para (int i = 0; i) ++i)
para (int j = i+1; j) ++j)
si (s[j] ‚àö‚â• s[i] " (s[j] - s[i]) % 2 == 0)
swap(s[i], s[j]);
devolver stoi(s);
`` `

*Highlights:* `std::swap` mantiene el c√≥digo conciso.

-...

### Bono: Sort‚Äêby‚ÄêParity Approach (Alternative)

Si quieres enfatizar * surtido* en lugar de los dos bucles codiciosos, puedes hacer:

``java
Lista seleccionadaCaracter√≠stica propiedad impares = nuevo ArrayList recomendado();
Lista seleccionadaCaracter√≠stica uniformes = nuevo ArrayList implicado();

para (carc : d√≠gitos) {
(c - '0') % 2 == 0) evens.add(c);
(c);
}
odds.sort(Collections.reverseOrder());
evens.sort(Collections.reverseOrder());

int o = 0, e = 0;
para (int i = 0; i) i++) {
si (digits[i] - '0') % 2 == 0) d√≠gitos[i] = evens.get(e++);
d√≠gitos[i] = odds.get(o++);
}
`` `

‚ñ† *Por qu√© sigue siendo ‚Äúbueno‚Äù* Es un poco m√°s largo pero hace que la *independencia de grupos de paridad* sea clara. En una entrevista, podr√≠a impresionar al entrevistador mostrando que ha considerado m√∫ltiples v√≠as de soluci√≥n.

-...

#### üöÄ Final Takeaway

LeetCode 2231 es un problema de entrevista *golden*. Dominar te da:

- Limitaciones de manejo de confianza y casos de esquina.
- Experiencia explicando claramente la l√≥gica codictiva.
- Un patr√≥n reutilizable (grupo ‚Üí ordenar ‚Üí reconstruir) que aparece en muchos problemas de matriz.

¬°Feliz codificaci√≥n y buena suerte en tu pr√≥xima entrevista! üöÄ

-...

## Recursos > Lectura ulterior

- [LeetCode 2231 - Declaraci√≥n de problemas](https://leetcode.com/problems/largest-number-after-digit-swaps-by-parity/)
- [Greedy Algorithms ‚Äì Coursera](https://www.coursera.org/learn/greedy-algorithms)
- [Parity in Programming ‚Äì Stack Overflow Q juntosA](https://stackoverflow.com/questions/ what-is-parity)

-...

### üìà SEO Boost

- **Keywords**: ‚ÄúLeetCode 2231‚Äù, ‚ÄúLargest Number After Digit Swaps by Parity‚Äù, ‚ÄúJava solution‚Äù, ‚ÄúPython solution‚Äù, ‚ÄúC++ solution‚Äù, ‚Äúgreedy algoritmo‚Äù, ‚Äúcoding interview tips‚Äù, ‚Äúarray manipulation‚Äù, ‚Äúparity restraint‚Äù, ‚Äúalgorithmic intuition‚Äù.
- **Caracteres**: Usar " armonizado " , " armonizado " , " armonizado " y " armonizado " para estructurar el contenido de los motores de lectura y b√∫squeda.
- **Im√°genes**: Incluye un peque√±o diagrama de ‚Äúgrupos o incluso grupos‚Äù y un diagrama de flujo del algoritmo.
- **Backlinks**: Repositorios oficiales de referencia LeetCode, Medium y GitHub para mayor exploraci√≥n.

Con el c√≥digo y la gu√≠a de entrevistas arriba, usted est√° listo para as LeetCode 2231 y mostrar su problema soluci√≥n de problemas en cualquier entrevista t√©cnica. ¬°Feliz codificaci√≥n!