-...
T√≠tulo: LeetCode 1943. Describe la pintura -
descripci√≥n: Titular
Fecha: 2025-09-21
categor√≠as: []
autor: muses
tags: []
HideToc: verdadero
-...
## üéØ Problema Recap - LeetCode 1943 "Describe la pintura"

‚ñ† **Objetivo** ‚Äì Convertir un conjunto de segmentos de color, superpuestos en una l√≠nea de n√∫meros en el conjunto m√≠nimo de segmentos no superpuestos de medio bloque que describen correctamente cada *mixed color* en la l√≠nea.
‚ñ† ** Salida** ‚Äì Para cada nuevo segmento `[l, r)` producimos el *sum* de todos los colores que est√°n presentes en ese intervalo (el ‚Äúcolor mezclado‚Äù es un conjunto de colores distintos, pero s√≥lo devolvemos la suma).

-...

### Por qu√© es un problema de entrevista cl√°sica

* **Line Sweep** ‚Äì la t√©cnica can√≥nica para tratar con intervalos que cambian en puntos finales.
* ** Estructuras de datos** ‚Äì √°rboles de b√∫squeda binaria equilibrados (`TreeMap`/`std::map`) o * arrays de diferencias*.
* **Edge-cases** ‚Äì manejo de ‚Äúholes‚Äù (partes no pintadas) y rangos superpuestos que tienen la misma suma pero diferentes conjuntos de colores.
* **La complejidad** ‚Äì `O(n log n)` (map) o `O(n + maxCoord)` (array) ‚Äì ambos aceptables para las limitaciones.

-...

## üë® üíª Solution Idea ‚Äì Line Sweep with a Difference Map

1. **Recoge todas las coordenadas "interesantes"** ‚Äì cada punto de inicio o final de un segmento.
2. **Store the delta of color sum at each point* *
* A√±adir `color` en el *start* de un segmento.
* Subtract `color` at the *end* of a segment.
3. **Ordenar las coordenadas** (o usar un mapa determinado) y ordenar.
4. Mantener un funcionamiento " corriente Sum`.
5. Cada vez que el `currentSum > 0` y la siguiente coordenadas difieren del anterior, emite un segmento `[prevCoord, currCoord)` con la suma actual.
6. Pasar intervalos donde `currentSum == 0` ‚Äì no est√°n pintados.

Debido a que cada color en la entrada es *unique*, el conjunto de colores activos cambia cada vez que la suma cambia. Por lo tanto una suma num√©rica pura es suficiente para la salida.

-...

## üì¶ Code

A continuaci√≥n se presentan soluciones limpias y idiom√°ticas en **Java, Python y C++**.
Cada soluci√≥n utiliza el mismo algoritmo; s√≥lo los datos de estructura difieren.

-...

### Java (Aplicaci√≥n basada en la matriz r√°pida)

``java
importar java.util*;

Soluci√≥n de la clase p√∫blica {}
public List made(int[] segmentos) {}
// Max endpoint ‚â§ 1e5 + 1 (el extremo ‚Äúmedio cerrado‚Äù)
int final MAX = 100001;
largo[] diff = nuevo largo [MAX + 2]; // diff[i] = cambio en la suma en i
boolean[] isEndpoint = nuevo booleano[MAX + 2];

// Dibujo de la diferencia
para (int[] seg : segmentos) {}
int start = seg[0], end = seg[1];
color largo = seg[2];
diff[start] += color;
diff[end] -= color;
isEndpoint[start] = true;
isEndpoint[end] = true;
}

Lista seleccionadaLista realizadaLong confianza Resultado = nuevo ArrayList recomendado();
long current = 0; // running sum
int prev = 0; //

para (int i = 1; i)= MAX + 1; i++) {
si (esEndpoint[i] " corriente " 0) {
// Intervalo de pintura [prev, i) con suma actual
result.add (Arrays.asList(long)prev, (long)i, current));
}
prev = isEndpoint[i] ? i : prev; // salto s√≥lo en puntos finales
actual += diff[i];
}
Resultado de retorno;
}
}
`` `

**La complejidad* *

TEN TERRITOR SON TEN ANTERIOR ANTERIOR ANTERIOR TERRITORIO ANTERIOR ANTERIOR ANTERIOR ANTERIOR
Silencio------Prince--------
Silencioso edificio diff Silencio `O(n)` Silencio `O(maxCoord)` Silencio
Silencioso matriz de escanning Silencioso `O(maxCoord)`
Silencio Total Silencio `O(n + maxCoord)` ‚ô• `O(1e5)` Silencio `O(maxCoord)` Silencio

-...

### Python (Using `sortedcontainers` or built‚Äêin `dict`)

``python
de la importaci√≥n Lista
de las colecciones importadas por defecto

Soluci√≥n de clase:
def splitPainting(self, segments: List[List[int]) - No. List[List[int]]:
diff = defaultdict(int)
extremos = set() # coordenadas que son puntos finales reales

# Construir mapa de la diferencia
para s, e, c en segmentos:
diff[s] += c
diff[e] -= c
end.add(s)
end.add(e)

# Lista clasificada de todas las coordenadas interesantes
coords = ordenados(en adelante)

res = []
corriente = 0
prev = coords[0] # first endpoint

para i en rango(1, len(coords)):
curr = coords[i]
corriente += diff[prev]
si es actual 0:
re.append([prev, curr, current])
prev = curr

retorno
`` `

‚ñ† **Tip** ‚Äì Si prefieres los insertos/lookups de O(log n), utiliza 'contenedores variados. SortedDict` (pip install).
‚ñ† El c√≥digo anterior se ejecuta en `O(n log n)` debido a la clasificaci√≥n del punto final (`n ‚â§ 2¬∑104`).

-...

### C++ (Fast array + `vector`)

``cpp
Incluido el t√≠tulo
#include >
usando std namespace;

Clase Soluci√≥n {
public:
vector realizador realizado durante mucho tiempo estipulado splitPainting(vector seleccionado seleccionado: {}
const int MAX = 100001; // m√°xima coordenadas + 1
vector realizado largamente dieff(MAX + 2, 0);
vector asignado t√≠tulo esEnd(MAX + 2, 0);

para (auto &seg : segmentos) {}
int s = seg[0], e = seg[1];
largo c = seg[2];
diff[s] += c)
diff[e] -= c;
isEnd[s] = isEnd[e] = 1;
}

vectorial realizador realizado durante mucho tiempo res;
Cura larga larga = 0;
int prev = 0;

para (int i = 1; i)= MAX + 1; ++i) {
(isEnd[i] " curva " 0) {
res.push_back({prev, i, cur});
}
prev = isEnd[i] i : prev;
cur += diff[i];
}
restituci√≥n;
}
};
`` `

**¬øPor qu√© `vector seleccionado' para 'esEnd'?* *
`bool` puede tener una sobrecarga definida por la implementaci√≥n. Un `char` es un byte y es suficiente para marcar si una coordinaci√≥n es un punto final real.

-...

## üìö Blog detallado ‚Äì ‚ÄúDescribe la pintura‚Äù en el estilo de un blog de entrevista t√©cnica

-...

# How to Master LeetCode 1943 ‚Äì ‚ÄúDescribe la pintura‚Äù

‚ñ† **Keywords:** LeetCode 1943, Describe la pintura, barrido de l√≠neas, soluci√≥n Java, soluci√≥n Python, soluci√≥n C++, entrevista de algoritmos, entrevista de codificaci√≥n, entrevista de trabajo, estructuras de datos, BST equilibrado, matriz de diferencias.

-...

## Tabla de contenidos

1. Declaraci√≥n de problemas
2. Observaciones clave
3. Algoritmo - Diferencia del sudor de l√≠neas Mapa
4. üì¶ Three Clean Implementations
5. –ù–∞–ª–∏–≤–∞–ª–∏ las cascadas comunes ( partes ‚ÄúBad‚Äù " Ugly " )
6. Recibir Qu√© hacer hincapi√© en una entrevista
7. üìà C√≥mo mostrar su soluci√≥n en una cartera
8. üíº ¬øPor qu√© este problema te hace trabajar?
9. üìö Leer m√°s " Recursos "

-...

## 1. Declaraci√≥n de problemas (Recap.)

Se le da un array `segments`, cada elemento `[start, end, color]`.
Todos los valores de color son √∫nicos.
La tarea: producir el *m√≠nimo* conjunto de segmentos no superpuestos semicerrados que describen correctamente los colores mezclados en la l√≠nea.
Presentar una lista de `[izquierda, derecha, sum_of_colors]` para cada intervalo pintado.
Intervalos sin color (`sum == Debe ser omitido.

Constraints: `1 ‚â§ n ‚â§ 20000`, `1 ‚â§ inicio ‚â§ 100000`, todos los colores ‚â§ `109`.

-...

## 2. Observaciones clave

TENCI√ìN ANTERIOR Por qu√© importa
Silencio...
Silencio ** Cambio de punto** Silencio Un segmento comienza o termina s√≥lo en coordenadas enteros. Silencio
Silencio **Colores √∫nicos** Silencio El conjunto de colores activos cambia si la suma num√©rica cambia. Silencio
Silencio **Half‚Äêclosed** Silencio `end` es *no* parte del segmento, por lo que podemos utilizar un array de diferencia sin errores fuera de cada uno. Silencio
Silencio **No se pintan ‚Äúagujeros‚Äù** Silenciosos Intervalados donde se ignoran ‚ÄúcurrentSum == 0‚Äù. Silencio
Silencio **Sorting required** Silencio Necesitamos las coordenadas en orden ascendente para realizar un barrido. Silencio

-...

## 3. Algoritmo ‚Äì L√≠nea Sudadera con un Mapa de Diferencia

1. *Crea un mapa delta*
* For every segment `[s, e, c]`: `delta[s] += c`, `delta[e] -= c`.
* Almacenar tanto " como " en un conjunto de " puntos finales " .
2. **Sort `endpoints`** ‚Äì esto nos da la orden de barrido.
3. Traverso
* Keep `curSum = 0`, `prev = first_endpoint`.
* Para cada coordenadas `x` en orden ordenado:
* `curSum += delta[prev]`.
* Si "curSum " , salida `[prev, x, curSum] ' .
* `prev = x`.
4. Devuelve la lista.

Debido a que la suma es estrictamente positiva para cualquier intervalo pintado, podemos saltar rangos no pintados y no necesitamos reconstruir el *set* de colores.

-...

## 4. Tres implementaciones limpias

‚ñ† **Tip** ‚Äì La l√≥gica central es id√©ntica; s√≥lo la elecci√≥n de la estructura de datos difiere.

Silencio Idioma Silencio Preferente Estructura de Datos Silencio Complejidad del Tiempo Silencio
Silencio------------------------------------------ La vida--
Silencio Java  suya Array (`diff`) + matriz booleana (`isEndpoint`) Silencio `O(n + maxCoord)` Silencio `O(maxCoord)` Silencio
Silencio Python Silencio `defaultdict` + `set` (sorted later) Silencio `O(n log n)` Silencio `O(n)` Silencio
TENIDO C++ TENIDO `vector realizado largo `` + `vector fielchar `` Silencio `O(n + maxCoord)` ANTE `O(maxCoord)` Silencio

-...

## Java ‚Äì Array basado (m√°s performant)

``java
importar java.util*;

Soluci√≥n de la clase p√∫blica {}
public List made(int[] segmentos) {}
int final MAX = 100001; // 1e5 + 1 es seguro
largo[] diff = nuevo largo [MAX + 2];
boolean[] isEnd = nuevo booleano[MAX + 2];

para (int[] seg : segmentos) {}
int s = seg[0], e = seg[1];
c = seg[2];
diff[s] += c)
diff[e] -= c;
isEnd[s] = true;
isEnd[e] = true;
}

Lista seleccionadaLista realizadaLong confianza ans = nuevo ArrayList recomendado();
Cura larga = 0;
int prev = 0;

para (int i = 1; i)= MAX + 1; i++) {
(isEnd[i] " curva " 0) {
ans.add (Arrays.asList(long)prev, (long)i, cur));
}
prev = isEnd[i] i : prev;
cur += diff[i];
}
devolver los ans;
}
}
`` `

-...

### Python ‚Äì Usando un mapa

``python
de las colecciones importadas por defecto
de la importaci√≥n Lista

Soluci√≥n de clase:
def splitPainting(self, segments: List[List[int]) - No. List[List[int]]:
diff = defaultdict(int)
extremos = set()

para s, e, c en segmentos:
diff[s] += c
diff[e] -= c
end.add(s)
end.add(e)

coords = ordenados(en adelante)
res = []
Cura = 0
prev = coords[0]

para i en rango(1, len(coords)):
cur += diff[prev]
si curs√© 0:
re.append([prev, coords[i], cur])
prev = coords[i]

retorno
`` `

‚ñ† **Si usted necesita estrictamente 'O(n log n)'** (que surja domina), esto ya satisface los l√≠mites.
‚ñ† El c√≥digo es 80 % m√°s corto que la soluci√≥n ‚Äúmap‚Äêonly‚Äù y mantiene la misma l√≥gica.

-...

### C++ ‚Äì Array basado (altamente eficiente)

``cpp
Incluido el t√≠tulo
usando std namespace;

Clase Soluci√≥n {
public:
vector realizador realizado durante mucho tiempo estipulado splitPainting(vector seleccionado seleccionado: {}
const int MAX = 100001;
vector realizado largamente dieff(MAX + 2, 0);
vector asignado t√≠tulo esEnd(MAX + 2, 0);

para (auto &seg : segmentos) {}
int s = seg[0], e = seg[1];
largo c = seg[2];
diff[s] += c)
diff[e] -= c;
isEnd[s] = isEnd[e] = 1;
}

vector realizador llevado a cabo larga larga larga experiencia
Cura larga larga = 0;
int prev = 0;

para (int i = 1; i)= MAX + 1; ++i) {
(isEnd[i] " curva " 0) {
ans.push_back({prev, i, cur});
}
prev = isEnd[i] i : prev;
cur += diff[i];
}
devolver los ans;
}
};
`` `

-...

## üß© ‚ÄúGood‚Äù, ‚ÄúBad‚Äù, y ‚ÄúUgly‚Äù ‚Äì What to Keep " What to avoid

Subt√≠tulos en la categor√≠a Silencio bueno Silencio
Silencio--------------...
Silencio ** Algorithm** tenci√≥n Barrido lineal; estable incluso con gran `maxCoord`. Silencio Iteraci√≥n sin surtido de coordenadas crudas ‚Üí puntos finales perdidos. Silencio Utilizar un *plain* mapa no deseado e iterando arbitrariamente ‚Äì produce un orden incorrecto. Silencio
Silencio **Data‚Äêstructure** Silencio `TreeMap` / `std::Map` para llaves ordenadas. Silencio `vector garantizadobool `` para endpoints (trabajos pero ligeramente desordenados). TENIDO Utilizando `ArrayList seleccionadaInteger confianza` + `HashMap madeInteger, Long `` entonces clasificando *s√≥lo las teclas delta* ‚Äì faltan coordenadas que tienen `delta == 0`. Silencio
Silencio **Complejidad** Silencio `O(n log n)` ‚Äì fino para los l√≠mites de LeetCode. Silencio `O(n2)` ‚Äì barrido ingenuo sin ordenar. Silencio `O(n + maxCoord)` ‚Äì eficiente pero puede ser exagerado si las coordenadas son enormes. Silencio
Silencio **Manejamiento por caso de Corner** Silencioso Skip when `currentSum == Olv√≠date de actualizar `prev` s√≥lo en los puntos finales. Emitir intervalos de longitud cero (`[x, x)`), causando respuesta incorrecta. Silencio
Silencio **Readability** Silencio Nombres variables claros (`currentSum`, `prevCoord`). tenci√≥n Dense l√≥gica de una l√≠nea ‚Äì dif√≠cil de depurar. " La seguridad del tipo " . Silencio

‚ñ† **Bottom line** ‚Äì el enfoque array-difference es el m√°s limpio para los entrevistadores; la versi√≥n basada en mapa es m√°s f√°cil de leer si no est√°s c√≥modo con el indexado de array.

-...

## üöÄ How This Problem Helps You Land Your Dream Job

1. **Demonstrates Core Data‚ÄêStructure Knowledge** ‚Äì Mapa, Tree, Array.
2. **Mostrar c√≥digo limpio " Manejo por caso de Edge** ‚Äì los entrevistadores aman soluciones que no se bloquean en `end == 0`.
3. **Exhibe Pensamiento Algor√≠tmico** ‚Äì transformando un problema de ‚Äúpintura‚Äù en una l√≠nea *sweep* ‚Äì un patr√≥n cl√°sico de problemas de entrevista.
4. **Portfolio Ready** ‚Äì Sube la soluci√≥n con comentarios " pruebas unitarias a GitHub o LinkedIn.
5. **Blog Post / Medium Article** ‚Äì Compartir este art√≠culo, como antecede, demuestra que usted puede comunicar ideas complejas.
6. **Idioma sobre plataformas de codificaci√≥n** ‚Äì A√±ada el problema a su lista "Top 50 resuelto" en LeetCode, Codeforces, HackerRank.

-...

## üìö M√°s lectura

Silencioso recurso
Silencio...
Silencio ‚ÄúCracking the Coding Interview‚Äù ‚Äì Cap√≠tulo sobre *Interval Scheduling* ‚Üê Problemas de l√≠nea de barrido cl√°sico. Silencio
‚ÄúAlgoritmos sobre datos geom√©tricos‚Äù ‚Äì Coursera tenci√≥n T√©cnicas de l√≠nea de barrido avanzada. Silencio
‚Üê ‚ÄúGeeksforGeeks ‚Äì Line Sweep Algorithm‚Äù _ M√∫ltiples ejemplos y explicaciones visuales. Silencio
Silencio ‚ÄúUniversidad de Entrevista de Coding‚Äù (GitHub) _ Lista completa de preguntas de entrevista, incluyendo 1943. Silencio

-...

### Closing Thought

Mastering LeetCode 1943 es una prueba *soft-skill* ‚Äì no solo est√°s resolviendo un rompecabezas; est√°s demostrando que puedes:

- **Traducir un problema a las estructuras de datos* *
- ** Casos de borde hundido elegantemente**
- **C√≥digo legible, mantenible* *
*Explica tu razonamiento claramente* *

Ponga esta soluci√≥n en su cartera, emparejarla con un blog limpio, y brillar√° en cualquier entrevista de codificaci√≥n o en LinkedIn. ¬°Buena suerte! üöÄ

-...

¬°Feliz codificaci√≥n! *