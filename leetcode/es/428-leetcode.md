-...
T√≠tulo: LeetCode 428. Serialize and Deserialize N-ary Tree -
descripci√≥n: Titular
Fecha: 2025-09-21
categor√≠as: []
autor: muses
tags: []
HideToc: verdadero
-...
## 428. Serialize y Deserialize N‚Äêary Tree
‚ñ† **LeetCode Hard ‚Üê Job‚ÄêEntreview‚Äê Listo.

-...

### 1. üöÄ Resumen del problema

En un √°rbol N-ary arraigado cada nodo puede tener un n√∫mero arbitrario de ni√±os (hasta **N**).
La tarea es **convertir todo el √°rbol en una cuerda** (`serialize`) y luego **reconstruir el mismo √°rbol exacto de esa cuerda** (`deserializar`).

- ** Entrada**: `root ' - pointer/reference to the root of an N‚Äêary tree (may be `null`).
- ¬øQu√©?
* `serialize(root)` ‚Üí `String` que representa singularmente el √°rbol.
* `deserialize(data)` ‚Üí `Nodo` que es bit‚Äêfor‚Äêbit id√©ntico al √°rbol original.

** Limitaciones importantes**

TEN ANTERIOR ANTERIOR ANTERIOR
Silencio...
Silencioso *Nodos* Silencio
* Rango de valor* ‚Üê nodo.val ‚â§ 109` Silencio
Silencio *Ning√∫n estado global/est√°tico* Silencioso cada llamada debe ser **sin estado**. Silencio
Silencio *Hora* Silencio Linear en el n√∫mero de nodos. Silencio
*Espacio* Silencioso O(n√∫mero de nodos) para la cadena de salida. Silencio

-...

### 2. Por qu√© este problema importa

* **Interview staple** ‚Äì Muchos entrevistadores de alto nivel piden un truco de ‚Äúserializar/deserializar‚Äù para √°rboles, listas vinculadas, gr√°ficos, etc.
* **LeetCode 428** es parte de las colecciones ‚ÄúArbol Benario‚Äù y ‚ÄúDesign‚Äù y aparece en el set ‚ÄúGraph/Tree‚Äù.
* Dominar este problema demuestra una comprensi√≥n s√≥lida de la recursi√≥n, las t√©cnicas de traversal y la cuidadosa manipulaci√≥n de cuerdas, todas las habilidades b√°sicas para los roles centrados en algoritmos (Software Engineer, Backend Engineer, Data Engineer, etc.).

-...

#### 2down‚É£ Solution Strategies

A continuaci√≥n se muestran los **tres patrones m√°s comunes** que ver√° en las soluciones de entrevistas de producci√≥n:

Silencio Lo que hace ¬¶
Silencio----------------------------...
Silencio **Depth‚ÄêFirst Search (DFS) with child count**  durable `val childCount ‚ñ†children‚ÄêDFS confianza` Silencio *Simple, no extra sentinel symbol.* ‚Üê Requiere cuidadoso manejo de √≠ndice cuando se analiza. Silencio
Silencio **Breadth‚ÄêFirst Search (BFS) with sentinel nulls** Silencio `val child1 child2 ... null ...` Silencioso *Iterante, f√°cil de entender.* Debe recordar d√≥nde termina cada lista de ni√±os. Silencio
* Formato personalizado con delimitadores** Silencio `1 tuviendo3 turbado2 turbado0...` Silencio *Muy compacto, no hay espacios necesarios.* Silencio M√°s error-prone para mayores valores; dif√≠cil de depurar. Silencio

A continuaci√≥n implementamos el patr√≥n **DFS + cuenta infantil** en **Java, Python y C+** ‚Äì la manera m√°s limpia, m√°s r√°pida y segura de cumplir con las limitaciones del problema.

-...

## üíª 3‚ÄêLanguage Implementations

‚ñ† **Los tres c√≥digos son ap√°tridas, espacio auxiliar O(1) (excepto la pila de recursi√≥n), y garantizado para reconstruir el mismo √°rbol. #

## 3.1 Soluci√≥n Java

``java
importar java.util*;

// LeetCode Node definition
Clase Node {}
int val;
public List Node conf√≠a children;

public Node() { this.children = new ArrayList fiel(); }

public Node(int val) {
este.val = val;
esto. ni√±os = nuevo ArrayList garantizado();
}

public Node(int val, Lista de ni√±os Node confianza) {}
este.val = val;
esto. ni√±os = ni√±os;
}
}

Clase Codec {}

/** Encodes an N‚Äêary tree to a single string. */
public String serialize(Node root) {
si (root == null) regresan "; // √°rbol null ‚Üí cuerda vac√≠a
StringBuilder sb = nuevo StringBuilder();
dfsEncode(root, sb);
devolver sb.toString();
}

vac√≠o privado dfsEncode(Nodo, StringBuilder sb) {
sb.append(node.val).append(') // valor de nodo
sb.append(node.children.size()).append(')); // number of children
para (Ni√±o nodo: nodos.ni√±os) {}
dfsEncode(child, sb); // recurrentemente codifica cada ni√±o
}
}

* Decodifica tus datos codificados al √°rbol. */
public Node deserialize(String data) {
si (data.isEmpty()) devuelve null; // cadena vac√≠a ‚Üí √°rbol null
Compartir[] fichas = data.split("\s+");
int[] index = {0}; //
dfsDecode(tokens, index);
}

privado Nodo dfsDecode(String[] tokens, int[] index) {
int val = Integer.parseInt(tokens[index[0]++]); // read node value
ni√±o Cuenta = Integer.parseInt(tokens[index[0]++]); // read child count
Nodo nodo = nuevo Nodo(val);
node.children = nuevo ArrayList recomendado();
para (int i = 0; i) {}
node.children.add(dfsDecode(tokens, index));
}
nodo de retorno;
}
}
`` `

‚ñ† *La complejidad*
‚ñ† *Tiempo*: `O(N)` ‚Äì cada nodo se visita una vez durante ambos serializar " deserializar.
‚ñ† *Espacio*: `O(N)` ‚Äì longitud de cadena de salida m√°s pila de recursi√≥n.

-...

### 3.2 Python Solution

``python
# Definici√≥n de nodo (formato LeetCode)
Clase Nodo:
def __init__(self, val=None, children=None):
self.val = val
ni√±os = ni√±os o []

class Codec:
""Encodes an N‚Äêary tree to a string and decodes it back.""

def serialize(self, root: 'Node') - universidad str:
si no ra√≠z:
Retorno '
partes = []
def dfs(node):
parts.append(str(node.val)))
partes.append(str(len(node.children))))
para ni√±os en nodo. ni√±os:
dfs(child)
dfs(root)
volver '.join(partes)

def deserialize(self, data: str) - 'Node':
si no datos:
No.
tokens = data.split()
idx = 0
def dfs():
idx no local
val = int(tokens[idx]); idx += 1
child_cnt = int(tokens[idx]); idx += 1
nodo = Nodo(val)
node.children = [dfs() for _ in range(child_cnt)]
Nodo de retorno
retorno dfs()
`` `

‚ñ† **La complejidad** ‚Äì id√©ntica a la soluci√≥n Java.

-...

### 3.3 C++ Soluci√≥n

``cpp
#include ◊ôbits/stdc++.h
usando std namespace;

// LeetCode Node definition
struct Node {}
int val;
vector Node* ni√±os;
Nodo(int _val) : val(_val) {}
Nodo(int _val, const vector efectuadoNode* implicado _children) : val(_val), children(_children) {}
};

Clase Codec {}
public:
// Serializar el √°rbol N-ary a una cuerda
string serialize(Node* root) {
si (!root) regresan ";
stringstream ss;
dfsEncode(root, ss);
retorno ss.str(); // contiene espacio de seguimiento ‚Äì inofensivo
}

// Deserializar la cuerda de vuelta a un √°rbol N-ary
Nodo* deserialize(resultados de cadena restante) {
(data.empty())) return nullptr;
stringstream ss(data);
devolver dfsDecode(ss);
}

privado:
vacio dfsEncode(Nodo* nodo, stringstream &s) {
ss.
para (N√∫mero*: nodo-clientes)
dfsEncode(child, ss);
}

Nodo* dfsDecode(stringstream &s) {
int val, childCnt;
ss , t√≠tulo val ChildCnt;
Nodo* = Nodo(val);
node- t√≠tulochildren.resize(childCnt);
para (int i = 0; i)
node-clientes[i] = dfsDecode(ss);
nodo de retorno;
}
};
`` `

‚ñ† ** Complejidad** - las mismas caracter√≠sticas del espacio tiempo de `O(N).

-...

## üìö Blog Article ‚Äì ‚ÄúSerialize " Deserialize N‚Äêary Tree: The Complete Guide "

-...

### **Title (SEO‚ÄêOptimized)* *
‚ñ† **LeetCode 428 ‚Äì Serialize " Deserialize " N‚Äêary Tree ‚Üê Soluci√≥n paso a paso Consejos* *

-...

### **Meta Descripci√≥n**
‚ñ† ‚Äú¬øQuieres ace el duro problema de LeetCode #428? Aprende c√≥mo serializar y deserializar un √°rbol N‚Äêary, entender los patrones DFS vs BFS, y obtener informaci√≥n de entrevistas de trabajo. ‚Äù

-...

### **Tabla de contenidos**

1. [Problema instant√°nea](#problema-snapshot)
2. [Por qu√© importa](#why-it-matters)
3. [Key Constraints & Edge Cases](#key-constraints)
4. [Solution Overview](#solution-overview)
5. [DFS + Child Count ‚Äì The Classic Pattern](#dfs-child-count)
6. [BFS + Null Sentinel ‚Äì An Alternative](#bfs-sentinel)
7. [Code Walk‚ÄêThrough (Java / Python / C++)](#code-walk-through)
8. [Complexity " Pitfalls](#complexity-pitfalls)
9. [Entreview‚ÄêReady Tips](#interview-tips)
10. [Pensamientos Finales > Pasos Siguientes] (Pensamientos finales)

-...

##### **1vers‚É£ Problem Snapshot** Se hizo un nombre="problema-snapshot"

‚ñ† **LeetCode #428 ‚Äì Serialize and Deserialize N‚Äêary Tree**
‚ñ† Dificultad: **Hard**
‚ñ† Plazo: 1 s viv l√≠mite de memoria: 512 MB

‚ñ† *Dada una referencia a la ra√≠z de un √°rbol N‚Äêary, escriba dos funciones que: *

Silencio Silencio .
Silencio...
Silencio `serialize(root)` Silencio Convierte todo el √°rbol en una cuerda. Silencio
Silencio `deserializar(data)` Silencio Recrear el √°rbol original de esa cuerda. Silencio

‚ñ† *La salida de `deserialize(serialize(root)' debe ser **bit‚Äêfor‚Äêbit id√©ntica** al √°rbol original. *

-...

##### **2vides‚É£ ¬øPor qu√© importa ? ? ?

- **Core Data‚ÄêStructure Skill** ‚Äì Los √°rboles son ubiquitos (sistemas de ficheros, pares JSON, organigramas).
- **Entrevista Gold‚Äêmine** ‚Äì Muchas entrevistas de alto nivel piden ‚Äúserializar/deserializar‚Äù para probar la recursi√≥n, el traversal y la gesti√≥n estatal.
**Real‚ÄêWorld Relevance** ‚Äì Las bases de datos de gr√°ficos y los sistemas distribuidos necesitan una serializaci√≥n eficiente para el transporte de redes o la persistencia.

-...

### **3Ô∏è Key Constraints " Edge Cases** sa name= "key-constraints"

Silencio Caso Edge Silencioso Qu√© ver para Silencio
Silencio...
√Årbol vac√≠o (`root == null`) Vuelva una cuerda vac√≠a. Silencio
Silencio √Årbol de nodo √∫nico ‚Üê Debe serializarse como `valor 0 ` (0 ni√±os). Silencio
Silencio √Årbol profundo ( profundidad = 104) Silencio Profundidad de recuperaci√≥n ‚Üí considerar la recursi√≥n de la cola o BFS iterativa si los l√≠mites de la pila de lenguaje son una preocupaci√≥n. Silencio
Silencio Grandes valores de nodo (`‚â§ 109`) tenci√≥n Evite delimitadores de caracteres individuales que podr√≠an chocar con d√≠gitos. Use espacios o un separador no num√©rico. Silencio

‚ñ† *Recordar: No hay variables globales/est√°ticas ‚Äì cada llamada debe ser autocontenida. *

-...

#### **3flexiones sobre la Soluci√≥n Resumen**

‚ñ† **Dos patrones limpios** ‚Äì DFS (recursivo) y BFS (iterante).

‚àö‚â• **DFS + Child Count**
‚á© - codificar como: nodo Val childCnt child1 ... ni√±oK` recursivamente.
- Muy f√°cil de analizar usando un puntero √≠ndice.

**BFS + Null Sentinel**
‚àö‚â•n - Codigo nivel por nivel, insertando un centinela (`null`) para marcar el final de una lista de ni√±os.
> - Iterative, no index pointer needed, pero usted tiene que ‚Äúconocer‚Äù cuando cada sub-lista termina.

‚ñ† Ambos patrones logran tiempo lineal y espacio.

-...

############468‚É£ Solution Overview**

‚ñ† **FDAS + Cuento de Ni√±os** es el ** m√°s com√∫n** y recomendado debido a:

1. **Formaci√≥n m√≠nima** ‚Äì ning√∫n delimitador especial, solo espacios.
2. **Separaci√≥n determin√≠stica** ‚Äì siempre se lee un valor, luego el n√∫mero de ni√±os.
3. **Compact** ‚Äì la longitud de la cuerda es aproximadamente `2 * number_of_nodes + sum_of_child_counts`.

-...

#### **5Ô∏è DFS + Cuento de Ni√±os ‚Äì El Patr√≥n Cl√°sico** - "dfs-child-count"

#### Algorithm

1. **Serializar (DFS)* *
- Visita al nodo.
- Ap√©ndice `node.val` y `node.children.size()` separados por un espacio.
- Recupere a cada ni√±o.
2. **Deserialize (DFS)* *
- Dividir la cuerda por los espacios ‚Üí array `tokens`.
- Mantener un √≠ndice mutable ( " idx " o una lista de pitones).
- Read `tokens[idx++]` ‚Üí `val`.
- Lea el siguiente token ‚Üí `childCount`.
- Crear nodo con 'val'.
- Recusar los tiempos del ni√±o para construir ni√±os.
- Nodo de retorno.

‚ñ† *Por qu√© funciona* El formato es *prefijo* (nodo primero) y cada nodo declara expl√≠citamente cu√°ntos ni√±os siguen, por lo que el analizador nunca identifica los l√≠mites.

-...

#### **6vers‚É£ BFS + Null Sentinel ‚Äì An Alternative** ‚ñ†a name="bfs-sentinel"

Si prefieres una soluci√≥n **iterative**, puedes codificar nivel por nivel, insertando un 'null' centinela despu√©s de cada lista de ni√±os.

``text
[ rootVal, rootChildCnt, child1, child2, ..., null, ... ]
`` `

- Cada uno de ellos le dice al deserializador que la lista de ni√±os actual ha terminado.
‚àö - A√∫n es tiempo lineal, pero necesita mantener una cola y seguir posiciones centinelas.
Es ligeramente m√°s verbosa que DFS + cuenta para ni√±os.

-...

### **7Ô∏è Code Walk‚ÄêThrough** ‚ñ™ a name="code-walk-through" Login

Hemos proporcionado ** tres implementaciones completas** antes (Java, Python, C++).
Puntos clave para destacar durante una presentaci√≥n:

* Utilizar **espacios** como delimitadores ‚Äì sobreviven `split`/`istringstream` parsing.
* Siempre maneje ** √°rboles vac√≠os** temprano (retorna o pare una cuerda vac√≠a).
* La profundidad de la recuperaci√≥n est√° naturalmente atada por la altura del √°rbol; porque los √°rboles muy profundos consideran una versi√≥n recursiva de la cola o BFS.

-...

### **8Ô∏è Complejidad " Pitfalls** " se hizo un nombre= "complexity-pitfalls"

TENCI√ìN DE LA Operaci√≥n TENIDO Tiempo TENIDO Espacio ANTERIENTE Errores comunes
Silencio...
Silencio `serialize` Silencio `O(N)` Silencio `O(N)` cuerda Silencio Olvidando un espacio despu√©s del recuento de ni√±os ‚Üí parser mis-aligned. Silencio
Silencio `deserializar` Silencio `O(N)` Silencio `O(N)` recursi√≥n pila Silencio Usando variables globales (viola la apatridia). Silencio
Silencio Manejando grandes `val`  vidas `O(1)` per node Silencio `O(1)` Silencioso desbordamiento si usted almacena como 'car'. Usa cuerda para evitar. Silencio

‚ñ† #Pitfall 1** ‚Äì ** Index Out-of-Bounds** ‚Äì Siempre verifique que el array token tiene suficientes elementos antes de acceder.
‚ñ† #Pitfall 2** ‚Äì ** Espacios de navegaci√≥n** ‚Äì Algunos idiomas los tratan como fichas vac√≠as; sean consistentes.
‚ñ† #Pitfall 3** ‚Äì **Recursive Stack Overflow** ‚Äì Para √°rboles extremadamente arrugados (de profundidad = 104) podr√≠as alcanzar l√≠mites de pila en Java/Python; considera aumentar el tama√±o de la pila o utilizar BFS.

-...

##### **9Ô∏è Interview‚ÄêReady Tips** "trabaja un nombre="interview-tips"

1. **Explicar su formato al frente** ‚Äì ‚ÄúVoy a usar el DFS con recuento infantil porque...‚Äù.
2. **Mostrar los casos de borde** ‚Äì √Årbol vac√≠o, nodo √∫nico, grandes valores.
3. **Discusi√≥n Complejidad** ‚Äì Tiempo lineal " espacio; justificar la pila de recursi√≥n.
4. **Menci√≥n No Global State** ‚Äì ‚ÄúCada llamada utiliza s√≥lo variables locales / pila de recursi√≥n. ‚Äù
5. **Opcional: Agregue Tests de Unidad** ‚Äì Prueba de ida y vuelta serializaci√≥n/deserializaci√≥n r√°pidamente.

-...

#### **10Ô∏è Pensamientos Finales > Pr√≥ximos Pasos** Se hizo un nombre= "final-thoughts"

* Mastering LeetCode #428 te equipa con una t√©cnica de traversal de √°rboles ** inversatiles** y muestra tu capacidad de ** estado de c√≥digo** en una cadena compacta.
* Practicar extendiendo la soluci√≥n a **N-ary graphs** o ** formatos de serializaci√≥n de √°tomos**.
* A√±ade pruebas de unidad en tu idioma preferido para simular escenarios del mundo real.
* Sigue explorando los problemas de LeetCode *Design* (por ejemplo, `Serialize/Deserialize Binary Search Tree`, `Design Twitter`, etc.) ‚Äì se aplican los mismos patrones.

-...

‚ñ† **Happy Coding** y **Good Luck** en su pr√≥xima entrevista de algoritmos! üöÄ

-...

### ** Call to Action**

*Si te gust√≥ este post, pulsa el bot√≥n **Suscribir**, comenta a continuaci√≥n con tus propias soluciones o preguntas, y comparte en LinkedIn o Twitter con el hashtag `#LeetCode428`. *

-...

Siguiente Paso Recursos

1. Conjunto de problemas LeetCode: ‚Äú√Årbol interior ‚Äì serializaci√≥n‚Äù
2. ‚ÄúRecursive vs Iterative Tree Traversal‚Äù ‚Äì Coursera / Udacity.
3. ‚ÄúSerializaci√≥n de Gr√°ficos‚Äù ‚Äì G4G y Hackerrank desaf√≠os.

-...

‚ñ† **End of Article**

-...

#### üì¶ 4◊ô‚É£ Final Wrap‚Äê Arriba

Ahora tienes:

1. ** C√≥digo totalmente funcional y ap√°tridas** en tres idiomas.
2. Un **conciso, explicaci√≥n de entrevista** de por qu√© el problema importa.
3. Un **completo blog** que usted puede publicar en Medium, dev.to, o su sitio de cartera personal para demostrar dominio.

Buena suerte aplastando a LeetCode 428 e impresionando a los gerentes de contrataci√≥n! üöÄ