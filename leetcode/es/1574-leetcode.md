-...
T√≠tulo: LeetCode 1574. Subarray m√°s corto para ser eliminado para hacer Array Ordenar -
descripci√≥n: Titular
Fecha: 2025-09-21
categor√≠as: []
autor: muses
tags: []
HideToc: verdadero
-...
# LeetCode 1574 ‚Äì ‚ÄúShortest Subarray to be Removed to Make Array Sorted‚Äù

‚ñ† *Problema*: Dado un array entero `arr`, retire un sub-array contiguo (puede estar vac√≠o) para que los elementos restantes est√©n en orden no-disminuci√≥n. Devuelve la longitud del sub-array m√°s corto que se puede quitar.

Dificultad para vivir Medio tiempo para vivir
Silencio----------------------------------
√ò 105 √ò 0 ‚â§ arrr.length ‚â§ 109 ¬¶
TENIDO Tiempo TENIDO O(n) TENIDO O(1) extra space TENIDO

A continuaci√≥n se presentan soluciones de producci√≥n en **Java**, **Python** y **C+**.
Despu√©s del c√≥digo nos sumergimos en un art√≠culo de blog de sangre completa que explica el *bueno, el malo y el feo* de este problema ‚Äì ideal para pulir tus notas de entrevista o escribir un art√≠culo de b√∫squeda de trabajo.

-...

## üîß 1. Soluci√≥n Java

``java
importar java.util*;

Clase Soluci√≥n {
int findLengthOfShortestSubarray(int[] arr) {
int n = arr.length;
// 1 / ‚É£ El prefijo m√°s largo que no disminuye
int left = 0;
mientras (izquierda + 1) se hac√≠a arrr[izquierda] arr[izquierda + 1]) izquierda++;

// El array ya est√° clasificado
si (izquierda == n - 1) retorno 0;

// 2Œ©‚É£ Sufijo no disminuyente
int right = n - 1;
mientras (derecho ‚àö‚â• 0 " p√É3rrr [derecha - 1] ◊ô= arr[derecha]) derecho...

Inicio con los dos candidatos obvios
int ans = Math.min(n - left - 1, right);

// 4 millas ‚É£ Dos puntos de fusi√≥n: mantener la parte de prefijo de la longitud i,
// mantener la parte de sufijo a partir de j, y comprobar la brecha
int i = 0, j = derecha;
mientras (i ◊ô= izquierda " p " ) {
si (arr[i] <= arr[j]) { // puede mantener arrr[i] y arr[j]
ans = Math.min(ans, j - i - 1); // delete middle
i++; // probar un prefijo m√°s largo
} otra { // necesidad de mover sufijo puntero
j++;
}
}
devolver los ans;
}
}
`` `

‚ñ† **La complejidad**:
‚Ä¢ Tiempo ‚Äì **O(n)** (tres escaneos lineales)
‚Ä¢ Espacio ‚Äì **O(1)**

-...

## üîß 2. Soluci√≥n de pit√≥n

``python
de la importaci√≥n Lista

Soluci√≥n de clase:
def findLengthOfShortestSubarray(self, arr: List[int]) - t√≠tulo int:
n = len(arr)

# El prefijo m√°s largo que no disminuye
izquierda = 0
mientras que la izquierda + 1 se realiz√≥ n y arrr[izquierda] se realiz√≥= arr[izquierda + 1]:
izquierda += 1
si la izquierda == n - 1:
retorno 0

# El sufijo m√°s largo que no disminuye
derecho = n - 1
y arrr [derecha - 1]
derecho -= 1

as = min(n - left - 1, right) # dos triviales

i, j = 0, correcto
mientras que yo hice la izquierda y j
si arrr[i]
as = min(ans, j - i - 1)
i += 1
m√°s:
j += 1
Retorno
`` `

‚ñ† *La complejidad*
‚Ä¢ Tiempo ‚Äì **O(n)**
‚Ä¢ Espacio ‚Äì **O(1)**

-...

## üîß 3. C++ Soluci√≥n

``cpp
#include ◊ôbits/stdc++.h
usando std namespace;

Clase Soluci√≥n {
public:
int findLengthOfShortestSubarray(vector fieltro unido arr) {
int n = arr.size();
// Prefijo m√°s largo que no disminuye
int left = 0;
mientras (izquierda + 1) se hac√≠a arrr[izquierda] arr[izquierda + 1]) izquierda++;

si (izquierda == n - 1) retorno 0; // ya ordenados

// Sufijo m√°s largo que no disminuye
int right = n - 1;
mientras (derecho ‚àö‚â• 0 " p√É3rrr [derecha - 1] ◊ô= arr[derecha]) derecho...

int ans = min(n - left - 1, right); // two simple deletions

// Dos puntos de fusi√≥n
int i = 0, j = derecha;
mientras (i ◊ô= izquierda " p " ) {
si (arr[i] {}
ans = min(ans, j - i - 1);
++i;
. ‚ô´ ... {
++j;
}
}
devolver los ans;
}
};
`` `

‚ñ† *La complejidad*
‚Ä¢ Tiempo ‚Äì **O(n)**
‚Ä¢ Espacio ‚Äì **O(1)**

-...

## üìö 4. Blog Art√≠culo ‚Äì ‚ÄúEl Bien, el Mal‚Äù el Ugly de LeetCode 1574‚Äù

‚ñ† **T√≠tulo**: El Bien, el Mal el Ugly de LeetCode 1574 ‚Äì Subarray m√°s corto para ser eliminado para hacer Array Ordenar*
‚ñ† **Meta Descripci√≥n**: Master LeetCode 1574 con una profunda inmersi√≥n en su soluci√≥n √≥ptima, trampas y explicaci√≥n de entrevista. Ideal para ingenieros de software que buscan impresionar a los gerentes de contrataci√≥n.

-...

Introducci√≥n

Cuando los reclutadores buscan una agudeza algor√≠tmica, a menudo le dan problemas que *mira* f√°cil pero ocultan los obst√°culos ocultos. **LeetCode 1574** es uno de estos problemas: *Remover un sub-array para que el array restante no disminuye.* En la superficie se siente como una simple ‚Äúremueva el segmento malo m√°s grande‚Äù pregunta, pero la soluci√≥n √≥ptima hinges en una fusi√≥n de dos puntos y manejo cuidadoso de los casos de borde.

En este art√≠culo:

- Explique por qu√© un enfoque ingenuo falla
- Mostrar la soluci√≥n √≥ptima **O(n)** en 3 idiomas
- Discuss the *good, the bad, and the feo* desde una perspectiva de entrevista
- Proporcione consejos de entrevista ‚Äútomada‚Äù que puede mencionar en el tel√©fono

-...

#### 2down‚É£ El problema en ingl√©s sencillo

Se le da un array entero `arr`. Puedes eliminar *one* sub-array contiguo (los elementos que eliminas no tienen que ser contiguos en el array final, simplemente se eliminan). Despu√©s de la eliminaci√≥n, los elementos **remanentes deben ser ordenados en orden no disminuyente**.

Su tarea: devolver el n√∫mero m√≠nimo de elementos** que tiene que eliminar.

*Examples*

TEN ANTERIOR ANTERIOR ANTERIOR ANTERIOR
Silencio----------...
TENIDO `[1, 2, 3, 10, 4, 2, 3, 5]` TENIDO `3` TENIDO Supr√≠mase `[10, 4, 2]` ‚Üí `[1, 2, 3, 3, 5]`. Silencio
Silencio `[5, 4, 3, 2, 1]` Silencio `4` Silencio La matriz est√° disminuyendo estrictamente; mantenga cualquier elemento √∫nico. Silencio
Silencio `[1, 2, 3]` Silencio `0` Silencio Ya ordenados. Silencio

-...

#### 3down‚É£ ¬øPor qu√©?

Un primer pensamiento com√∫n: *‚ÄúEncuentra el prefijo m√°s largo y sufijo, luego elimina todo entre.‚Äù*
Esto le da una respuesta de `derecha - izquierda - 1`, pero no siempre es √≥ptima. Por ejemplo:

`` `
arr = [1, 3, 5, 2, 4, 6]
`` `

- Prefijo m√°s largo: `[1, 3, 5]`
- Sufijo m√°s largo:
- Eliminar el medio ‚Üí `3` elementos eliminados.

Pero en realidad podemos eliminar `[5, 2]` (2 elementos) y todav√≠a tienen `[1, 3, 4, 6]` ordenados.
El defecto es que debemos mantener al menos un elemento del sufijo** que *se adapta* despu√©s del prefijo.

Otra idea ingenua: probar todas las posibles eliminaciones a trav√©s de dos bucles anidados (`O(n2)`), que pasar√°n el tiempo por `n = 105`.

As√≠ que necesitamos un algoritmo **O(n)** que fusiona inteligentemente el sufijo prefijo mientras respeta la limitaci√≥n de orden.

-...

### 4down‚É£ The Optimal O(n) Strategy ‚Äì Two‚ÄêPointer Merge

1. **Identificar el prefijo m√°s largo que no disminuye**
Esc√°ner desde la izquierda hasta `arr[i]. Que ese √≠ndice sea "izquierda".

2. ** Identificar Sufijo No Disminuir*
Esc√°ner desde la derecha hasta `arr[j-1]. Que ese √≠ndice sea "derecho".

3. **Si toda la matriz ya est√° clasificada** (`izquierda == n-1`), la respuesta es `0`.

4. **Initializar Respuesta** con dos candidatos obvios:
- Eliminar todo despu√©s del prefijo ‚Üí `n - izquierda - 1`
- Borrar todo antes del sufijo ‚Üí 'derecha'

4. *Merge con dos punteros*
- Set `i = 0`, `j = right`.
- Mientras que " yo " , izquierda " y " ,
- Si 'arr[i] Puedes quedarte con las dos.
* Eliminar el segmento medio* ‚Üí candidato = `j - i - 1`.
Incremento `i` para probar un prefijo m√°s largo.
- Else ( "arr[i] el elemento sufijo actual no puede permanecer despu√©s de `arr[i]`.
Mover `j` adelante para encontrar un elemento sufijo que es lo suficientemente grande.

4. **Retorno M√≠nimo**

Este algoritmo visita cada elemento al m√°ximo dos veces ‚Üí **O(n)** tiempo y **O(1)** espacio.

-...

#### 5down‚É£ El C√≥digo ‚Äì ‚ÄúBien, el Mal‚Äù

#### 5.1 Bien - La Explicaci√≥n de la Entrevista

- **Escaneo de l√≠nea** ‚Äì muestra que usted entiende la importancia de * pre-computar* √≠ndices de l√≠mites.
- **Two-pointer merging** ‚Äì demuestra trucos avanzados de puntero (com√∫n en ‚ÄúSuceso de Incremento Mayor‚Äù o ‚ÄúDeleciones m√≠nimas para mantener el orden‚Äù).
- ** Manejo de maletas Edge** ‚Äì el guardia `si (izquierda == n-1)` demuestra que piensa en entradas ya clasificadas.

‚ñ† *Entrevista Tip*: ‚ÄúEn un paso lineal, puedo capturar r√°pidamente los l√≠mites ordenados, luego combinarlos con una t√©cnica de dos puntos para respetar las limitaciones de orden. ‚Äù

#### 5.2 Bad ‚Äì Los saltos comunes

Silencio Pitfall Silencio Reason Silencio
Silencio------------
Silencio **Ignorando la condici√≥n de ‚Äúfits despu√©s‚Äù** Silencio elimina demasiados elementos o pierde una eliminaci√≥n m√°s corta. tenci√≥n Compare el √∫ltimo elemento guardado del prefijo con el primer elemento guardado del sufijo. Silencio
Silencio **Using nested loops** Silencio O(n2) ‚Üí TLE for `n=105`. Silencio Usar dos escaneos lineales y un solo paso de dos puntos. Silencio
Silencio **Casos de bordes de apariencia superior** (`arr=[1]`, todos los elementos iguales o estrictamente disminuyendo). tenci√≥n puede producir `-1' o √≠ndice incorrecto.  Agregue el comprobante ‚Äúya ordenado‚Äù y mantenga ‚Äúi‚Äù = izquierda‚Äù / `j  observado n‚Äô l√≠mites. Silencio

#### 5.3 Ugly ‚Äì The Hidden ‚ÄúTrick‚Äù That Breaks the Na√Øve Idea

‚ñ† **El Ugly** es la realizaci√≥n de que *no puedes pegar el prefijo y sufijo arbitrariamente*.
‚ñ† Es tentador pensar que puedes ‚Äúesquipar‚Äù el medio y mantener el sufijo. Pero si `arr[left] > arr[right]`, el elemento sufijo no puede seguir el prefijo, por lo que debe mover el puntero sufijo hasta que encuentre un elemento "compatible".

En la pr√°ctica, muchos candidatos se quedan atrapados en esta trampa exacta, dando lugar a respuestas incorrectas.
La clave es tratar el puntero de sufijo como un **b√∫squeda** en lugar de un segmento fijo.

-...

#### 5down‚É£ Entrevista Take‚Äê Aways

1. **Declara tu plan primero**
‚ÄúEncontrar√© el prefijo y sufijo m√°s largos, luego tratar√© de fusionarlos mientras mantiene el orden. ‚Äù
Esto demuestra que est√° estructurando la soluci√≥n.

2. **Explicar el cheque de Edge‚ÄêCase* *
‚ÄúSi la matriz ya est√° ordenada, no podemos eliminar nada. ‚Äù
Esta peque√±a l√≠nea suele salir con candidatos.

3. # Discusi√≥n de la Idea de dos puntos #
‚ÄúVoy a caminar por el array de izquierda y derecha, luego mover los punteros hasta que encuentre un par que mantenga el orden. ‚Äù
Destaca por qu√© es **linear**.

4. ** Complejidad de la menci√≥n Temprano* *
‚ÄúMi algoritmo funciona en tiempo O(n) y espacio O(1), satisfaciendo las limitaciones. ‚Äù

5. **Optional Python/Java/C++ Code Snippet**
Compartir una de las soluciones anteriores en el tel√©fono; los reclutadores aprecian ver que puede escribir el c√≥digo correcto en el lugar.

-...

#### 5down‚É£ Conclusi√≥n

LeetCode 1574 es un problema enga√±osamente sutil que recompensa a los que:

- Reconocer el *boundary* de prefijo ordenados/suffix
- Comprender la necesidad de un *merge* que preserve el orden
- Aplicar una t√©cnica de dos puntos** para lograr tiempo lineal

Con las tres soluciones limpias y agn√≥sticas m√°s arriba, usted est√° listo para golpear cualquier entrevista t√©cnica que le haga esta pregunta. Recuerde enfatizar **por qu√© las soluciones ingenuas fallan** ‚Äì demuestra una visi√≥n m√°s profunda del algoritmo.

¬°Feliz codificaci√≥n, y puede aplastar esa pr√≥xima entrevista de contrataci√≥n! üéØ

-...

### üé§ Interview Tip Cheat‚Äê Sheet

Silencio t√≥xico Qu√© decir
Silencio...
Silencio **Phone screen** Silencio ‚ÄúEncontrar√© primero el prefijo y sufijo m√°s largos, y luego los fusionar√© con un escaneo de dos puntos‚Äù. Silencio
"Mi soluci√≥n es lineal y utiliza espacio constante, por lo que escala a la m√°xima limitaci√≥n de 105". Silencio
Silencio **Code review** Silencio ‚ÄúEl truco clave es asegurar que el elemento sufijo que guarda es mayor o igual al √∫ltimo elemento del prefijo elegido‚Äù. Silencio

-...

#### üîó Enlaces √∫tiles

- LeetCode 1574 Discussion: https://leetcode.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted/discuss/
- Gu√≠a T√©cnica de dos puntos: https://leetcode.com/articles/two-pointer-solution/
- Java Interview Prep: https://www.javaworld.com/article/3201234/learn-30-java-interview-questions.html

-...

¬°Feliz entrevista! Si te result√≥ √∫til este art√≠culo, comp√°rtalo en LinkedIn o Twitter con #LeetCode #CodingInterview. üöÄ