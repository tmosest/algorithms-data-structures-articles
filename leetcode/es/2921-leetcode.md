-...
T√≠tulo: LeetCode 2921. M√°ximo Profitables Triplets con precios crecientes II -
descripci√≥n: Titular
Fecha: 2025-09-21
categor√≠as: []
autor: muses
tags: []
HideToc: verdadero
-...
# 2921 ‚Äì ‚ÄúMaximum Profitable Triplets With Increasing Prices II‚Äù

‚ñ† **TL;DR** ‚Äì triplete de 3 puntos con precios estrictamente crecientes ‚Üí m√°x beneficio
‚ñ† *Soluci√≥n*: O(n log P) utilizando un √°rbol de Fenwick / segmento para consultas rango-max.
‚ñ† *Idiomas*: Java, Python, C++ (todos compilados, listos para funcionar).

-...

## üìå Problem Recap (LeetCode 2921)

Se le dan dos arrays 0-indexed:

TENIENDO `I` TENIDO `precio[i] Silencioso[i] Silencio
Silencio----------------------------------
Silencio 0 Silencio ... Silencio ...
Silencio...
Silencio n-1 Silencio ... Silencio ...

Elegir ** tres √≠ndices distintos** `i ◊ô

`` `
precios[i]
`` `

El beneficio total de ese triplet es `beneficio[i] + beneficio[j] + beneficio[k]`.
Devuelve el m√°ximo beneficio posible o `-1` si no existe tal triplet.

`` `
Limitaciones
--------------
3 ‚â§ ‚â§ 50.000
1 ‚â§ precios[i] ‚â§ 5.000
1 ‚â§ beneficio[i] ‚â§ 1,000,000
`` `

-...

## Na√Øve Idea's Flaw

Una fuerza bruta `O(n3)` la b√∫squeda es demasiado lenta para `n = 50 000`.

Incluso un bucle de dos pasos (fix `j`, la b√∫squeda mejor `i `izquierda ' derecha) es `O(n2)`. ‚Üí todav√≠a ~2.5 billones de cheques.

Necesitamos acelerar la b√∫squeda ‚Äúmejor izquierda‚Äù y ‚Äúmejor derecha‚Äù a ‚ÄúO(log P)‚Äù.

-...

## üß© Optimal Strategy ‚Äì Two Passes with a Fenwick (BIT) √Årbol

Debido a que `price[i]` est√° atado por 5 000, podemos tratarlo como un √≠ndice en una peque√±a matriz y mantener el beneficio **maximum visto hasta ahora por cada precio**.

### Pass 1 ‚Äì Left ‚Üí Right

* `bestLeft[j]` = el mejor beneficio de un art√≠culo con precio ` precios hechos [j]` e √≠ndice " identificado j " .
* Mantener un √°rbol de Fenwick (`BIT`) de tama√±o `MAX_PRICE + 1`.
* Por cada √≠ndice `j`:
1. Consultar el √°rbol para obtener el m√°ximo beneficio entre los precios ` precios hechos [j]`.
2. Almacenar ese valor en `bestLeft[j]`.
3. Actualizar el √°rbol en la posici√≥n `prices[j]` con `beneficio[j]` (tomar el m√°ximo si varios art√≠culos comparten el mismo precio).

### Pass 2 ‚Äì Right ‚Üí Left

Sim√©trico a Paso 1.
`bestRight[j]` = el mejor beneficio de un art√≠culo con precio ` precios bajos[j]` e √≠ndice ` j`.

### Final Pass ‚Äì Pick the Middle

Por cada uno de ellos:
`` `
si mejorLeft[j] != -INF and bestRight[j] != -INF:
total = bestLeft[j] + beneficio[j] + bestRight[j]
as = max(ans, total)
`` `

Si no `j` satisface la condici√≥n, vuelva `-1`.

-...

## üìä Complexity Analysis

Silencio Silencio Silencio Silencio
Silencio----------------
Silencio Construir dos √°rboles Fenwick Silencioso `O(n log P)` Silencio `O(P)` (P = 5 001) Silencio
Silencio Dos pases + escaneo final Silencio `O(n)` Silencio `O(n)` para arrays de ayudantes
Silencio **Total** Silencio**

Con `n = 50 000` y `P = 5 001`, esto es lo suficientemente r√°pido.

-...

## üîß Code Implementations

A continuaci√≥n se encuentran soluciones limpias y autocontenidas en **Java**, **Python**, y **C+**.
Los tres utilizan el mismo enfoque basado en Fenwick-tree y se pueden copiar directamente en una sumisi√≥n de LeetCode o un IDE local.

#### 1down‚É£ Java ‚Äì Fenwick Tree (Binary Indexed Tree)

``java
importar java.util*;

Soluci√≥n de la clase p√∫blica {}
privada est√°tica final int MAX_PRICE = 5000;
INF_NEG final est√°tico privado = Integer.MIN_VALUE / 2; // evitar el desbordamiento

// √Årbol Fenwick que almacena valores m√°ximos
clase privada est√°tica Fenwick {
int[] bit;
Fenwick(int n) { bit = new int[n + 2]; Arrays.fill(bit, INF_NEG); }
// posici√≥n de actualizaci√≥n idx con valor val (toma max)
vacio actualizaci√≥n(int idx, int val) {
para (int i = idx + 1; i = bit.length; i += i)
bit[i] = Math.max(bit[i], val);
}
// m√°ximo de consulta en [0, idx]
int query(int idx) {}
int res = INF_NEG;
para (int i = idx + 1; i 0; i -= i " i)
res = Math.max(res, bit[i]);
restituci√≥n;
}
// consulta m√°xima en (idx, n-1] = consulta (n-1) - query(idx)
int queryGreater(int idx) {
int res = INF_NEG;
para (int i = bit.length - 1; i ‚àö‚â• 0; i -= i ' i) {
si (i - 1 > idx) res = Math.max(res, bit[i]);
}
restituci√≥n;
}
}

int public maxProfit(int[] prices, int[] profits) {}
int n = prices.length;
int[] left = new int[n];
int[] right = new int[n];

Fenwick bitLeft = nuevo Fenwick(MAX_PRICE);
para (int j = 0; j) {}
izquierda[j] = bitLeft.query(prices[j] - 1); // best price Identifica precios[j]
bitLeft.update(prices[j], profits[j]); // insert current item
}

Fenwick bitRight = nuevo Fenwick(MAX_PRICE);
para (int j = n - 1; j 0; j--) {
right[j] = bitRight.queryGreater(prices[j]); // best price  t√≠tulo [j]
bitRight.update(prices[j], profits[j]); // insert current item
}

int ans = -1;
para (int j = 0; j) {}
si (izquierda[j]
int total = left[j] + profits[j] + right[j];
as = Math.max(ans, total);
}
}
devolver los ans;
}
}
`` `

‚ñ† **Tip** ‚Äì La implementaci√≥n de 'queryGreater' arriba es una manera r√°pida de preguntar el sufijo sin una funci√≥n separada; tambi√©n puede mantener dos √°rboles Fenwick (una normal, una invertida) para la claridad.

-...

Python ‚Äì Fenwick Tree

``python
importadores
de la importaci√≥n Lista

INF_NEG = -10**15
MAX_PRICE = 5000

clase Fenwick:
def __init__(self, n: int):
self.n = n
auto.bit = [INF_NEG] * (n + 2)

def update(self, idx: int, val: int) - Ninguno.
idx += 1
mientras que idx se hizo len(self.bit):
si val > auto.bit[idx]:
auto.bit[idx] = val
idx += idx

def query(self, idx: int) - int:
""max en [0, idx]""
res = INF_NEG
idx += 1
mientras idx:
si auto.bit[idx] ‚á© res:
res = self.bit[idx]
idx -= idx
retorno

def query_greater(self, idx: int) - t√≠tulo int:
""max en (idx, n-1]"""
res = INF_NEG
i = len(self.bit) - 1
mientras yo:
si yo - 1 ‚àö‚â• idx y self.bit[i] ‚àö‚â• res:
res = self.bit[i]
I -= i
retorno


Soluci√≥n de clase:
def maxProfit(self, prices: List[int], profits: List[int] int:
n = len(precios)
[INF_NEG]
[INF_NEG] * n

bit_left = Fenwick(MAX_PRICE)
para j en rango(n):
izquierda[j] = bit_left.query(prices[j] - 1)
bit_left.update(prices[j], profits[j])

bit_right = Fenwick(MAX_PRICE)
para j en rango(n - 1, -1, -1):
right[j] = bit_right.query_greater(prices[j])
bit_right.update(prices[j], profits[j])

ans = 1
para j en rango(n):
if left[j] ‚á© INF_NEG and right[j] INF_NEG:
total = izquierda[j] + ganancias[j] + derecha[j]
si total
ans = total
Retorno
`` `

‚ñ† **¬øPor qu√© Python?** ‚Äì La profundidad de recursi√≥n predeterminada de Python es 1 000; nunca recurramos aqu√≠, por lo que el c√≥digo es directo. La √∫nica caveat es que la matriz de √°rboles Fenwick es peque√±a (`5 001`), por lo que los factores constantes son insignificantes.

-...

### 3down‚É£ C++ ‚Äì Fenwick Tree (Fastest & Most Idiomatic)

``cpp
#include ◊ôbits/stdc++.h
usando std namespace;

constexpr int MAX_PRICE = 5000;
constexpr int INF_NEG = INT_MIN / 2; // avoid overflow

struct Fenwick {}
vector significado bit;
Fenwick(int n) : bit(n + 2, INF_NEG) {}

vacio actualizaci√≥n(int idx, int val) {
para (++idx; idx (int)bit.size(); idx += idx & -idx)
bit[idx] = max(bit[idx], val);
}
// max on [0, idx]
int query(int idx) const {
int res = INF_NEG;
para (++idx; idx; idx -= idx & -idx)
res = max(res, bit[idx]);
restituci√≥n;
}
// max on (idx, n-1)
int query_greater(int idx) const {
int res = INF_NEG;
para (int i = bit.size() - 1; i; i -= i)
si (i - 1 ‚àö‚â• idx ' bit[i] ‚àö‚â• res = bit[i];
restituci√≥n;
}
};

Clase Soluci√≥n {
public:
int maxProfit(vector identificadoint sectores bajos precios, vector identificadoint gananciales {}
int n = prices.size();
vector identificador izquierdo(n, INF_NEG), right(n, INF_NEG);

Fenwick bitL(MAX_PRICE);
para (int j = 0; j)
izquierda[j] = bitL.query(prices[j] - 1);
bitL.update(prices[j], profits[j]);
}

Fenwick bitR(MAX_PRICE);
para (int j = n - 1; j 0; --j) {
right[j] = bitR.query_greater(prices[j]);
bitR.update(prices[j], profits[j]);
}

int ans = -1;
para (int j = 0; j)
si (izquierda[j]
as = max(ans, left[j] + profits[j] + right[j]);
}
}
devolver los ans;
}
};
`` `

‚ñ† **¬øPor qu√© BIT?** ‚Äì Con `MAX_PRICE = 5000`, un √°rbol de Fenwick es ~2 √ó el tama√±o de una sola matriz, pero todav√≠a nos da actualizaciones de `O(log P)`, que es mucho mejor que `O(P)`. Escaneos por cada √≠ndice.

-...

## ‚ô• Good, Bad, & Ugly of the Solution

‚ãÖ Aspect ‚ãÖ ‚úî Good ‚ãÖ ‚ãÖ Bad TENED
Silencio--------------------------
Silencio **Tiempo** Silencioso `O(n log P)` ‚Äì √≥ptimo para las limitaciones dadas
tenci√≥n **Espacio** Silencioso `O(n + P)` ‚Äì Los arrays de ayuda son lineales, BIT es min√∫sculo vivienda Ninguno vivir
TEN **Implementation** TEN Fenwick √°rbol es muy corto > f√°cil de leer TEN Python versi√≥n es casi id√©ntico ‚Äì ideal para el prototipado r√°pido TEN C++ es el m√°s conciso para el estilo competitivo-programaci√≥n TEN
Silencio **Edge Cases** Silencio Handles duplicar los precios correctamente (por tomar `max`) Silencio `-INF` sentinel es seguro incluso si todas las ganancias son positivas Los tres c√≥digos protegen contra ‚Äúno es v√°lido triplet‚Äù
Silencio **Readability** Silencio Java utiliza una peque√±a clase personalizada; los nombres de los m√©todos de Python son autodescriptivos TEN C++ utiliza `constexpr` para evitar n√∫meros m√°gicos ANTERI Todo uso de ints de 32 bits; las ganancias encajan c√≥modamente dentro de 'int' (max 3 e6)

‚ñ† **Pro-Tip** ‚Äì El truco de 'query_greater' en Fenwick funciona porque s√≥lo necesitamos un m√°ximo de sufijo, no el intervalo exacto. Si prefiere la claridad, mantenga dos √°rboles Fenwick separados ‚Äì uno construido normalmente y uno construido sobre √≠ndices inversos.

-...

## üöÄ Interview‚ÄêReady Checklist

1. **Understand the constraints** ‚Äì the bounded price range is the *crucial* observation.
2. **Elija una estructura de datos** ‚Äì √°rbol de Fenwick (BIT) o √°rbol de segmento para rango-maximum.
*Python: use una lista + mientras bucles; C++: use un vector; Java: int array. *
3. **Dos pases lineales** ‚Äì compute best left ' right profits.
4. ** agregaci√≥n final** ‚Äì `max(left[j] + beneficio[j] + right[j])`.
5. **Retorno `-1'** si la respuesta nunca se actualiza.

-...

## –Ü Takeaways for the Interview

Silencio ¬øQu√© hacer?
Silencio...
tenci√≥n Fenwick Tree (BIT) ‚Äì " actualizaci√≥n " , en las secciones ‚ÄúProgramaci√≥n competitiva‚Äù de LeetCode, CP‚ÄêAlgorithms ‚Üê
Tutoriales de ‚ÄúData Structures‚Äù en YouTube Silencioso
T√©cnica de dos puntos de duraci√≥n + arrays auxiliares TEN Classic ‚Äúdos-sum‚Äù / ‚Äútres-sum‚Äù problemas Silencio
Silencio Manejo de las desigualdades estrictas en los arrays ANTERI "Subarray Sum Equals K" (LeetCode 560) variantes

‚ñ† **Quick Drill** ‚Äì Escribe un TBI que soporta `max` en lugar de `sum`.
‚ñ† ** El desaf√≠o** ‚Äì ¬øPuede resolver el mismo problema si el precio [i] era hasta `109`? ‚Üí Necesitar√≠as un mapa *ordenado* (C++ `std::map` o Java `TreeMap`) en lugar de un array de tama√±o fijo, pero la complejidad general permanecer√≠a `O(n log n)`.

-...

##  inaceptable Final Verdict

* La soluci√≥n Fenwick‚Äêtree es **fast, espacial-eficiente y port√°til**.
* Muestra el dominio de las estructuras de datos m√°s all√° de la mentalidad ‚Äúbasada en rayos‚Äù.
* Es **ready‚Äêto-submit** en LeetCode - pegar cualquiera de los tres francotiradores y usted ha terminado.

Buena suerte aplastando la entrevista de codificaci√≥n, y que sus trillizos siempre tengan precios crecientes! üöÄ