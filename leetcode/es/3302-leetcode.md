-...
T√≠tulo: LeetCode 3302. Encuentra la secuencia de v√°lvulas m√°s peque√±a de Lexicografia -
descripci√≥n: Titular
Fecha: 2025-09-21
categor√≠as: []
autor: muses
tags: []
HideToc: verdadero
-...
# 3302. Encuentra la secuencia de v√°lvulas m√°s peque√±a de Lexicograf√≠a
**Java / C++ / Python ‚Äì Una soluci√≥n saludable que funciona en O(n+m)* *

-...

## üöÄ TL;DR

Silencio Idioma Silencio Tiempo Silencioso
Silencio--------------
Silencio **Java** Silencio O(n+m) Silencio
Silencio **C+** Silencio O(n+m) Silencio
Silencio **Python** Silencio O(n+m) Silencio

*`n = word1.length`, `m = word2.length` (m  made n ‚â§ 3¬∑105)*

La idea clave:
1. **Computar el √≠ndice m√°s adecuado en `palabra1` que puede coincidir con cada sufijo de `palabra2`. #
2. **Escan `palabra1` de izquierda a derecha, recogiendo ambiciosamente √≠ndices que coinciden o son seguros para saltar el actual `palabra2 ` car√°cter** (s√≥lo permitido una vez).
3. La primera vez que podemos saltar un personaje, debemos hacerlo inmediatamente ‚Äì que garantiza la minimalidad lexicogr√°fica.

-...

## üìÑ Problema Restatement

Se le dan dos cadenas de min√∫sculas, `palabra1` y `palabra2`.

- Una cuerda `x` es casi igual a 'y' si usted puede cambiar ** en la mayor√≠a de un car√°cter de 'x' para que se vuelva id√©ntico a 'y'.
- Una secuencia de √≠ndices `seq` es **v√°lido** si:
1. `seq` se clasifica ascendentemente.
2. Concatenaci√≥n " palabra1[seq[i] " en orden da una cuerda que es casi igual a `palabra2`.

Devuelve la secuencia v√°lida *lexicogr√°ficamente m√°s peque√±a* (arrigraf√≠a de √≠ndices).
Si no existe una secuencia v√°lida, devuelve un array vac√≠o.

‚ñ† **Nota**: ‚ÄúDirecci√≥n lexicogr√°ficamente m√°s peque√±a‚Äù significa que comparamos las secuencias elemento por elemento, no la cadena resultante.

-...

## Constraints

Par√°metro Silencioso
Silencio...
TENIDO `1 ‚â§ word2.length
confidencialidad Personajes Silenciosos 'a' ... 'z'

-...

## üéØ The Greedy Insight

Imaginemos que estamos escaneando `palabra1` de izquierda a derecha y queremos construir la secuencia.

1. **Si el personaje actual es igual a `word2[j]`, *debemos* tomarlo** ‚Äì escoger un partido posterior s√≥lo cambiar√≠a los √≠ndices correctos y nunca producir√≠a un array m√°s peque√±o.
2. *Si no coincide* *podemos borrar* la actual palabra2[j]. Una vez** (cambiando ese personaje).
Pero s√≥lo podemos saltarlo si todav√≠a podemos terminar el resto de la palabra 2 utilizando el sufijo de la palabra 1 que sigue la posici√≥n actual.

As√≠ que necesitamos, para cada posici√≥n " yo " en `palabra1 " , la posici√≥n * m√°s temprana " en `palabra2 " que pueda coincidir con el sufijo `palabra1[i...] " .
Pre-computar esto es el truco que nos permite decidir en O(1) si el saltar es seguro.

-...

## üìä How the Algorithm Works

1. **Paso de vuelta ‚Äì construir `√∫ltimo[j]**
`last[j]` almacena el √≠ndice *rightmost* en `word1` que puede coincidir con `word2[j]`.
Escanear `palabra1` de derecha a izquierda; cada vez que vemos `palabra1[i] ==palabra2[j]`, establecer `√∫ltimo[j] = i` y mover `j` izquierda.

2. **Paso futuro: construcci√≥n codiciada* *
Camina `palabra1` de nuevo (izquierda ‚Üí derecha).
Mantenga dos variables:
* `j` ‚Äì posici√≥n actual en `word2`.
* `skip` - si ya hemos utilizado el que permiti√≥ el desajuste (0 o 1).

Por cada uno:
*Caso 1 ‚Äì Coincidencia directa*: `palabra1[i] == word2[j] ‚Üí tomar 'i', "j++".
- **Caso 2 - Saltar permitido** (`skip == 0`) y es *seguro* saltar `word2[j]`:
*Safe* significa que el siguiente personaje de `word2` (`word2[j+1]`) todav√≠a puede ser igualado por un √≠ndice posterior.
Esto equivale a " i " √∫ltima [j+1] " (o si `j` es el √∫ltimo √≠ndice, estamos libres de saltar).
Si la condici√≥n tiene, tome `i`, ponga `skip = 1`, `j+`.

3. * Terminaci√≥n*
Si logramos igualar a todos los `m` caracteres (`j == m`), devuelve los √≠ndices recogidos.
De lo contrario, devuelve una matriz vac√≠a.

-...

## üìê Correctness Proof Sketch

1. **Feasibilidad** ‚Äì El algoritmo s√≥lo agrega un √≠ndice si coincide con el actual `palabra2` car√°cter o es un patr√≥n seguro.
*Safe skip* garantiza que el resto de `word2` todav√≠a puede ser igualado, por lo que la cadena final ser√° casi igual a `word2`.

2. **Minicidad lexicogr√°fica** ‚Äì
* Cualquier √≠ndice elegido antes de un partido posterior ser√° m√°s peque√±o, por lo que nunca posponemos un partido que es posible.
* La √∫nica vez que posponemos es saltar un personaje.
Nos saltamos *s√≥lo cuando es seguro* y *inmediatamente* (la primera vez que un salto es posible).
Skipping later would increase the first differing index in the resulting sequence, thus violating lexicographic minimality.

3. **Unicidad de la secuencia** ‚Äì
Las opciones avaricias son forzadas: una vez que existe un partido directo debemos tomarlo; si saltamos, el conteo de salto se convierte en 1 y nunca podemos saltar de nuevo.
Por lo tanto el algoritmo produce una secuencia √∫nica que es lexicogr√°ficamente m√≠nima entre todas las secuencias v√°lidas.

-...

## üìö Complexity Analysis

Silencio Fase , tiempo , tiempo , espacio ,
Silencio--------...
‚Üê Backward pass Silencio O(n) Silencio O(m) (array `last`) Silencio
Silencio Forward pasar Silencio O(n) Silencio O(m) (result array) Silencio
Silencio **Total** Silencio **O(n + m)** Silencio **O(m)**

" n " puede ser hasta 300 000, lo que est√° bien dentro de los l√≠mites de las CPU modernas.

-...

## ‚ãÖ Common Pitfalls

¬øPor qu√© no soporta c√≥mo evitar la vida?
Silencio----------------------------
Silencio **Usando el primer partido durante el escaneo delantero** Silencio Podr√≠a estar mal si un personaje posterior puede ser saltado con seguridad antes. ‚Üê Pre-compute `√∫ltimo' y utilizarlo para comprobar la seguridad antes de saltar. Silencio
Silencio **Skipping siempre que veas un desajuste** Silencio No podr√≠a dejar √≠ndices para terminar `palabra2`. TENIDO Use el array `√∫ltimo` para garantizar que el sufijo todav√≠a contiene un partido para el sufijo restante de `palabra2`. Silencio
TEN **Counting discords incorrectly** TEN Off‚Äêpor-one errores al comprobar '√∫ltimo [j+1]` para el √∫ltimo personaje. Silencio Tratar el √∫ltimo √≠ndice especialmente: puedes saltarlo en cualquier momento porque no hay nada despu√©s de que coincida. Silencio
Silencio **Usando demasiada memoria** Silencio Robar un '√∫ltimo' conjunto de tama√±o `n` doble memoria. tenci√≥n Almacenar s√≥lo `√∫ltimo ' de tama√±o `m` (longitud del suffix), no una variedad de tama√±o `n`. Silencio

-...

## üß© Code Implementations

#### ## 1down‚É£ Java

``java
importar java.util*;

Clase Soluci√≥n {
int[] validSequence(String word1, String word2) {
int n = word1.length(), m = word2.length();
int[] last = new int[m]; // last[j] = rightmost index in word1 that match word2[j]
Arrays.fill(last, -1);

// Pase trasero
int j = m - 1;
para (int i = n - 1; i >= 0 " cl j " = 0; i--) {
(word1.charAt(i) == word2.charAt(j) {
[j] = i;
j...
}
}

// Adelante
j = 0;
int skip = 0;
int[] res = nuevo int[m];
int pos = 0; // posici√≥n en res

para (int i = 0; i)
if (word1.charAt(i) == word2.charAt(j) { // direct match
[pos++] = i;
j++;
Si no, si... 0) { // considerar la posibilidad de saltar
booleano seguro = (j == m - 1) tenci√≥n infligida (i ◊ô last[j + 1]);
si (seguro) {
[pos++] = i;
omitir = 1;
j++;
}
}
}

retorno (j == m) ? res : nuevo int[0];
}
}
`` `

#### 2down‚É£ C++

``cpp
#include ◊ôbits/stdc++.h
usando std namespace;

Clase Soluci√≥n {
public:
vector asignadoint t√≠tulo validSequence(string word1, string word2) {
int n = word1.size(), m = word2.size();
vector implicado √∫ltimo(m, -1); // posiciones m√°s correctas

// Pase trasero
int j = m - 1;
para (int i = n - 1; i >= 0 " cl j " = 0; --i) {
(word1[i] == word2[j]) {}
[j] = i;
-j;
}
}

// Adelante
vector res;
res.reserve(m);
j = 0;
int skip = 0;
para (int i = 0; i) {}
(word1[i] == word2[j]) {}
res.push_back(i);
++j;
Si no...
bool safe = (j == m - 1) tenci√≥n infligida (i ◊ô last[j + 1]);
si (seguro) {
res.push_back(i);
omitir = 1;
++j;
}
}
}

retorno (j == m) ? res : vector implicado();
}
};
`` `

#### 3down‚É£ Python

``python
Soluci√≥n de clase:
def validSequence(self, word1: str, word2: str) List[int]:
n, m = len(word1), len(word2)
* m

# Backward pass: compute rightmost matching indices
j = m - 1
para i en rango(n - 1, -1, -1):
si j >= 0 y word1[i] == word2[j]:
[j] = i
j)= 1

Pase adelante: construcci√≥n avaricia
res = []
j = 0 # √≠ndice actual en word2
skip = 0 # 0 ‚Üí ning√∫n desajuste utilizado todav√≠a

para i, ch in enumerate(word1):
si j >= m:
descanso
si ch == word2[j]:
res.append(i)
j += 1
elif skip == 0:
# safe to skip if we can still match remaining suffix
caja fuerte = (j == m - 1) o (i)
si es seguro:
res.append(i)
Salto = 1
j += 1

retorno si j == m []
`` `

Las tres soluciones utilizan la l√≥gica *same*; las √∫nicas diferencias son los detalles sint√°cticos espec√≠ficos para cada idioma.

-...

## üß© ‚ÄúBueno, malo, feo‚Äù ‚Äì Lo que este problema teme

Silencio Silencio
Silencio------------Prince------
Silencio **Dificultad** Silencio entrevista de 2 horas pregunta ‚Üê Requiere cuidadoso O(n) razonamiento tenci√≥n 300 000‚Äêchar inputs trip naive DP or recursion
Silencio **Key Insight** Silencio Un solo salto s√≥lo es posible si el resto de `palabra2 ' todav√≠a se ajusta a Silencio Olvidar pre-compute `last` conduce a O(n2) o TLE ANTE Utilizar un array DP completo (`dp[i][j]`) sopla la memoria (3¬∑1052) Silencio
Silencio ** Errores comunes** Silencio Tomar el √≠ndice de emparejamiento *primero* es incorrecto; usted debe posponer s√≥lo para *seguro* skips ANTE Saltar arbitrariamente da el resultado lexicogr√°fico equivocado ‚Üê No manejar el √∫ltimo car√°cter de `palabra2` (palabra permitida s√≥lo una vez)
Silencio **Lo que los entrevistadores aman** Silencio Tiempo lineal, memoria O(m), razonamiento avaricioso claro Silencioso Explicaci√≥n de control de seguridad v√≠a `√∫ltimo[j+1]` ‚Üê Demostrar que usted puede manejar enormes entradas sin repeticiones

-...

## üéØ How This Helps Your Job Hunt

*¬øPor qu√© dominar este tipo de problema codicioso una t√°ctica ‚Äúcareer-boost‚Äù? *

1. **Interview‚ÄêFriendly** ‚Äì Muchas entrevistas tecnol√≥gicas piden soluciones *O(n)* en problemas lineales.
Demostrar que usted puede pensar en t√©rminos de *dos pases* y *pre-computed safety* muestra que usted es c√≥modo con algoritmos de tiempo √≥ptimo.

2. **Scalability Mindset** ‚Äì
Empresas como Google, Facebook y Amazon enfatizan el manejo de tama√±os de datos en millones.
Mostrando que se puede procesar 3¬∑105 caracteres en menos de un segundo ( √ò 10 ms) se√±ales que usted escribir√° c√≥digo de producci√≥n listo.

3. **Explain‚Äêand‚ÄêDemo** ‚Äì
Cuando usted camina a trav√©s de la soluci√≥n durante una entrevista, narrar la *comprensi√≥n auditiva*, *prueba de seguridad* y *valorizaci√≥n toxicogr√°fica*.
Eso demuestra claridad del pensamiento, un talento blando apreciado en la contrataci√≥n de paneles.

-...

## üìå Quick Reference ‚Äì Paste‚ÄêReady Code Snippets

## Java

``java
int[] validSequence(String word1, String word2) {
int n = word1.length(), m = word2.length();
int[] last = new int[m];
Arrays.fill(last, -1);

// Pase trasero
int j = m - 1;
para (int i = n - 1; i >= 0 " cl j " = 0; i--) {
(word1.charAt(i) == word2.charAt(j) {
[j] = i;
j...
}
}

// Adelante
int[] res = nuevo int[m];
int idx = 0, skip = 0, j2 = 0;
para (int i = 0; i)
(word1.charAt(i) == word2.charAt(j2) {
res[idx++] = i;
j2++;
Si no, si... 0) {
booleano seguro = (j2 == m - 1) Silencioso (i ◊ô last[j2 + 1]);
si (seguro) {
res[idx++] = i;
omitir = 1;
j2++;
}
}
}
retorno (j2 == m) ? res : nuevo int[0];
}
`` `

### C++

``cpp
vector asignadoint t√≠tulo validSequence(string word1, string word2) {
int n = word1.size(), m = word2.size();
vector significado √∫ltimo(m, -1);

// Pase trasero
int j = m - 1;
para (int i = n - 1; i >= 0 " cl j " = 0; --i) {
(word1[i] == word2[j]) {}
[j] = i;
-j;
}
}

// Adelante
vector res;
res.reserve(m);
j = 0;
int skip = 0;
para (int i = 0; i) {}
(word1[i] == word2[j]) {}
res.push_back(i);
++j;
Si no...
bool safe = (j == m - 1) tenci√≥n infligida (i ◊ô last[j + 1]);
si (seguro) {
res.push_back(i);
omitir = 1;
++j;
}
}
}

retorno (j == m) ? res : vector implicado();
}
`` `

## Python

``python
def validSequence(self, word1: str, word2: str) List[int]:
n, m = len(word1), len(word2)
* m

# Backward pass
j = m - 1
para i en rango(n - 1, -1, -1):
si j >= 0 y word1[i] == word2[j]:
[j] = i
j)= 1

Adelante
[], 0, 0
para i, ch in enumerate(word1):
si j >= m:
descanso
si ch == word2[j]:
res.append(i)
j += 1
elif skip == 0:
caja fuerte = (j == m - 1) o (i)
si es seguro:
res.append(i)
Salto = 1
j += 1

retorno si j == m []
`` `

-...

## üåê TL;DR

- **Problema:** Encuentra la matriz de √≠ndices m√°s peque√±a-lexicogr√°ficos, permitiendo en la mayor√≠a de un desajuste.
- **Soluci√≥n:** Dos pases lineales, posiciones pre-computadas m√°s seguras ( ' √∫ltima ' ), y hacer un control de seguridad antes de un solo salto.
- **La complejidad: *El tiempo, la memoria.
- **Takeaway:** La docencia de patrones codiciosos aumenta el rendimiento de las entrevistas y demuestra el pensamiento de escalabilidad‚Äîesencial para cualquier funci√≥n tecnol√≥gica de alto nivel.

-...

### üîñ SEO Tags > Palabras clave (para lectores de blogs)

`# Algoritmos #Greedy #Entreview #LinearTime #TwoPassAlgorithm #ScalableCode #Java #C+ #Python #TechEntreviewTips #BigData #EntreviewPreparation `

¬°Feliz codificaci√≥n y buena suerte en tu pr√≥xima entrevista! üöÄ