-...
T√≠tulo: LeetCode 381. Insert Delete GetRandom O(1) - Duplicados permitidos -
descripci√≥n: Titular
Fecha: 2025-09-21
categor√≠as: []
autor: muses
tags: []
HideToc: verdadero
-...
## üéØ 381. Insertar Eliminar GetRandom O(1) ‚Äì Duplicados Permitidos
### Soluci√≥n de personal completo en **Java / Python / C+** + un post de blog amigable con SEO

-...

### #1# ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ##### ## ## ### ## ## ## ## #### ###### ## ##### ## ##### ####################################################################################

Necesitamos una estructura de datos que apoye las siguientes operaciones en tiempo *medio* O(1):

Silencio Operaci√≥n Silencioso Descripci√≥n
Silencio----------------------------------------
Silencio `insert(val)` ¬¶ Add `val` to the multiset. Se permiten duplicados. TENIENDO `verdad ' si `val` no estaba ya presente, de otra manera `false ' Silencio
Silencio `remove(val)` Silencio Remove one occurrence of `val` if it exists. TENIDO `verdad ' si la remoci√≥n tuvo √©xito, de lo contrario `false ' Silencio
Silencioso `getRandom()` Vuelva un elemento aleatorio. La probabilidad de cada elemento es proporcional a su frecuencia en el multiset. ‚Üê Un entero al azar

‚ñ† **Constraints**
‚â§ 231 - 1
‚â§ 2 √ó 105 operaciones totales
* `getRandom()` nunca se llama a una colecci√≥n vac√≠a

-...

#### 2down‚É£ Core Idea ‚Äì ‚ÄúIndex‚ÄêBased HashMap + Dynamic Array‚Äù

1. **Direcci√≥n Din√°mica** (`ArrayList` / `vector` / `list`) mantiene cada elemento insertado.
* Acceso aleatorio (`O(1)`) ‚Üí perfecto para `getRandom()`.
* El √∫ltimo elemento se puede eliminar en `O(1)` intercambiando con la posici√≥n que queremos eliminar.

2. **HashMap** (`Mapa realizadaInteger, Set GarantizadoInteger confianza`) mapas un valor ‚Üí *all* √≠ndices donde ese valor ocurre en el array.
* Nos permite localizar r√°pidamente una ocurrencia arbitraria de `val`.
* El conjunto puede ser un `HashSet`, `LinkedHashSet`, o `unordered_set` (C++).

3. ** Eliminaci√≥n**:
* Escoge un √≠ndice arbitrario `i` del conjunto de `val`.
* Reemplace `array[i]` with the last element `last`.
* Actualizar los conjuntos para 'val' y '√∫ltimo'.
* Retire el √∫ltimo elemento del array.

Todas las operaciones son **amortized O(1)** ‚Äì las operaciones establecidas y las operaciones vectoriales son O(1) en promedio.

-...

#### 3down‚É£ C√≥digo

‚ñ† **Las tres implementaciones siguen la misma l√≥gica** ‚Äì s√≥lo cambios de sintaxis.

-...

##### 3.1 Java

``java
importar java.util*;

clase p√∫blica Collecci√≥n aleatoria {}
// Almacena todos los elementos
final privado datos;
// Valor de mapas - conjunto de √≠ndices donde el valor ocurre
Mapa final privado realizadoInteger, Establecer los √≠ndices Integer t√≠tulo
final privado Random rand;

public RandomizedCollection() {}
datos = nuevo ArrayList seleccionado();
indices = nuevo HashMap fiel();
rand = nuevo Random();
}

* Inserta un valor a la colecci√≥n. */
public boolean insert(int val) {
// ¬øLa primera vez que vemos Val?
booleano es nuevo = !indices.containsKey(val);
indices.computeIfAbsent(val, k - t√≠tulo new HashSet correctamente()).add(data.size());
data.add(val);
El regreso es nuevo;
}

* Elimina un valor de la colecci√≥n. */
public boolean remove(int val) {
Establecer:Integer t√≠tulo idxSet = indices.get(val);
si (idxSet == null ‚Üê idxSet.isEmpty()) retornan falsos;

// Agarra un √≠ndice arbitrario del valor para eliminar
int removeIdx = idxSet.iterator().next();
idxSet.remove(removeIdx);

int lastIdx = data.size() - 1;
int lastVal = data.get(lastIdx);

// Mueva el √∫ltimo elemento en el punto del elemento eliminado
data.set(removeIdx, √∫ltimoVal);
// Actualizar el √≠ndice establecido para el √∫ltimo Val
Establecer:Integer confianza lastIdxSet = indices.get(lastVal);
lastIdxSet.remove(lastIdx);
lastIdxSet.add(removeIdx);

// Eliminar el √∫ltimo elemento de la lista
data.remove(lastIdx);

// Limpiar mapa si no quedan m√°s √≠ndices
si (idxSet.isEmpty()) indices.remove(val);
retorno verdadero;
}

* Obtenga un elemento aleatorio de la colecci√≥n. */
public int getRandom() {}
data.get(rand.nextInt(data.size()));
}
}
`` `

-...

###### 3.2 Python

``python
importaci√≥n al azar
de las colecciones importadas por defecto

clase RandomizedCollection:
def __init__(self):
self.data = [] # lista de todos los valores
auto.indices = defaultdict(set) # val - t√≠tulo de posiciones

def insert(self, val: int) - t√≠tulo Bool:
is_new = val no en uno mismo. √≠ndices
auto.indices[val].add(len(self.data))
self.data.append(val)
El regreso es nuevo

def remove(self, val: int) - t√≠tulo Bool:
si Val no en s√≠ mismo. √≠ndices o no auto.indices[val]:
Retorno Falso

remove_idx = self.indices[val].pop()
last_idx = len(self.data) - 1
last_val = self.data[last_idx]

# Reemplazar el punto eliminado con el √∫ltimo elemento
self.data[remove_idx] = last_val
auto.indices[last_val].add(remove_idx)
auto.indices[last_val].discard(last_idx)

self.data.pop()

si no auto.indices[val]:
del self.indices[val]
Retorno

def getRandom(self) - Propiedad int:
volver al azar.choice(self.data)
`` `

-...

#### 3.3 C++ (GNU+17)

``cpp
Incluido el t√≠tulo
#include ‚ñ†unordered_map Conf
#include ‚ñ†unordered_set
#Incluye #

clase aleatoria Colecci√≥n {}
public:
RandomizedCollection() : gen(rd()), dis(0, 0) {}

bool insert(int val) {
bool isNew = mp.find(val) == mp.end();
mp[val].insert(data.size());
data.push_back(val);
El regreso es nuevo;
}

bool remove(int val) {
auto = mp.find(val);
si (it == mp.end() TENIDO SUPERVISI√ìN-Consejo.empty()) retornan falsos;

// √≠ndice para eliminar
int idx = *it- convienesecond.begin();
it- t√≠tulo.erase(idx);

int lastVal = data.back();
int lastIdx = data.size() - 1;

// Mueva el √∫ltimo elemento en idx
data[idx] = last Val;
mp[lastVal].insert(idx);
mp[lastVal].erase(lastIdx);

data.pop_back();

si (es decir, segundo.empty()) mp.erase(it);
retorno verdadero;
}

int getRandom() {}
dis = std::uniform_int_distribuci√≥n obtenidaint(0, data.size() - 1);
datos de devoluci√≥n [dis(gen)];
}

privado:
std::vector obtenidosint datos del usuario;
std::unordered_map armonizado, std::unordered_set mp;
std::random_device rd;
std::mt19937 gen;
std::uniform_int_distribuci√≥n hechaint dis;
};
`` `

-...

### 4 comentarios ‚É£ Blog Art√≠culo ‚Äì ‚ÄúEl Bien, el Mal, el Ugly of RandomizedCollection‚Äù

‚ñ† **SEO Palabras clave**: `LeetCode 381`, `RandomizedCollection`, `O(1) insert delete random`, `multiset data structure`, `hashmap vector trick`, `duplicate elements`, `data structures interview`, `python c+ java`, `job interview coding `

-...

##### 4.1 Introducci√≥n

Cuando los reclutadores piden ‚Äúejecutar una estructura de datos que soporta insertar, eliminar y getRandom en tiempo constante‚Äù, no solo est√°n probando su conocimiento de arrays o tablas de hash ‚Äì est√°n probando su capacidad para **combine** estructuras de datos creativamente.
LeetCode 381 ‚Äì *Inserto Eliminar GetRandom O(1) ‚Äì Duplicados permitidos* es un cl√°sico favorito de entrevista que muestra este conjunto de habilidades exactas.

En este art√≠culo vamos a diseccionar el **bueno**, el **bad**, y el **ugly** de resolver este problema. Ya sea que se est√© preparando para una entrevista de codificaci√≥n, mirando a su pr√≥ximo papel, o simplemente agudizando su caja de herramientas algor√≠tmica, esta gu√≠a le dar√° ideas accionables y fragmentos de c√≥digo en Java, Python y C++.

-...

#### 4.2 The Good: Why the HashMap‚ÄêVector Trick is a Game‚ÄêChanger

1. **Simplicity + Power** ‚Äì
*Un array para acceso aleatorio, un hashmap para contabilidad de √≠ndice* ‚Äì toda la soluci√≥n encaja en menos de 100 l√≠neas de c√≥digo.
* Cada operaci√≥n es *amortizada* O(1) ‚Äì perfecta para preguntas de entrevista de alto volumen.

2. **Robustness with Duplicates** ‚Äì
El hashmap almacena *sets* de √≠ndices, para que puedas rastrear f√°cilmente cu√°ntas copias de un valor existen.
Esto elimina la necesidad de listas vinculadas o √°rboles que pueden degradar a O(log n).

3. **Patr√≥n de lengua agn√≥stica** ‚Äì
La misma l√≥gica se traduce en Java ( " ArrayList + HashMap cumplimentado " ), Python ( "list + defaultdict(set) " ) y C++ ( " vencedor + unordered_map " ).
La habilidad demostrante en varios idiomas puede ser un fuerte diferenciador en funciones *full‚Äêstack* o *backend*.

-...

#### 4.3 The Bad: Hidden Pitfalls That Trip Candidatos

Silencio Pitfall Silencio Lo que pasa es c√≥mo evitarlo
Silencio----------------------------
Silencio **O(n) en el peor de los casos** Silencio Usar una lista y un conjunto que rehashes frecuentemente puede causar un pico de tiempo lineal. Silencio Rely on `HashSet`/`unordered_set` ‚Äì they‚Äôre O(1) amortized, not worst‚Äêcase. Silencio
TEN **Off‚Äêby‚ÄêOne errors** TEN Wrong index update during swap (forgetting to update the set for the moved element). tenci√≥n Escribe un m√©todo de ayudador `swapAndUpdate(int i, int lastIdx)` o comenta meticulosamente. Silencio
Silencio **Memoria fuga en Java** Silencio No quitar la llave del mapa cuando su conjunto se vuelve vac√≠o ‚Üí O(n) espacio. ‚Üê Limpiar con "si (set.isEmpty()) indices.remove(val);`. Silencio
Silencio **Iniciaci√≥n del generador de comandos** Silencio En C++ crear la distribuci√≥n en cada llamada puede ser caro. Silencio Mantenga vivo un generador::mt19937` y s√≥lo reconstruya la distribuci√≥n cuando el tama√±o cambie. Silencio
Silencio **Python `defaultdict` misuse** Silencio Guardando accidentalmente conjuntos vac√≠os que mantienen la clave viva. TENIDOS Eliminar la llave cuando el conjunto se vac√≠a (`del auto.indices[val]`). Silencio

-...

#### 4.4 The Ugly: Edge Cases & Debugging Tricks

1. **Swap‚Äêand‚ÄêRemove Bug**
* Error com√∫n*: olvidando eliminar el √∫ltimo √≠ndice del conjunto del valor movido.
**Debug tip**: despu√©s de cada `remove()`, imprime el hashmap para el valor eliminado y el √∫ltimo valor para asegurar que los conjuntos sean consistentes.

2. **Empty Collection on `getRandom()**
El problema garantiza que esto no suceder√°, pero la codificaci√≥n defensiva paga en APIs del mundo real.
``java
si (data.isEmpty()) lanzar nuevo NoSuchElementException();
`` `

3. *Los n√∫meros principales*
Al usar arrays, los valores negativos no importan ‚Äì son s√≥lo claves en el hashmap.
Pero en C++ `unordered_map observadoint, ... `` est√° bien; s√≥lo tenga cuidado con `size_t` vs `int` conversiones.

4. *Mareos*
Algunos entrevistadores prueban la verdadera uniformidad. Use un *sistema RNG* (`Random` en Java, `random.choice` en Python, `mt19937` en C++) y **re-seed** si est√° escribiendo un servicio de larga duraci√≥n.

-...

#### 4.5 How This Wins Interviewers

* **Showcases Data‚ÄêStructure Fusion** ‚Äì Combinar array y hashmap es un sello distintivo de la ingenier√≠a inteligente.
* **Highlights Edge‚ÄêCase Handling** ‚Äì Duplicados, eliminaciones de valores perdidos y l√≥gica de limpieza demuestran la atenci√≥n al detalle.
* **Demonstrates Language Proficiency** ‚Äì Proporcionar soluciones Java, Python y C++ muestra que est√°s listo para cualquier pila.
* **Habla a Real‚ÄêWorld Use** ‚Äì `RandomizedCollection` es esencialmente un *multiset* con muestreo aleatorio r√°pido ‚Äì un patr√≥n utilizado en caches, balanceadores de carga y motores de juego.

-...

#### 4.6 Quick Checklist Antes de la entrevista

Silencio TENIDO ANTERIOR ANTERIOR
Silencio...
Silencio **Entender el problema** ‚Äì se permiten duplicados. Silencio
Silencio **Conoce las estructuras de datos** ‚Äì matriz din√°mica + hashmap de conjuntos de √≠ndices. Silencio
TEN **Planea el borrador** ‚Äì intercambia con el √∫ltimo elemento, actualiza √≠ndices. Silencio
Silencio ** Funciones de ayuda de palabras** ‚Äì para mantener el c√≥digo legible. Silencio
Silencio **M√°s a fondo** ‚Äì insertar, eliminar, getRandom, casos de borde. Silencio
*Explicar su dise√±o* ‚Äì grande‚Äì O, por qu√© utilizamos un conjunto, por qu√© es tiempo constante. Silencio
Silencio **Mention trade‚Äêoffs** ‚Äì memoria overhead, potencial peor-case, espec√≠fico del lenguaje. Silencio

-...

#### 4.7 Palabras finales

LeetCode 381 puede parecer enga√±osamente simple, pero es una prueba *code-generaci√≥n* de comprensi√≥n profunda.
El **bueno** es la elegancia del patr√≥n array-hashmap.
El **bad** es los errores sutiles que se esconden en la l√≥gica del swap‚Äêand-remove.
El **ugly** es los casos de borde que viajan incluso programadores experimentados.

Mostrando una implementaci√≥n limpia y bien comunicada ‚Äì como hemos hecho anteriormente ‚Äì te permitir√° entrar en la habitaci√≥n de un reclutador y decir:
‚ñ† ‚ÄúPuedo construir un **multiset** que se comporta como una bolsa y todav√≠a elegir un art√≠culo aleatorio en O(1) ‚Äì todo en Java, Python y C++. ‚Äù

¬°Buena suerte aterrizando ese trabajo! üöÄ

-...

‚ñ† *Si has encontrado este art√≠culo √∫til, dale un üëç, comp√°rtelo en LinkedIn, o deja un comentario abajo ‚Äì vamos a ayudar a la pr√≥xima generaci√≥n de ingenieros a romper LeetCode 381 y aterrizar sus roles de sue√±o. *

-...

‚ñ† *Copyright ¬© 2023 ‚ÄúCoding Interviews Demystified‚Äù ‚Äì Todos los derechos reservados. *

-...

### üìö Referencias > Leer m√°s

1. [LeetCode 381 ‚Äì Insert Delete GetRandom O(1) ‚Äì Duplicates allowed](https://leetcode.com/problems/insert-delete-getrandom-o1-duplicates-allowed/)
2. [GeeksforGeeks ‚Äì Randomized Set " Multiset](https://www.geeksforgeeks.org/design-a-data-structure-that-supports-insert-delete-getrandom-in-constant-time/)
3. [EntreviewBit ‚Äì Constant Time Operations](https://www.interviewbit.com/question/insert-delete-get-random-o1/)

-...

¬°Feliz codificaci√≥n! üíªüî•