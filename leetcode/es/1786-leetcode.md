-...
T√≠tulo: LeetCode 1786. N√∫mero de caminos restringidos del primero al √∫ltimo nodo -
descripci√≥n: Titular
Fecha: 2025-09-21
categor√≠as: []
autor: muses
tags: []
HideToc: verdadero
-...
# 1786. N√∫mero de caminos restringidos del primer a √∫ltimo nodo
*(Medium ‚Äì LeetCode)*

‚ñ† ** Resumen del programa* *
‚ñ† Se le da un gr√°fico no dirigido, ponderado, conectado con *n* nodos (1-basado).
‚ñ† Por cada nodo *x* que `dist(x)` sea la distancia m√°s corta de *x* a nodo *n*.
‚ñ† Un camino restringido ** del nodo 1 al nodo *n* es un camino
" [z0, z1, ... , zk] " , donde `z0 = 1 ' , `zk = n ' , y por cada ` i `
" dist(zi) " (la distancia al √∫ltimo nodo disminuye estrictamente).
‚ñ† Contar todos estos caminos modulo `1 000 000 007`.

-...

## ‚Üë Key Insight

1. **Las distancias m√°s cortas del objetivo** ‚Äì Run Dijkstra desde el nodo *n*.
2. **Graph se convierte en DAG** ‚Äì Por cada borde `(u,v)` s√≥lo la direcci√≥n 'u ‚Üí v` con
`dist(u) ‚àö‚â• dist(v)` puede aparecer en un camino restringido.
3. **DP on the DAG** ‚Äì `ways[u] = Governing ways[v]` over all outgoing restricted edges.
4. Resultado**: "Siempre[1]".

El algoritmo funciona en la memoria `O(n+m) log n)` tiempo y `O(n+m).



-...

## üì¶ Code Solutions

A continuaci√≥n se presentan implementaciones idiom√°ticas limpias en **Java, Python y C+**.

## Java 17

``java
importar java.util*;

*
* LeetCode 1786 ‚Äì N√∫mero de caminos restringidos
*/
Soluci√≥n de la clase p√∫blica {}
int final est√°tico privado MOD = 1_000_000_007;

int countRestrictedPaths(int n, int[] edges) {
// 1 / ‚É£ Build adjacency list
Lista realizadaLista realizada[] t√≠tulo g = nuevo ArrayList recomendado(n + 1);
para (int i = 0; i <= n; i++) g.add (new ArrayList fiel());
para (int[] e : bordes) {
int u = e[0], v = e[1], w = e[2];
g.get(u).add(new int[]{v, w});
g.get(v).add(new int[]{u, w});
}

Dijkstra desde el nodo n
long[] dist = new long[n + 1];
Arrays.fill(dist, Long.MAX_VALUE);
dist[n] = 0;
PriorityQueue hac√≠a lo largo[] conf√≠a pq = nueva PrioridadQueue decir:(Comparador.comparingLong(a - t√≠tulo a[1]));
pq.offer(new long[]{n, 0});

mientras (pq.isEmpty()) {
long[] cur = pq.poll();
int u = (int) cur[0];
largo d = cur[1];
si (d != dist[u]) contin√∫an;
para (int[] nb : g.get(u) {
int v = nb[0], w = nb[1];
largo nd = d + w;
si {}
dist[v] = nd;
pq.offer(nuevo largo []{v, nd});
}
}
}

DP (memoized DFS) en el DAG
long[] dp = new long[n + 1];
Arrays.fill(dp, -1);
dfs(1, n, g, dist, dp);
}

dfs privados largos(int u, int n, Lista hecha g,
largo[] dist, long[] dp) {
si (u == n) retorno 1;
si (dp[u]!= -1) retorno dp[u];
ans largas = 0;
para (int[] nb : g.get(u) {
int v = nb[0];
si (dist[u]
as = (ans + dfs(v, n, g, dist, dp) % MOD;
}
}
dp[u] = ans;
devolver los ans;
}
}
`` `

## Python 3

``python
importaci√≥n heapq
de la importaci√≥n Lista

MOD = 1_000_000_007

Soluci√≥n de clase:
def countRestricted Paths(self, n: int, edges: List[List[int]]) int:
# 1 Construir la lista de adjacency
g = [[] para _ en rango(n +1)]
para u, v, w en los bordes:
g[u].append(v, w))
g[v].append(u, w))

# 2Ô∏è Dijkstra from node n
(n +1)
dist[n] = 0
pq = [(0, n)] # (dist, node)
mientras pq:
d, u = heapq.heappop(pq)
si d != dist[u]:
continuar
for v, w in g[u]:
d + w
si nd , se hizo [v]:
[v] = nd
heapq.heappush(pq, (nd, v))

DP on DAG (topological order by dist)
orden = orden(range(1, n + 1), key=lambda x: dist[x])
dp = [0] * (n +1)
dp[n] = 1
para u en orden:
for v, _ in g[u]:
si dist[u]
dp[u] = (dp[u] + dp[v] % MOD

retorno dp[1]
`` `

### C+17

``cpp
#include ◊ôbits/stdc++.h
usando std namespace;

Clase Soluci√≥n {
static const int MOD = 1'000'007;
public:
int countRestrictedPaths(int n, vector obtenidosvector fieltros iguales bordes) {}
Lista de adyacencia
vector realizador obtenidospair obtenidosint,int hilo conductor g(n + 1);
para (auto &e : bordes) {}
int u = e[0], v = e[1], w = e[2];
g[u].push_back({v, w});
g[v].push_back({u, w});
}

Dijkstra desde el nodo n
vector llevado a cabo largo plazo dist(n + 1, LLONG_MAX);
dist[n] = 0;
priority_queue hicistepair realizado largo,int
vector asignadopair llevado largo largo,int.
mayor significadopair realizado largo,int pq;
pq.push({0, n});
mientras (pq.empty()) {
auto [d, u] = pq.top(); pq.pop();
si (d != dist[u]) contin√∫an;
para (auto [v, w] : g[u]) {}
largo largo nd = d + w;
si {}
dist[v] = nd;
pq.push({nd, v});
}
}
}

DP on DAG (topological by dist)
vector de orden(n)
iota(order.begin(), order.end(), 1);
sort(order.begin(), order.end(),
[](int a, int b){ return dist[a] [a] [b]; });

vector asignadointento dp(n + 1, 0);
dp[n] = 1;
para (int u : order) {
para (auto [v, w] : g[u]) {}
si {}
dp[u] = (dp[u] + dp[v]) % MOD;
}
}
}
dp[1];
}
};
`` `

Las tres soluciones comparten el mismo tiempo y la complejidad espacial:

- **Tiempo**: `O(n + m) log n)` (Dijkstra domina).
- **Espacio**: `O(n + m)` (lista de asistencia + array de distancia + matriz DP).

-...

Blog Art√≠culo
*(SEO-optimizada ‚Äì ‚ÄúLeetCode 1786, caminos restringidos, gr√°fico, entrevista‚Äù) *

### Title
**Mastering LeetCode 1786: N√∫mero de caminos restringidos ‚Äì De la Teor√≠a Gr√°fico a Job‚ÄêLey Entrevista Prep* *

## Meta Descripci√≥n
‚ÄúAprenda la soluci√≥n completa para LeetCode 1786 ‚Äì caminos restringidos. Sum√©rgete en Dijkstra, DP en DAG y Java, Python, c√≥digo C++. Boost your coding interview scores and land your dream job. ‚Äù

##### Outline

TENCI√ìN TERRITORIO ANTERIOR ANTERIOR
Silencio...
Silencio 1. Sinopsis del problema tenci√≥n Definici√≥n, limitaciones, ejemplos. Silencio
Silencio 2. Intuici√≥n Silencio Por qu√© funciona Dijkstra + DP. Silencio
Silencio 3. Restricted Edge Direction Silencio Show how `dist(u) ‚àö‚â• dist(v)` convierte el gr√°fico en un DAG. Silencio
Silencio 4. Casos de bordes " Pitfalls " tenci√≥n Cero-pesos bordes, distancias iguales, m√∫ltiples caminos m√°s cortos. Silencio
Silencio 5. Algorithm ‚Üê Paso a paso con diagramas. Silencio
Silencio 6. Detalles de la implementaci√≥n Silenciosos C√≥digos, estructuras de datos, memoizaci√≥n. Silencio
Silencio 7. An√°lisis de Complejidad ‚Üê Big‚ÄêO, por qu√© es √≥ptimo. Silencio
Silencio 8. Bien / mal / Ugly ‚Üê Qu√© celebrar, qu√© evitar, los obst√°culos del mundo real. Silencio
Silencio 9. Entrevista com√∫n Variantes Silenciosos ‚ÄúPatinas con reducci√≥n no limitada‚Äù, ‚ÄúAgregar pesos nodos‚Äù, ‚ÄúVersi√≥n sin ponderar‚Äù. Silencio
Silencio 10. C√≥mo utilizar en las entrevistas ‚Üê Temas de conversaci√≥n, por qu√© el entrevistador lo ama. Silencio
Silencio 11. Recursos de pr√°ctica ‚Üê M√°s preguntas de gr√°fico LeetCode, libros, cursos en l√≠nea. Silencio
Silencio 12. Conclusi√≥n Silencioso, aliento. Silencio

Texto completo

-...

##### 1. Panorama general de los problemas

El problema *N√∫mero de Senderos Restrictos* se encuentra en la intersecci√≥n de algoritmos de gr√°ficos **shortest‚Äêpath** y ** programaci√≥n dinamica**.
Dado un gr√°fico no dirigido ponderado, un camino est√° ‚Äúrestricto‚Äù si el *distance to the destination* disminuye estrictamente a cada paso.
Debemos contar todos estos caminos del nodo 1 al nodo *n*.

Las limitaciones son generosas:
- 2 ‚â§ 20.000
- 1 ‚â§ bordes. longitud ‚â§ 200.000
- `1 ‚â§ peso ‚â§ 106 `
- El gr√°fico est√° garantizado para estar conectado.

Estos l√≠mites hacen **O(n+m) log n)** el lugar dulce ‚Äì cualquier cosa m√°s lenta es un punto muerto en una entrevista.

-...

##### 2. Intuici√≥n

1. **La distancia m√°s corta del objetivo** ‚Äì Piense en 'dist(x)` como un "mapa de la altura" del gr√°fico. Nodo *n* es el nivel del mar (distancia 0).
2. **Los caminos restringidos deben ir cuesta abajo** ‚Äì Debido a que se requiere `dist(zi) ≈ì dist(zi+1)`, cada paso debe descender estrictamente este mapa de altura.
3. **Los edges apuntan cuesta abajo s√≥lo** ‚Äì Para cualquier borde no redirigido `(u,v)`, s√≥lo la direcci√≥n donde el comienzo es m√°s alto que el extremo puede ser utilizado.
4. **El gr√°fico se convierte en un Gr√°fico Ac√≠clico Directo (DAG)** ‚Äì Ning√∫n ciclo puede existir porque las alturas disminuyen estrictamente.
5. ** Programaci√≥n Din√°mica en el DAG** ‚Äì Contar maneras de alcanzar el fregadero de cada nodo.

‚ñ† **Key takeaway**: *Short‚Äêest-distance ‚Üí DAG ‚Üí DP. *

-...

##### 3. Casos de borde " Cascadas comunes

Escenario Silencioso Por qu√© importa
Silencio...
Silencio M√∫ltiples bordes entre el mismo par Silencio Dijkstra debe considerar el peso m√°s peque√±o tenci√≥n Uso lista de adyacencia; mantener todos los bordes. Silencio
TENIENDO `dist(u)` y `dist(v)` Silencio No pueden ser parte de una senda restringida TENIDO Saltar tales bordes en DP. Silencio
Los bordes de peso cero Silencio Dijkstra todav√≠a funciona (los pesos positivos est√°n bien) Silencio Uso `long' para distancias. Silencio
Silencio Gran respuesta ‚Äì necesidad modulo tenci√≥n Prevent overflow tenci√≥n Siempre mod despu√©s de cada adici√≥n. Silencio

-...

##### 4. Algoritm detallado

1. **Run Dijkstra de nodo *n***
- Complejidad: `O(n+m) log n) `
- Almacene `dist[1...n]` (long/64‚Äêbit para evitar el desbordamiento).

2. **Build the DAG**
- Por cada borde no dirigido `(u,v,w)`:
* If `dist[u] ‚á© dist[v] ‚Üí a√±adir borde dirigido `u ‚Üí v`*
* If `dist[v] ‚á© dist[u] ‚Üí a√±adir borde dirigido `v ‚Üí u`*
*Si `dist[u] == dist[v]` ‚Üí ning√∫n borde dirigido (no se puede utilizar). *

3. **DP on the DAG**
- `ways[n] = 1`.
- Nodos de proceso en orden ascendente de `dist`** (orden totol√≥gico).
- Por nodo `u`:
`ways[u] = Governing ways[v]` sobre todos los bordes restringidos salientes.
- Regresa por ah√≠.

El DAG asegura que cuando procesamos un nodo, todos los nodos que se√±ala que ya han sido procesados.

-...

##### 5. Producci√≥n C√≥digo listo (Java, Python, C++)

(Ver la secci√≥n del c√≥digo anterior ‚Äì copy‚Äêpaste listo, completamente comentado, y testado de batalla).

‚ñ† *Tip for interviewers*: Mostrar la l√≥gica primero, luego presentar el c√≥digo esqueleto. Muestra tanto la comprensi√≥n como la aplicaci√≥n limpia.

-...

##### 6. An√°lisis de la complejidad

Silencio Silencio
Silencio...
Silencio Dijkstra Silencioso `O(n+m) log n)` Silencio
Silencioso Edificio DAG Silencioso `O(m)` Silencio
Silencio DP traversal Silencioso `O(n+m)` Silencio
tenci√≥n **Total** Silencioso `O(n+m) log n)` tiempo, `O(n+m)` memoria Silencio

Para `n = 20 000` y `m = 200 000`, esto encaja c√≥modamente en los l√≠mites de tiempo de LeetCode y cualquier plataforma de entrevista.

-...

##### 7. Bien / mal / Ugly

Silencio Lo que es bueno para vivir mal para siempre
Silencio------------Prince------
Silencio **Bueno** Silencio ‚Ä¢ Separaci√≥n clara de las preocupaciones (Dijkstra + DP). Reutilizaci√≥n de la lista de adyacency para ambos pases.
TEN **Bad** Silencio ‚Ä¢ La profundidad de la recuperaci√≥n puede alcanzar los l√≠mites de recursi√≥n en Python. TEN ‚Ä¢ Usar DP iterativo o aumentar la pila de recursi√≥n.
Silencio **Ugly** Silencio ‚Ä¢ Algunas soluciones intentan realizar DFS sin memoizaci√≥n en el DAG, lo que lleva a tiempo exponencial. Silencio ‚Ä¢ Evitar. Silencio ‚Ä¢ Pre-computar un orden topol√≥gico clasificando `dist` es simple y evita el flujo de la pila de recursi√≥n. Silencio

-...

##### 8. Variaciones " Extensiones

Silencioso Variaci√≥n Silencioso C√≥mo adaptarse
Silencio--------------
Silencioso *Pasajes en los que `dist(zi) >= dist(zi+1)`* Silencio Eliminar la desigualdad estricta; todav√≠a un DAG. Silencio
tenci√≥n *La gracia se dirige originalmente* Silencio Mantener los bordes dirigidos que satisfacen la desigualdad. Silencio
*Los pesos pueden ser negativos pero no ciclos negativos* Silencio Dijkstra ya no funciona; use Bellman‚ÄêFord ford for `dist`. La complejidad se convierte en `O(nm)`. Silencio
Silencio *Large `n` hasta 105, `m` hasta 5¬∑105* TENIDO El mismo algoritmo funciona; use r√°pido I/O en C++/Java.

-...

##### 9. Estrategia de entrevistas

1. **Clarificar el requisito de ‚Äúdisminuci√≥n limitada‚Äù** ‚Äì Algunos candidatos lo malinterpretan como ‚Äúno creciente. ‚Äù
2. **Explicar la formaci√≥n de DAG** ‚Äì Visualizar el mapa de altura.
3. **La complejidad del tiempo de meditaci√≥n frente a frente** ‚Äì Mostrar que has considerado los l√≠mites.
4. **Discuss memoization vs. topological DP** ‚Äì Highlight trade‚Äêoffs.
5. **Hablar sobre aritm√©tica modular** ‚Äì Muchos entrevistadores prueban errores por uno en el manejo del modulo.

-...

##### 10. Recursos pr√°cticos

- **LeetCode**: 1786 ‚Äì caminos restringidos, 1785 ‚Äì N√∫mero de caminos buenos, 1237 ‚Äì Conde Sub Islas.
- **Libros**: *‚ÄúElementos de las entrevistas de programaci√≥n ‚Äì Gr√°fico‚Äù*, *‚ÄúIntroducci√≥n a Algoritmos (CLRS) ‚Äì Senderos m√°s cortos‚Äù*.
- **Cortes**: *‚Äú Algoritmos Gr√°fico‚Äù* en Coursera, *‚ÄúProgramaci√≥n Din√°mica‚Äù* en Udemy.
LeetCode Gym, Interviewing.io, Pramp.

-...

##### üéØ Final Take‚Äêaway

‚ñ† *‚ÄúLa mejor manera de asar un problema de gr√°fico LeetCode es dividirlo en un subproblema cl√°sico de corto camino seguido por un DP DAG.‚Äù*

Con los fragmentos de c√≥digo arriba, usted puede:

- **Explicar la soluci√≥n claramente** durante una entrevista de codificaci√≥n en vivo.
- **Demonstrate production‚Äêready knowledge** presentando c√≥digo limpio, bien comunicado en Java, Python, o C++.
- **Mostrar profundidad de comprensi√≥n** discutiendo casos de borde, complejidad y estrategias de entrevista.

Buena suerte ‚Äì est√°s un paso m√°s cerca de aterrizar ese *sue√±o trabajo*! üöÄ

-...

### üìå SEO Tags

`LeetCode 1786`, `N√∫mero de caminos restringidos ' , ` algoritmo gr√°fico ' , `Dijkstra ' , `programaci√≥n dinamica ' , `entrevista de codificaci√≥n ' , `entrevista de ingenieros de software ' , ` Soluci√≥n de Palestina ' , `Convenci√≥n de entrevista ' , ' .