-...
T√≠tulo: LeetCode 2092. Encontrar a todas las personas con secreto -
descripci√≥n: Titular
Fecha: 2025-09-21
categor√≠as: []
autor: muses
tags: []
HideToc: verdadero
-...
## üéØ 2092 ‚Äì Find All People With Secret
## Solution in **Java**, **Python**, y **C+** (Union‚ÄêFind + Batching de tiempo)
-...

#### TL;DR
El secreto se extiende s√≥lo ** en la hora exacta de una reuni√≥n**.
Si varias reuniones suceden al mismo tiempo, todos los que ya tienen el secreto pueden transmitirlo instant√°neamente a ** todos los participantes** de ese *time-batch*.
El problema se puede resolver en **O(n + m log m)** tiempo y **O(n + m)** memoria por:

1. **Sorting** reuniones a tiempo.
2. **Procesamiento** cada una de las sesiones juntas utilizando un **Union‚ÄêFind Union (DSU)** (Union‚ÄêFind).
3. Al final, todos los nodos cuyo representante es `0` (persona 0) conocen el secreto.

El ESD se reinicia despu√©s de cada lote para que las personas que hicieron **no** reciban el secreto durante ese tiempo sean aisladas de nuevo.

-...

## 1down Java Implementation

``java
importar java.util*;

Soluci√≥n de la clase p√∫blica {}
// -------- Disjoint Set Union...--------
DSU de clase privada {}
int[] parent, rank;
DSU(int n) {
padre = nuevo int[n];
rango = nuevo int[n];
para (int i = 0; i)
}
int find(int x) {
(parent[x] != x) parent[x] = find(parent[x]);
devolver padre[x];
}
uni√≥n de vac√≠o(int a, int b) {}
int pa = find(a), pb = find(b);
si (pa == pb) regresa;
[pa] = pb;
[pb] = pa;
[pb] = pa; rank[pa]++; }
}
}

public List (0)Integer confianza findAllPeople(int n, int[] meetings, int firstPerson) {}
Clasificar por el tiempo
Arrays.sort(meetings, Comparator.comparingInt(a - t√≠tulo a[2]));

DSU dsu = nuevo DSU(n);
dsu.union(0, firstPerson); // persona 0 da el secreto a la vez 0

int i = 0, m = meetings.length;
mientras (i
int curTime = meetings[i][2];
// mantener a todos los participantes de esta sesi√≥n de tiempo
Lista de los participantes del t√≠tulo = nuevo ArrayList implicado();

// 2Ô∏è Uni√≥n todos los que se re√∫nen en este momento
mientras (i ◊ô m ' reuniones[i][2] == curTime) {
int a = meetings[i][0];
int b = meetings[i][1];
dsu.union(a, b);
a);
a) Participantes.add b);
i++;
}

// 3Ô∏è Reset DSU para personas que no recibieron el secreto
para (int p : participantes) {}
si (dsu.find(p) != dsu.find(0)
dsu.parent[p] = p; // isolated again
}
}

// 4down Recoger a todos los que est√°n conectados a 0
Lista de datos:Integer confianza res = nuevo ArrayList correctamente();
para (int i1 = 0; i1 = n; i1++)
si (dsu.find(i1) == dsu.find(0))) res.add(i1);

restituci√≥n;
}
}
`` `

**La complejidad* *
- `O(n + m) log m) ' time (sorting dominates)
- `O(n + m)` memoria (DSU + matriz de reuniones)

-...

## 2down‚É£ Python Implementation

``python
de las colecciones importadas por defecto
importadores
sys.setrecursionlimit(1

clase DSU:
def __init__(self, n):
self.par = list(range(n))
* n

def find(self, x):
si auto.par[x]!= x:
self.par[x] = self.find(self.par[x])
volver a s√≠ mismo.par[x]

def union(self, a, b):
pa, pb = self.find(a), self.find(b)
si pa == pb: retorno
si auto.rnk[pa] se auto.rnk[pb]:
self.par[pa] = pb
elif self.rnk[pb] se hizo auto.rnk[pa]:
self.par[pb] = pa
m√°s:
self.par[pb] = pa
self.rnk[pa] += 1

def findAllPeople(n: int, meetings: list[list[int], firstPerson: int) - ratio[int]:
meetings.sort(key=lambda x: x[2]) # sort by time
dsu = DSU(n)
dsu.union(0, firstPerson) # transferencia secreta inicial

I = 0
mientras que yo hice el len(meetings):
cur_time = reuniones[i ][2]
participantes

# sindicato de todas las reuniones que suceden al mismo tiempo
mientras que yo hice la menci√≥n y las reuniones [i][2] == cur_time:
a, b, _ = reuniones[i]
dsu.union(a, b)
participantes.extend([a, b])
i += 1

# resetea los nodos que no recibieron el secreto durante este lote
para p en participantes:
si dsu.find(p) != dsu.find(0):
dsu.par[p] = p

retorno [i para i en el rango(n) si dsu.find(i) == dsu.find(0)]

# --------------------------------------------------
# Uso de ejemplo (descomunal para probar)
# N = 6
# meetings = [[1,2,5],[2,3,8],[1,5,10]]
# print(findAllPeople(n, meetings,1)) # - t√≠tulo [0, 1, 2, 3, 5]
`` `

**La complejidad** ‚Äì id√©ntica a la soluci√≥n Java.

-...

## 3down C C++ Aplicaci√≥n

``cpp
#include ◊ôbits/stdc++.h
usando std namespace;

Clase DSU {}
public:
DSU(int n): parent(n), rank(n), 0) {
iota(parent.begin(), parent.end(), 0);
}
int find(int x) {
volver padre[x]=x ? x : parent[x]=find(parent[x]);
}
vac√≠o unite (incluido a, int b) {}
int pa=find(a), pb=find(b);
si (pa==pb) regresa;
[pa]=pb) padre [pa]=pb;
[pb]=pa;
[pb]=pa; rank[pa]++; }
}
privado:
vector:
};

Clase Soluci√≥n {
public:
vector asignadoint c√≠rculo encontrarTodas las personas(int n, vector asignadovector identificadoint—é—â reuniones, int firstPerson) {}
sort(meetings.begin(), meetings.end(),
[](cont auto ' , const auto &b){ devolver a [2]  obtenidos b[2]; });

DSU dsu(n);
dsu.unite(0, firstPerson); // secret starts at person 0

int i = 0;
mientras(i) {}
int cur = meetings[i][2];
vector implicado; // participantes en este tiempo-batch

mientras(i) se hac√≠a (int)meetings.size() " reuniones individuales[i][2] == cur) {
int a = meetings[i][0];
int b = meetings[i][1];
dsu.unite(a, b);
part.push_back(a);
part.push_back(b);
++i;
}

para(int p : part) // reajustar a los que no recibieron secretos
if(dsu.find(p) != dsu.find(0)
dsu.unite(p, p); // set parent to itself
}

vector significar uns
para (int j=0;j obtenidos;+j)
if(dsu.find(j) == dsu.find(0))
ans.push_back(j);
devolver los ans;
}
};
`` `

. **Tip**: En C++ se puede saltar el paso "reset" usando un *stack* de nodos que cambian a los padres durante un lote, pero lo anterior es m√°s f√°cil de leer.

-...

## üìö Blog Article ‚Äì ‚ÄúThe Secret Spread: A Deep Dive into LeetCode 2092‚Äù

### Title
**‚ÄúEl mensaje secreto: 2092 ‚Äì De BFS a Union‚ÄêFind ‚Äì El bueno, el malo, el ugly‚Äù* *

## Meta Descripci√≥n
Aprende c√≥mo romper LeetCode 2092 en tiempo O(n+m log m). Lea la profunda inmersi√≥n en estrategias BFS, DSU y de reducci√≥n de tiempo. Perfecto para la preparaci√≥n de entrevistas, entrevistas de codificaci√≥n y ingenieros de b√∫squeda de empleo.

-...

#### Introduction

‚ñ† **Recapto de problemas* *
‚ñ† Se les da `n` personas, una lista de reuniones `(x, y, tiempo)`, y una `primera persona`. Persona `0` tiene un secreto a la vez `0` y lo pasa a 'primera persona'. Cada vez que se celebra una reuni√≥n, cualquiera que ya sepa el secreto lo comparte instant√°neamente con el otro asistente.
‚ñ† ** Objetivo** ‚Äì devolver a todas las personas que conocen el secreto despu√©s de todas las reuniones.

‚ñ† *Por qu√© importa* ‚Äì
‚ñ† 1. **Concurrencia** ‚Äì m√∫ltiples reuniones al mismo tiempo.
‚ñ† 2. **La propagaci√≥n del gr√°fico** ‚Äì un problema cl√°sico de ‚Äúreachabilidad‚Äù, pero con un giro: la propagaci√≥n ocurre *s√≥lo* en determinados momentos.
‚ñ† 3. **Interview challenge** ‚Äì requiere un pensamiento cuidadoso sobre *cuando* puedes difundir el secreto, no s√≥lo *quien* puede.

-...

### The Na√Øve View: Breadth‚ÄêFirst Search (BFS)

Un primer instinto es tratar cada reuni√≥n como un borde en un gr√°fico y ejecutar un BFS de la fuente `(0, primera persona)`.

``text
tiempo 0: 0 - Propiedad first Persona
t: BFS de todos los que conocen el secreto en este momento
`` `

**Problema** ‚Äì BFS asume un gr√°fico *est√°tico*. En nuestro problema, los bordes s√≥lo llegan a ser relevantes ** una vez** en el tiempo de reuni√≥n, y pueden ser "apagados" si el secreto nunca lleg√≥ a ese borde. Ejecutar BFS una vez por cada sello de tiempo llevar√≠a a un algoritmo **O(n ¬∑ m)** ‚Äì demasiado lento para las restricciones (`m` up to `2¬∑105`).

-...

### The Good ‚Äì Union‚ÄêFind + Time‚ÄêBatching

#### #1# ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## #

Ordenar todas las reuniones por `tiempo`. Todas las reuniones que comparten el mismo tiempo forman un *batch*.

##### 2downSU DSU within a Batch

Durante un lote, si **cualquier participante** conoce el secreto, el secreto se propaga a **todo** componente conectado de ese lote instant√°neamente.
Union‚ÄêFind nos permite *merge* todos los participantes de un lote en tiempo amortizado casi constante.

##### 3down‚É£ Reiniciar Despu√©s del Batch

Despu√©s de procesar el lote, debemos aislar a los que hicieron **no** el secreto.
En c√≥digo esto parece:

``pseudo
para cada participante p en este lote:
si encuentra(p) != find(0):
parent[p] = p // resetear a s√≠ mismo
`` `

Este truco garantiza que la pr√≥xima vez-batch comienza de cero para todos los que no recibieron el secreto.

-...

### El malo - ¬øPor qu√© BFS es un final muerto

TENIDO TENIDO Complejidad ANTERIOR Por qu√© Fails ANTE
Silencio--------------------------
Silencio Puro BFS Silencio `O(n ¬∑ m)` Silencio Demasiado lento cuando `m` es enorme. Silencio
Silencio BFS + Sorting Silencio `O(m log m + n)` Silencio Todav√≠a `O(n¬∑m)` porque necesitamos recomputar la posibilidad de llegar desde cero para cada vez m√°s. Silencio

En resumen, BFS ignora la dimensi√≥n *time* y por lo tanto no puede manejar las reuniones simult√°neas de manera eficiente.

-...

### The Ugly ‚Äì Edge Cases that Break Simple Code

El caso Edge t√≥xico t√≥xico Problema
Silencio-----------------------Prince--
tenci√≥n **Reuni√≥n de padres con el mismo par en diferentes momentos** Silencio DSU puede recordar incorrectamente los sindicatos pasados. Silencio
tenci√≥n **Tama√±o de entrada alto** ‚Üê Profundidad de la recuperaci√≥n en los desbordamientos de DSU en Java/Python. Use compresi√≥n de ruta y bucles iterativos o levante l√≠mites de recursi√≥n. Silencio
Silencio **Multiple visits to the same person in one batch** Silencio A√±adir el mismo participante dos veces puede inflar la lista de los participantes innecesariamente. ‚Üê Mantener un `std::unordered_set interpretadoint `` (o `HashSet`) por lote para almacenar nodos √∫nicos. Silencio

-...

### Complexity Breakdown

Silencio Silencio Silencio Silencio Silencio Silencio
Silencio--------------------
Silencio Clasificar reuniones Silencio `m log m` Silencio Dominant Silencio
Silenciosas operaciones de la DAA TENIDO `Œ±(n)` amortizado por uni√≥n ANTE `O(n + m)` Silencio
Silencioso Reiniciar los bucles Silencio en la mayor√≠a de `2 ¬∑ m` por lote Silencioso `O(n + m)`
Silencio Final scan Silencio `n` finds Silencio `O(n)` Silencio

‚ñ† Resultado** ‚Äì `O(n+m) log m)` tiempo, `O(n+m)` espacio.

-...

### Consejos para entrevistas

1. **Explicar la idea de tiempo-batch primero.** Los entrevistadores les encanta ver que entendieron por qu√© ‚Äúlas reuniones simult√°neas‚Äù son especiales.
2. **Mostrar el truco de reajuste del ESD** ‚Äì es el * huevo este* que convierte una soluci√≥n ingenua del ESD en el √≥ptimo.
3. **Alternativas de menci√≥n** (BFS con una cola de eventos atemporales, o un gr√°fico por timetamp). Esto demuestra que usted es consciente del paisaje.
4. **Discusa la optimizaci√≥n del espacio** ‚Äì por ejemplo, reutilizando el vector de reuniones, o usando un vector de ‚Äúnodos cambiados‚Äù en lugar de reiniciar toda la matriz de padres.
5. **Pr√°ctica sobre problemas similares** ‚Äì por ejemplo, *BFS con limitaciones*, *Union‚ÄêFind with time windows*.

-...

### Conclusi√≥n

LeetCode 2092 te ense√±a a mezclar dos conceptos cl√°sicos:

- **BFS** (reachability)
- **Union‚ÄêFind** (compuestos conectados)

...y combinarlos con un truco de reducci√≥n de tiempo ** que respeta las reglas de coincidencia del problema.
Dominar este patr√≥n le dar√° confianza para las preguntas sobre *redes temporales*, *propulsi√≥n impulsada por elevento*, y *conectividad dinamica* en entrevistas t√©cnicas.

-...

### Referencias > Lectura posterior

- [Union‚ÄêFind (DSU) ‚Äì Wikipedia](https://en.wikipedia.org/wiki/Disjoint-set_data_structure)
- [BFS on graphs ‚Äì LeetCode](https://leetcode.com/problems/breadth-firstsearch/)
- [Problemas de gr√°ficos basados en el tiempo - Codeforces EDU](https://codeforces.com/blog/entry/11978)

¬°Feliz codificaci√≥n! üöÄ