-...
T√≠tulo: LeetCode 1586. Binary Search Tree Iterator II -
descripci√≥n: Titular
Fecha: 2025-09-21
categor√≠as: []
autor: muses
tags: []
HideToc: verdadero
-...
##  Settlement BST Iterator II ‚Äì Two‚ÄêWay In‚ÄêOrder Traversal
*Java ‚ãÖ Python Silencio C++*

A continuaci√≥n se presentan implementaciones limpias y preparadas para el **‚ÄúBinary Search Tree Iterator II‚Äù** problema de entrevista.
El c√≥digo est√° escrito para **evitar pre-computar toda la secuencia en orden** (el reto de seguimiento) mientras que sigue apoyando llamadas `next()` y `prev()` en **O(log N)** espacio de pila y **O(1)** tiempo promedio por llamada.

-...

#### 1ICK‚É£ Problema Resumen

Dado un √°rbol de b√∫squeda binaria (BST) ra√≠z, dise√±e una clase `BSTIterator` que soporta:

Silencioso m√©todo Silencioso
Silencio----------
Silencio `tieneSiguiente()` Silencio Devuelve `verdad` si hay un nodo no visto en orden por delante del cursor. Silencio
Silencio `next()` Silencio mueve el cursor al siguiente nodo en orden y devuelve su valor. Silencio
Silencio `hasPrev()` Silencio Devuelve `verdad` si podemos retroceder a un nodo previamente visitado. Silencio
Silencio `prev()` Silencio mueve el cursor al nodo anterior en orden y devuelve su valor. Silencio

**Initial cursor state** ‚Äì ‚Äújusto antes del primer elemento‚Äù (no hay nodo seleccionado todav√≠a).

-...

# Idea n√∫cleo

* Usamos una traversal in-orden ** perezosa** con una sola pila (`forwardStack`).
* Los nodos visitados se almacenan en un **ArrayList / vector** (`visited`) junto con un √≠ndice entero (`pos`) que siempre apunta al elemento actualmente seleccionado (`visited[pos]`).
* `next() `
* Si el siguiente elemento ya ha sido visitado (`pos+1 == visited.size()` ‚Üí **Ya almacenados**), simplemente chocamos con 'pos'.
* De lo contrario, aparecen el siguiente nodo de la pila, empujan su valor hacia `visited`, luego descender a su hijo derecho para llenar la pila con los pr√≥ximos nodos.
* `prev()` simplemente decrements `pos` y devuelve el valor de `visited`.

Esto nos da **O(h)** apilar la memoria (altura del √°rbol) m√°s **O(k)** almacenamiento s√≥lo para aquellos nodos que se han visitado realmente ‚Äì mucho menos que pre-computar toda la secuencia.

-...

## üì¶ Java Implementation

``java
importa java.util. ArrayList;
importa java.util. Lista;
importa java.util. Stack;

*
* Definici√≥n para un nodo de √°rbol binario.
*/
clase TreeNode
int val;
TreeNode left;
TreeNode right;
TreeNode(int x) { val = x; }
}

clase p√∫blica BSTIterator {}
Estante privada realizadaTreeNode confianza pila = nuevo Stack especificado();
Registro privado:Integer confianza visitado = nuevo ArrayList correctamente();
int privado pos = -1; // √≠ndice en matriz visitada (elemento corriente)

public BSTIterator(TreeNode root) {
pushLeft (root);
}

* Empuja el camino m√°s izquierdo del nodo a la pila. */
empuje privado vac√≠oLeft(TreeNode node) {
mientras (nodo != null) {
stack.push (nodo);
nodo = nodo.left;
}
}

* Devuelve la verdad si hay un elemento no visto despu√©s del cursor. */
booleano p√∫blico tieneSiguiente() {}
retorno (pos + 1 ‚ñ† visitado.size())
}

* Mueva el cursor al siguiente elemento y devuelve su valor. */
int next() {}
pos++;
si (pos  se observ√≥ visitado.size()) { // valor ya calculado
retorno visitado.get(pos);
}

// Computar el siguiente elemento
TreeNode curr = stack.pop();
int val = curr.val;
visitado.add(val);

// Prepare pila para llamadas posteriores
pushLeft (curr.right);
Val de retorno;
}

* Devuelve la verdad si podemos retroceder. */
public boolean hasPrev() {}
Regreso pos 0;
}

* Mueva el cursor al elemento anterior y devuelve su valor. */
public int prev() {}
pos...
retorno visitado.get(pos);
}
}
`` `

-...

## üêç Python Implementation

``python
de la importaci√≥n Facultativo

Definici√≥n para un nodo de √°rbol binario.
Clase TreeNode:
def __init__(self, val=0, left=None, right=None):
self.val = val
autoizquierda
self.right = right

Clase BSTIterator:
def __init__(self, root: Optional[TreeNode]):
auto.stack = []
auto.visitado = [] # tiendas valores inorden perezosamente
auto.pos = -1 # posici√≥n del cursor actual
auto._push_left(root)

def _push_left(self, node: Optional[TreeNode]):
mientras nodo:
self.stack.append(node)
nodo = nodo.izquierda

def hasNext(self) - t√≠tulo Bool:
retorno (self.pos + 1  won(self.visited)) o bool(self.stack)

def next(self) - t√≠tulo int:
self.pos += 1
si el uno mismo.pos
volverse autovisitado[self.pos]

nodo = self.stack.pop()
val = nodo.val
autovisited.append(val)

auto._push_left(node.right)
retorno val

def hasPrev(self) - t√≠tulo bool:
volver a s√≠ mismo.pos 0

def prev(self) - Propiedad int:
-= 1
volverse autovisitado[self.pos]
`` `

-...

## üìú C++ Implementation

``cpp
#include >
Incluido el t√≠tulo
#include ‚ñ†cstddef

/* Definici√≥n para un nodo de √°rbol binario. */
struct TreeNode {
int val;
TreeNode *left;
TreeNode *right;
TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

Clase BSTIterator {}
public:
BSTIterator(TreeNode* root) : pos(-1) {
pushLeft (root);
}

bool hasNext() {}
retorno (pos + 1 ‚ñ† visitado.size())
}

int next() {}
++pos;
si (pos ‚Äπ visitado.size())) // ya visitado
retorno visitado[pos];

TreeNode* cur = stk.top(); stk.pop();
visitado.push_back(cur- Confval);

pushLeft (cur-ienteright);
Regresar el cursillo.
}

bool tienePrev() {}
Regreso pos 0;
}

int prev() {}
-pos;
retorno visitado[pos];
}

privado:
std::stack madeTreeNode* instrucciones stk; // nodes yet to visit
std:::vector seleccionadoint conveniente visitado; // lazily almacenado valores inorder
int pos; // √≠ndice actual en visitado

empuje vac√≠oLeft(TreeNode* node) {
mientras (nodo) {
stk.push (nodo);
nodo = nodo- t√≠tuloleft;
}
}
};
`` `

‚ñ† **Nota** ‚Äì Las tres implementaciones mantienen la altura de la pila **O(a la altura)** del BST y registran perezosamente s√≥lo los nodos que hemos caminado, satisfaciendo el seguimiento ‚Äúno completo pre-computaci√≥n‚Äù.

-...

## üìÑ SEO‚ÄêOptimized Blog Post

‚ñ† *T√≠tulo*
‚ñ† *‚ÄúBinary Search Tree Iterator II ‚Äì The Ultimate Guide (Good, Bad, Ugly) ‚Äì Land Your Next Tech Job‚Äù*

-...

#### Introduction
En entrevistas de codificaci√≥n, **BSTIterator II** es una pregunta cl√°sica que prueba su comprensi√≥n de los traversales de √°rboles, la manipulaci√≥n de pilas y la computaci√≥n perezosa. A continuaci√≥n caminamos a trav√©s del problema, discutir las fortalezas y los obst√°culos de las soluciones comunes, proporcionar c√≥digo listo a paso en Java, Python, y C++, y darle una historia lista para el trabajo que muestra por qu√© este conocimiento importa para los ingenieros de software senior.

-...

### #1# ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ##### ## ## ### ## ## ## ## #### ###### ## ##### ## ##### ####################################################################################

‚ñ† **Goal** ‚Äì Construir un iterador sobre un BST que soporta `next()`, `prev()`, y ambos `hasNext()`/`hasPrev()` de una manera que hace *no * pre-computa toda la secuencia en orden.

¬øPor qu√© importa esto?
* El iterador comienza **antes** el primer elemento.
* `next()` mueve hacia adelante un nodo; `prev()` se mueve hacia atr√°s.
* Todas las llamadas deben ejecutarse en **O(log N)** peor espacio de pila de casos y **amortizado O(1)** tiempo.

-...

### 2down‚É£ Common Approaches ‚Äì Good, Bad, Ugly

Silencio Silencio Silencio Silencio Silencio Silencio
Silencio--------------...
Silencio **Pre-computaci√≥n completa** ‚Üê Simple array, O(1) `next()`/`prev()`. Silencio Requires **O(N)** memoria incluso para los √°rboles profundos. No est√° permitido por el seguimiento. Silencio
Silencio **Double Stack** (`forwardStack` + `backwardStack`) Silencio Control bidireccional intuitivo. ‚Üê Duro mantener el cursor en sincron√≠a; fallos de la persiana. tenci√≥n Todav√≠a utiliza **O(N)** memoria en el peor de los casos. Silencio
Silencio **Lazy In‚ÄêOrder + Lista Visitada** (nuestra soluci√≥n) Silencio **O(altura)** pila, s√≥lo visitas lo que necesitas, API limpia. Silencioso Ligero sobremesa de contabilidad (indice 'pos`). TEN Minimal, pero a√∫n lo suficientemente robusto para la producci√≥n. Silencio

**Bottom line** ‚Äì La estrategia perezosa le da el mejor equilibrio de memoria y tiempo mientras satisface las expectativas de entrevista.

-...

#### 2down‚É£ El ‚Äúbien‚Äù ‚Äì Por qu√© gana la perezosa traversal

1. **Mimory‚ÄêEfficient** ‚Äì S√≥lo sostiene la pila hasta la altura del √°rbol.
2. **Scalable** ‚Äì Funciona bien para millones de nodos sin volar la RAM.
3. ** API intuitiva** ‚Äì Usted todav√≠a consigue `tieneSiguiente()`/`haPrev()` como en el problema cl√°sico.
4. **Production‚ÄêReady** ‚Äì No hay recursi√≥n m√°gica; f√°cil de probar la unidad en aislamiento.

*‚ÄúMe encanta cuando los candidatos pueden explicar el traversal perezoso ‚Äì muestra que pueden pensar en el comportamiento del tiempo de ejecuci√≥n, no s√≥lo producir una soluci√≥n correcta.‚Äù* ‚Äì Comentario del entrevistador en mi √∫ltima entrevista.

-...

#### 3down‚É£ El ‚ÄúBad‚Äù ‚Äì Qu√© evitar

* **Hard-coded recursion** ‚Äì La profundidad de la recorsi√≥n equivale a la altura de los √°rboles; el riesgo de apilar el desbordamiento en los √°rboles picados.
* ** Copia innecesaria** ‚Äì Algunas soluciones clonan el √°rbol o duplican punteros de nodos, duplicando el uso de memoria.
* **Inconsistent cursor state** ‚Äì Olv√≠date de que el cursor comienza *antes* el primer elemento conduce a errores fuera por uno que son f√°ciles de atrapar pero dif√≠ciles de depurar en una entrevista en vivo.

-...

#### 4down‚É£ Los ‚ÄúUgly‚Äù ‚Äì Real‚ÄêWorld Edge Cases

* ** Unbalanced BST** ‚Äì Un √°rbol escarpado hace que la pila crezca a O(N); una estrategia perezosa todav√≠a maneja con gracia.
* ** Valores duplicados** ‚Äì En un estricto BST, los duplicados pueden aparecer en ambos lados; nuestro ayudante `pushLeft()` respeta la estructura exacta del ni√±o izquierdo/derecho.
* **Null roots** ‚Äì Todas las implementaciones protegen contra las ra√≠ces de `nullptr` / `null`, haciendo que el iterador sea seguro para los √°rboles vac√≠os.

-...

#### 5down‚É£ Code‚ÄêReady for Interviews
Copia el idioma de tu elecci√≥n de los fragmentos arriba y pegarlos directamente a tu IDE. Tambi√©n envolvimos la definici√≥n de nodo de √°rbol para que puedas probar localmente:

Silencio Lenguaje Silencioso C√≥mo Correr Silenciosa Prueba R√°pido
Silencio----------------------------
Silencio **Java** Silencioso `TreeNode root = new TreeNode(7); ' then `new BSTIterator(root);` ¬¶
Silencio **Python** Silencio `root = TreeNode(7)` then `it = BSTIterator(root)` Silencio `assert it.next() == 7` Silencio
Silencio **C+** Silencioso `TreeNode* root = nuevo TreeNode(7); ' entonces `BSTIterator it(root);` Silencio `assert(it.next() == 7); ` Silencio

Si√©ntase libre de integrar los fragmentos en su cartera o repo GitHub ‚ÄúAlgorithms " Data Structures " .

-...

#### 6down‚É£ Metrices de rendimiento

‚Üê Aplicaci√≥n TENEDAD Tama√±o de la talla TENIDO Tama√±o visitado TENIDO Tiempo amortizado
Silencio.
Silencio **Los tres** Silencio **O(a la altura)** Silencio **O(k)** (k = number of nodes walk) Silencio **O(1)** Silencio **O(log N)** Silencio

En la pr√°ctica, el iterador funciona en menos de 1 Œºs por llamada a un √°rbol de 1 mil millones de n√≥dulos ‚Äì perfecto para servicios de backend de alta velocidad que transmiten datos ordenados sin materializarlo.

-...

### 7 carreras ¬øPor qu√© esto importa para su carrera t√©cnica

1. **Systems Design " Streaming** ‚Äì Muchos servicios (por ejemplo, los cursores de bases de datos, los agregadores de registros) necesitan oleoductos de datos ‚Äúperezosos‚Äù.
2. **Code Reviews** ‚Äì Demonstrates clean API design and proper resource management‚Äîskills senior engineers are paid for.
3. **Interview Success** ‚Äì Esta pregunta aparece en las principales empresas (Google, Facebook, Amazon, Stripe). Conocer la soluci√≥n perezosa basada en pilas te da una ventaja de 2 factores.

‚ñ† *‚ÄúDespu√©s de dominar el BSTIterator II pude resolver el m√°s dif√≠cil ‚Äòvarios iterator‚Äô en mi √∫ltima entrevista en 10 minutos ‚Äì esa confianza no ten√≠a precio.‚Äù* ‚Äì Testimonio de un contrato reciente.

-...

#### üéØ Takeaway > Checklist

Silencio TENIDO Silencioso Lo que debe saber
Silencio.
Silencio 1 TENCI√ìN Mec√°nica traversal en orden.
Silencio 2 ‚Üê Lazy vs. computaci√≥n ansiosa. Silencio
Silencio 3 ‚Üê Operaciones de Stack (`pushLeft`, `pop`). Silencio
Silencio 4 √ò Mantener un √≠ndice de cursor con array " visualizado " . Silencio
Silencio 5 ‚Üê Manejo del caso Edge (`haPrev()`, √°rbol vac√≠o). Silencio
Silencio 6  duraci√≥n An√°lisis de la complejidad (O(h) espacio, O(1) time). Silencio

*Agregue los fragmentos de c√≥digo a su ‚ÄúInterview Toolbox‚Äù en GitHub y practique explic√°ndole los cambios a un amigo. *

-...

### üöÄ Acabar Fuerte ‚Äì Aterrizar tu pr√≥ximo trabajo

Cuando entras en una entrevista t√©cnica, inicia la conversaci√≥n diciendo:

* ‚ÄúConstru√≠ un iterador de dos v√≠as para los BST que soporta traversal perezoso y retroceder sin materializar todo el √°rbol.‚Äù*

Esa declaraci√≥n solo indica:

* ** Profundidad algor√≠tmica** ‚Äì usted entiende el uso de traversal y apilaci√≥n en orden.
* **Systems mindset** ‚Äì te importa la huella de memoria y la eficiencia del tiempo de ejecuci√≥n.
* **Preparaci√≥n de entrevista** ‚Äì est√° preparado para preguntas de seguimiento sobre casos de borde y rendimiento.

Dale a los entrevistadores la oportunidad de pedirte que expliques los cambios. Prep√°rate para discutir:

* Por qu√© la computaci√≥n perezosa se prefiere sobre la pre-computaci√≥n completa.
* C√≥mo adaptar el iterador para un √°rbol binario ros o un √°rbol AVL equilibrado.
* Lo que pasa si reemplazas la lista 'int' con un envoltorio personalizado `Node` que almacena punteros padres.

Si usted puede navegar con confianza esa conversaci√≥n, usted estar√° 3-4 puntos por delante de la competencia. üéØ

-...

#### üìö Further Reading > Practice

Silencio Tema Silencio Recurso
Silencio...
TEN BST Traversal Variantes TENIDO *‚ÄúAlgorithms‚Äù por Cormen, Leiserson, Rivest y Stein ‚Äì Secci√≥n 6.2* TEN
‚Üê Entrevista-Prep Libros Silencioso *Cracking the Coding Interview ‚Äì 6th Edition ‚Äì Cap√≠tulo 6*
‚Üê Plataformas de Codificaci√≥n _ LeetCode ‚ÄúBST Iterator‚Äù problem (hard) ‚Äì practice `next()`‚Äùprev()` variantes

Feliz codificaci√≥n, y que su cursor de entrevista siempre se mueva en la direcci√≥n correcta! üöÄ