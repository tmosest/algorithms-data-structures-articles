-...
T√≠tulo: LeetCode 1357. Aplicar Descuento Cada n Pedidos -
descripci√≥n: Titular
Fecha: 2025-09-21
categor√≠as: []
autor: muses
tags: []
HideToc: verdadero
-...
# 1 ride Lee LeetCode 1357 ‚Äì * Descuento de aplicaci√≥n Cada n Pedidos*
**Soluci√≥n en Java, Python & C++ + una entrevista adaptada a SEO**

-...

Problema Recap

Un supermercado vende " productos " por " precios[i] " .
La factura de un cliente es dos arrays paralelos `product` & `amount`.
Cada cliente **`n``th** recibe un **`discount` %** fuera del subtotal.

Usted debe implementar:

``text
Cajero(int n, int descuento, int[] productos, int [] precios)
doble getBill(int[] producto, int[] cantidad)
`` `

`getBill` devuelve la cantidad final que un cliente debe pagar (descuento aplicado si es el
nth cliente). Se aceptan respuestas en el apartado 1e-5.

‚ñ† **Constraints**
‚â§ 104
* `0 ‚â§ descuento ‚â§ 100`
> > ‚â§ productos. longitud ‚â§ 200 >
* 1 ‚â§ producto. longitud ‚â§ productos. longitud `
* `product` Los ID son √∫nicos

-...

# Idea n√∫cleo

* **Map product IDs ‚Üí precios** (`HashMap / unordered_map / dict`).
* Mantener un **contra** (`actualCustomer`).
* Despu√©s de cada llamada a `getBill`, aumentar el contador.
Si `currentCustomer % n == 0`, aplicar el descuento.
* Computar el subtotal por iterar a trav√©s del orden y summing
`amount[i] * price[product[i]]`.

El algoritmo es **O(k)** por llamada, donde *k* es el n√∫mero de elementos en que
pedido, y utiliza **O(p)** espacio adicional para el mapa de precios.

-...

## ŸÅ Code

#### ## 1down‚É£ Java

``java
importa java.util. HashMap;
importa java.util. Mapa;

clase p√∫blica Cashier {
int n privado final; // cada nth cliente obtiene descuento
descuento final privado; // por ciento descuento
final privado Mapa:Integer,Integer ratioMap;
privado int cliente Cnt = 0; // cuenta cu√°ntos clientes hasta ahora

public Cashier(int n, int descuento, int[] productos, int[] precios) {
esto.n = n;
esto. descuento = descuento;
precioMap = nuevo HashMap garantizado(products.length);
para (int i = 0; i) i++) {
precioMap.put(products[i], precios[i]); // O(p)
}
}

public double getBill(int[] product, int[] amount) {
cliente Cnt++; // 1 base contando

subtotal doble = 0;
para (int i = 0; i) i++) {
subtotal += priceMap.get(product[i]) * (double) amount[i];
}

si (customer Cnt % n == 0) { // nth customer
subtotal *= (100 - descuento) / 100.0; // aplicar descuento
}
subtotal de retorno;
}
}
`` `

#### 2down‚É£ Python

``python
clase Cajero:
def __init__(self, n: int, descuento: int, productos: list[int], precios: list[int]):
self.n = n
self.discount = descuento
self.price_map = {p: pr para p, pr en zip(products, prices)}
self.customer_cnt = 0

def getBill(self, product: list[int], amount: list[int] flotante:
auto.customer_cnt += 1
subtotal = sum(self.price_map[prod] * amt for prod, amt in zip(product, amount))
si auto.customer_cnt % self.n == 0: # cada nth client
subtotal *= (100 - self.discount) / 100.0
subtotal
`` `

#### 3down‚É£ C++

``cpp
#include ‚ñ†unordered_map Conf
Incluido el t√≠tulo

clase Cajero
int n; // frecuencia de descuento
descuento int; // por ciento
std::unordered_map seleccionada, int ratioMap; // product ‚Üí precio
cliente int Cnt = 0; //

public:
Cajero(int n, int descuento, std::vector fielint productos, std::vector fielint precios)
: n(n), descuento(descuento) {
para (size_t i = 0; i) ++i)
precioMap[products[i] = precios[i];
}

doble getBill(cont std::vector seleccionadoint limitada product, const std::vector fieltro cantidad) {
++cliente Cnt;
subtotal doble = 0,0;
para (size_t i = 0; i) ++i)
subtotal += precioMap [product[i]] * static_cast seleccionadodouble(amount[i]);

si (customer Cnt % n == 0)
subtotal *= static_cast seleccionadodouble(100 - descuento) / 100.0;
subtotal de retorno;
}
};
`` `

-...

## üìê Complexity Analysis

TEN TERRITOR SON TEN ANTERIOR ANTERIOR ANTERIOR TERRITORIO ANTERIOR ANTERIOR ANTERIOR ANTERIOR
Silencio------------------------------ La vida----
Silencio Precio del edificio mapa Silencioso `O(p)` (`p` = #products) Silencio `O(p)` Silencio
Silencio `getBill` call (per order) Silencio `O(k)` (`k` = #items in order) Silencio `O(1)` (beside input) ‚Üê

Con una mayor√≠a de 1000 llamadas y `p ‚â§ 200`, la soluci√≥n encaja f√°cilmente dentro de la
l√≠mites.

-...

Art√≠culo del Blog ‚Äì ‚ÄúEl Bien, el Mal y el Ugly of *Apply Discount Every n Orders*‚Äù

### 1. T√≠tulo " Meta-Descripci√≥n "

‚ñ† **T√≠tulo**: *Aplicar Descuento Cada n Pedidos ‚Äì Java, Python & C++ Soluciones (LeetCode 1357)*
‚ñ† **Meta‚ÄêDescription**: Solve LeetCode 1357 ‚ÄúPromoci√≥n de aplicaci√≥n Cada n Pedidos‚Äù con c√≥digo Java limpio, Python y C++. Aprenda los cambios, casos de borde y consejos de entrevista para llegar a la pregunta.

### 2. Esquema

1. **Introducci√≥n** ‚Äì ¬øPor qu√© este problema es un problema b√°sico en las entrevistas t√©cnicas
2. **Problema declaraci√≥n** ‚Äì Restate constraints, goal, and expected output
3. **Observaciones clave** ‚Äì ID de producto √∫nico, frecuencia de descuento fija
4. **Estrategia** ‚Äì Mapa de b√∫squeda + contador
5. **Implementaci√≥n** ‚Äì C√≥digos para Java, Python, C++
6. ** Casos de complejidad y borde** ‚Äì Rebosa, precisi√≥n de punto flotante
7. **El Bien** ‚Äì Simplicidad, legibilidad, espacio O(1) por llamada
8. **El mal** ‚Äì trampas alternativas (b√∫squeda de rayos, recursi√≥n)
9. **El Ugly** ‚Äì trampas del mundo real (desbordamiento entero, reinicio de descuento perdido)
9. **Perspectiva de Interview** ‚Äì ¬øQu√© entrevistadores est√°n buscando realmente
10. **Testing** ‚Äì C√≥mo escribir pruebas de unidad
11. **FAQs** ‚Äì Puntos de confusi√≥n comunes
12. **Conclusi√≥n " Call‚Äêto-Action** - Fomentar la pr√°ctica " prep

### 3. Texto completo del Blog

``markdown
# Apply Discount Every n Orders ‚Äì Java, Python & C+ Solutions (LeetCode 1357)

‚ñ† **LeetCode 1357** es una pregunta de entrevista cl√°sica que prueba
*data‚Äêstructure choice*, *contra l√≥gica* y *floating‚Äêpoint handling*.
‚ñ† A continuaci√≥n se presenta una gu√≠a paso a paso con c√≥digo limpio en tres idiomas principales,
m√°s una profunda inmersi√≥n en los intercambios que cada candidato debe saber.

## üìå Introduction

Los entrevistadores aman problemas que mezclan un sistema *establecido* (un cajero) con un
regla aritm√©tica simple (todos los clientes nth obtienen un descuento).
Comproba:
- su comprensi√≥n de **hash mapas** para la b√∫squeda O(1)
**modulo arithmetic** para eventos peri√≥dicos
- manejo **materia de punto flotante** sin perder precisi√≥n

Si usted ha clavado esta pregunta, usted se sentir√° confiado tackling similar
problemas estatales en cualquier ronda de contrataci√≥n t√©cnica.

-...

Declaraci√≥n de problemas

‚ñ† Una tienda vende *productos* para *precios*.
‚ñ† El pedido de un cliente es dos arrays: `product[]` y `amount[]`.
‚ñ† Cada cliente de 'n' obtiene un 'descuento' % del subtotal.
‚ñ† Implementar `Cashier` con `getBill()` que devuelve la cantidad final.

Constraints:
- 1 ‚â§ 104
- `0 ‚â§ descuento ‚â§ 100`
- `products.length ‚â§ 200`
- `producto` Las identificaciones son **unique** y **positivo**.

-...

## üîç Observaciones clave

TENCI√ìN ANTERIOR Por qu√© importa
Silencio...
Silencio ** IDs √∫nicos** Silencio Permite la b√∫squeda directa de hash‚Äêmap. Silencio
Silencio **Fixed `n`** Silencio Simple contador con modulo. Silencio
Silencio **`discount`** ‚â§ 100 casos de retraso 0 % (sin descuento) > 100 % (gratuito). Silencio
Silencio **No hay cambios de orden** Silencio Mapa de precio construido una vez en constructor. Silencio

-...

## üìä Strategy

1. ** Mapa de precios** ‚Äì `producto ‚Üí precio `
*O(p)* para construir, *O(1)* por lookup.
2. **Customer Counter** ‚Äì `current Customer++`.
Aplicar descuento cuando `currentCustomer % n == 0`.
3. **C√°lculo subtotal** ‚Äì Itear sobre los art√≠culos de pedido.

El dise√±o es *O(k)* por llamada, *O(p)* espacio.
Los tres idiomas (Java, Python, C++) usan la misma l√≥gica ‚Äì simplemente diferente
sintaxis.

-...

## üßë üíª Aspectos destacados de la implementaci√≥n

Silencio Idioma Silencio Core Lines Silencio Por qu√© se ve bien
Silencio--------------------------------...
Silencio **Java** Silencioso `priceMap.put(products[i], prices[i]);` + `subtotal *= (100‚Äêdiscount)/100.0;` peru Strong typing + explicit `double` cast.
Silencio **Python** Silencio `{p: pr for p, pr in zip(products, prices)}` + `subtotal *= (100-discount)/100.0` peru Concise comprensi√≥n, automatic big-int support. Silencio
Silencio **C++** Silencio `unordered_map observadoint,intenta precioMap;` + `subtotal *= (100-discount)/100.0` peru Compilaci√≥n r√°pida-time Lookups, expl√≠cito casting to double. Silencio

Los bloques de c√≥digo de la secci√≥n **Soluci√≥n** est√°n incrustados para copiar r√°pidamente.

-...

## ‚è± Complexity & Edge Cases

* **Hora** ‚Äì `O(k)` por orden, lineal en n√∫mero de art√≠culos.
* **Pace** ‚Äì `O(p)` para el mapa; por llamada `O(1)`.
* **Overflow** ‚Äì `amount[i] * price` fits in 32‚Äêbit signed int (`‚â§ 200 √ó 104`),
pero lanzamos a "doble" antes de multiplicarse para evitar el desbordamiento accidental.
* **Precisi√≥n** ‚Äì Use `doble` y un multiplicador como `(100-discount)/100.0`.
LeetCode acepta `1e-5`, por lo que IEEE‚Äê754 est√°ndar es seguro.

-...

## llev√°ndose el bien

Silencioso Benefit
Silencio...
Silencio **Claridad** Silencio Un mapa, un contador ‚Äì ning√∫n truco oculto. Silencio
Silencio **Performance** tenci√≥n Mapa de tiempo constante; lineal en tama√±o de orden solamente. Silencio
Silencio **Mantenibilidad** Silencioso constructor separado " m√©todo; f√°cil de probar. Silencio
tenci√≥n **Cross‚ÄêLanguage** tenci√≥n Mismo algoritmo, adaptaci√≥n m√≠nima para Java/Python/C++. Silencio

-...

## ‚ãÖ The Bad

Por qu√© duele la vida
Silencio...
Silencio **Array‚ÄêSearch Alternative** Silencio Usar una b√∫squeda lineal en la matriz de productos da tiempo `O(p*k)` ‚Äì innecesario si `p` es 200. Silencio
tenci√≥n **Recursive Counter** TEN Recursion apilar√≠a el flujo si `n` es grande. Silencio
Silencio **Missing Reset** Silencio Failing para restablecer el contador despu√©s del descuento conduce a descuentos futuros incorrectos. Silencio

-...

## The Ugly

Problema de la vida en el escenario del mundo real
Silencio--------------...
Silencio **Desbordamiento entero** Silencioso `mont[i] * precio` podr√≠a exceder `231‚Äê1` si usted permanece en `int`. tenci√≥n Promuevan a `long` o `doble` antes de la multiplicaci√≥n. Silencio
TEN **Floating‚Äêpoint drift** TEN Los descuentos repetidos pueden acumular errores de redondeo. Retorno `doble` y conf√≠e en `1e‚Äê5` tolerancia; utilice `Decimal` en Python si se necesita la exactitud. Silencio
Silencio **Guardia de la divisi√≥n del espacio** Cnt % 1 == Siempre es verdad. Funciona bien; s√≥lo asegura que el descuento se aplica a cada cliente ‚Äì un caso de esquina que debe probar. Silencio

-...

## üìà Interview Tips

1. **Preguntas aclaratorias** ‚Äì ‚Äú¬øSe aplica el descuento al subtotal o al total final? ‚Äù
2. **Explicar la contra l√≥gica** ‚Äì ‚ÄúAmucho el contador primero, luego comprobar ‚Äúcnt % n == 0‚Äù. ‚Äù
3. **Mostrar la construcci√≥n del mapa** ‚Äì ‚ÄúConstruiremos el mapa una vez en el constructor para espacio O(p). ‚Äù
4. ** Punto flotante de la menci√≥n** ‚Äì ‚ÄúUsamos el doble para preservar los centavos. ‚Äù
5. ** Casos de prueba de debate** ‚Äì Proporcionar ejemplos, especialmente para casos de borde: `descuento = 0`, `descuento = 100`, `n = 1`, √≥rdenes grandes.

-...

## üìö Testing Checklist

Silencio Test confidencialidad Qu√© hacer para verificar
Silencio...
tenci√≥n Ejemplo b√°sico (desde el problema) Silencio Correct descuento en 3er y 6to clientes. Silencio
Silencio `discount = 0` Silencio No hay cambio a subtotal. Silencio
Silencioso `descuento = 100` Silencio Zero factura final. Silencio
Silencio `n = 1` Silencio Cada cliente obtiene descuento. Silencio
tenci√≥n Orden grande (200 √≠tems) Silencio Sin degradaci√≥n del rendimiento. Silencio
Silencio Llamadas repetidas 104 √ò El contra modulo sigue funcionando. Silencio

-...

Conclusi√≥n

LeetCode 1357 es una pregunta *establecida* que combina el uso de la estructura de datos con
aritm√©tica modular.
Un simple hashmap + contra enfoque da c√≥digo limpio y eficiente en **Java,
Python y C+**.
Entender las trampas (sobreflujo, punto flotante) y discutir el dise√±o
oficios en entrevistas ‚Äì demostrar√°s tanto la habilidad t√©cnica como
pensativo problema - soluci√≥n.

-...

## ‚ùì FAQ

Silencio
Silencio...
Silencio **¬øPuedo usar un array en lugar de un mapa?** Silencio S√≠, pero necesitar√°s `O(p)` b√∫squeda lineal para cada orden ‚Äì O(k √ó p) tiempo. Silencio
Silencio **¬øQu√© pasa si los IDs de producto no son √∫nicos?** Silencio Problema garantiza la singularidad; de lo contrario necesitar√° una lista de precios por ID. Silencio
Silencioso ** ¬øDesbordar√° la multiplicaci√≥n de enteros?** Silencio Use `long` o cast to `double` antes de la multiplicaci√≥n. Silencio
Silencio **¬øEs suficiente precisi√≥n doble?** Silencio LeetCode acepta error 1e‚Äê5; mantissa de 53 bits doble es m√°s que suficiente. Silencio

-...

## üöÄ Get Hired

Dominar este problema muestra que puede:

* Map data to a value efficient (`HashMap` / `dict`).
* El manejo del estado peri√≥dico cambia de forma limpia (`%` operador).
* Escriba c√≥digo limpio, multiplataforma.

Agregue las soluciones anteriores a su cartera, incluya la explicaci√≥n lista para la entrevista, y tendr√° un punto de conversaci√≥n fuerte para cualquier entrevista **software-engineering**.

¬°Feliz codificaci√≥n y buena suerte en tu pr√≥xima entrevista!