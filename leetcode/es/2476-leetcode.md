-...
T√≠tulo: LeetCode 2476. B√∫squedas m√°s cercanas en un √°rbol de b√∫squeda binaria -
descripci√≥n: Titular
Fecha: 2025-09-21
categor√≠as: []
autor: muses
tags: []
HideToc: verdadero
-...
## üéØ 2476. B√∫squedas m√°s cercanas en un √°rbol de b√∫squeda binaria
### LeetCode ‚Üê Medium tenci√≥n Entrevista Soluci√≥n lista (Java ‚Üê Python Silencio C++)

-...

### üöÄ TL;DR
* **Problema** ‚Äì Para cada consulta *q* encontrar:
* * *mini* = valor m√°s grande ‚â§ *q* en el BST (o **‚Äê1** si ninguno).
* * * m√°xi* = valor m√°s peque√±o ‚â• *q* en el BST (o **‚Äê1** si ninguno).
* **Aprobaci√≥n** ‚Äì Convertir el BST en un array surtido ** (en la traversal ordenada) y utilizar la b√∫squeda binaria (`bisect`/`lower_bound`) para cada consulta.
* Complejidad*
*Time* : **O(n + m log n)** ( *n* = #nodes, *m* = #queries)
*Espacio*: **O(n)** (para la matriz ordenada)
* **Por qu√© importa** ‚Äì Muestra conocimiento profundo de las propiedades BST, el traversal de √°rboles y la b√∫squeda eficiente ‚Äì perfecto para cualquier entrevista de ingenier√≠a de software senior.

-...

Declaraci√≥n de problemas (LeetCode 2476)

‚ñ† **Input**
* `root` ‚Äì root of a binario search tree (BST).
* `queries` ‚Äì lista de n√∫meros enteros positivos.
‚ñ† **La salida*
‚ñ† Un array de 2-D 'respuesta' donde
> `answer[i] = [mini, maxi]` para la consulta *i*‚Äêth.

‚ñ† *Examples*
" texto
√Æ root = [6,2,13,1,4,9,15,null,null,null,null,null,null,null,null,14]
[2,5,16]
[2,2],[4,6],[15,-1]
" `

-...

Intuici√≥n & Dise√±o

TENIDO ANTERIOR ANTERIENTE ANTERIOR ANTERIOR ANTERIOR ANTERIOR ANTERIOR ANTERIOR ANTERIOR ANTERIOR ANTERIOR ANTERIOR ANTE ANTE
Silencio----------...
tenci√≥n ** propiedad BST** ‚Äì cada ni√±o izquierdo se llev√≥ a cabo padre o hija derecha. Silencio **Escaneo luminoso** para cada consulta es O(n ¬∑ m) ‚Üí TLE en 105 nodos/queries. Silencio **Ignorar los casos de borde** (no predecesor/succesor) conduce a resultados incorrectos. Silencio
TEN **In‚Äêorder traversal** da una matriz ordenada ‚Üí f√°cil b√∫squeda binaria. **El almacenamiento del √°rbol entero** de nuevo (por ejemplo, TreeSet) es innecesario. **B√∫squeda binaria incorrecta** (errores falsos por uno) identifica err√≥neamente los l√≠mites. Silencio
tenci√≥n **`lower_bound` / `bisect`** encontrar el primer elemento ‚â• target. TEN **B√∫squeda binaria plegable** dentro de un lazo es m√°s dif√≠cil de depurar. TEN **La profundidad de la recursi√≥n** puede soplar si el √°rbol es picado ‚Äì mejor para hacer traversal iterante. Silencio

-...

## 3down Algoritm

1. **Atravesar el orden BST** ‚Üí `Vals surtidos`.
2. Por cada `q ' en las ' demandas ' :
* `idx = lower_bound(sorted Vals, q)`
* `maxi = (idx < n) ? ordenadosVals[idx] : -1`
* `mini = (idx 0) ? sortVals[idx-1] : -1`
* Si `idx ' se realiz√≥ n` y `sortedVals[idx] == q` ‚Üí tanto `mini ' como `maxi` = `q`.
3. Ap√©ndice `[mini, maxi]` al resultado.

-...

## 4VIEW‚É£ Complexity Analysis

TEN TERRITOR SON TEN ANTERIOR ANTERIOR ANTERIOR TERRITORIO ANTERIOR ANTERIOR ANTERIOR ANTERIOR
Silencio------Prince--------
Silencio In‚Äêorder traversal Silencio **O(n)** Silencio **O(n)** (sorted array)
Silencio Cada consulta (b√∫squeda binaria) Silencio **O(log n)** Silencio ‚Äì Silencio
Silencio total **O(n + m log n)** Silencio **O(n)**

* `n` = n√∫mero de nodos de √°rboles (‚â§ 105)
* `m` = n√∫mero de consultas (‚â§ 105)

Tanto el tiempo como la memoria encajan f√°cilmente dentro de los l√≠mites de LeetCode.

-...

## 5down Implementaciones de referencia

## 5.1 Java (Using `ArrayList` + Binary Search)

``java
importar java.util*;

// Definici√≥n para un nodo de √°rbol binario.
clase TreeNode
int val;
TreeNode izquierda, derecha;
TreeNode(int x) { val = x; }
TreeNode(int x, TreeNode l, TreeNode r) { val = x; left = l; right = r; }
}

Clase Soluci√≥n {
// Construir la matriz ordenada a trav√©s de traversal en orden
inorden de vac√≠o privado(TreeNode node, Lista de instrucciones) {
si (nodo == nulo) regresa;
inorder(node.left, list);
list.add(node.val);
inorder(node.right, list);
}

public List made m√°s cercanaNodos(TreeNode root, Listo) {}
Lista realizadaInteger t√≠tulo clasificado = nuevo ArrayList implicado();
inorder(root, ordered);

Lista realizadaLista realizadaInteger t√≠tulo ans = nuevo ArrayList recomendado();
int n = sort.size();

para (int q : consultas) {
int lo = 0, hola = n; // hola es exclusiva
mientras (lo  hi hola) { // b√∫squeda binaria
int mid = lo + (hi - lo) / 2;
si (sorted.get(mid) < q) lo = mid + 1;
m√°s hola = medio;
}
// lo es el primer √≠ndice con valor >= q (o n)
int maxi = (lo iere n) ? sort.get(lo) : -1;
int mini = (lo ‚â§ 0) ? sort.get(lo - 1) : -1;

si (lo ecto n " cl.get(lo) == q) { // exacta partido
mini = maxi = q;
}
ans.add (Arrays.asList(mini, maxi));
}
devolver los ans;
}
}
`` `

‚ñ† *Por qu√© funciona* *
‚ñ† *En orden* da una lista ascendente estrictamente porque la entrada es un BST.
> `lo` se convierte en el l√≠mite m√°s bajo ** - el √≠ndice m√°s peque√±o con `valor ‚â• q`.
‚ñ† Los casos de borde ( " lo==n " , " lo==0 " ) se manejan mediante la comprobaci√≥n de l√≠mites.

-...

## 5.2 Python (Using `bisect`)

``python
de la importaci√≥n de bisect_left
de la importaci√≥n List, Optional

Definici√≥n para un nodo de √°rbol binario.
Clase TreeNode:
def __init__(self, val:int=0, left:'TreeNode'=None, right:'TreeNode'=None):
self.val = val
autoizquierda
self.right = right

Soluci√≥n de clase:
def _inorder(self, node: Optional[TreeNode], arr: List[int]) - t√≠tulo Ninguno.
si no no nodo: retorno
self._inorder(node.left, arr)
arr.append(node.val)
self._inorder(node.right, arr)

def m√°s cercanoNodes(self, root: TreeNode, consultas: List[int] - t√≠tulo List[List[int]]:
sort_vals = []
auto._inorden(root, sort_vals)
n = len(sorted_vals)
res = []

para q en consultas:
idx = bisect_left(sorted_vals, q) # first —é= q
maxi = sort_vals[idx] si idx
mini = sort_vals[idx-1] si idx √ò 0 m√°s -1

si idx se hizo n y clasifica_vals[idx] == q: # exacta coincidencia
mini = maxi = q
re.append([mini, maxi])
retorno
`` `

> `bisect_left` implementa la misma l√≥gica que la b√∫squeda binaria de Java pero en una l√≠nea √∫nica.

-...

### 5.3 C++ (Usando `vector` + `lower_bound`)

``cpp
#include ◊ôbits/stdc++.h
usando std namespace;

// Definici√≥n para un nodo de √°rbol binario.
struct TreeNode {
int val;
TreeNode *left, *right;
TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

Clase Soluci√≥n {
order de vac√≠o(TreeNode* nodo, vector identificadoint
si (!node) regresa;
inorder(node-propleft, v);
v.push_back(node-ciendoval);
inorder(node- correctamente, v);
}
public:
vector node* root, vector identificadoint confianza consultas) {
vector asignadoint t√≠tulo clasificado;
inorder(root, ordered);
int n = sort.size();
vector realizador:

para (int q : consultas) {
auto = inferior_bound(sorted.begin(), sort.end(), q); // first ‚â§
int idx = it - sort.begin();

int maxi = (it != classified.end()) ? *it : -1;
int mini = (idx > [idx-1] : -1;

if (it != classified.end() " Unidos == q) { // exact match
mini = maxi = q;
}
ans.push_back({mini, maxi});
}
devolver los ans;
}
};
`` `

Es la contraparte STL de `bisect_left`.
‚ñ† El c√≥digo es *iterative* y seguro para √°rboles muy profundos.

-...

## 6down Ed Edge‚Äê Lista de verificaci√≥n de casos

‚Üê Situaci√≥n Silencio esperada Resultado
Silencio...
Silencio No elemento ‚â§ query Óåì **‚Äê1** ‚Üê Olvidar `idx == Mira. Silencio
Silencio Ning√∫n elemento ‚â• query Silencio **‚Äê1** Silencio Utilizando incorrectamente `upper_bound`. Silencio
Silencio Query es igual a un valor de nodo Silencio `[q, q]` Silencio Dejar al predecesor sin cambios ‚Üí incorrecto. Silencio
Silencio √Årbol escarpado (degenerado) Silencio Todav√≠a O(n) memoria ¬¶ Recursive traversal puede desbordar la pila ‚Äì preferir iterante. Silencio
‚Üê Valores duplicados no permitidos en BST TENIDO Strictly ascending list TEN `lower_bound` todav√≠a funciona; duplicados romper√≠an la suposici√≥n. Silencio

-...

Consejos de entrevista

‚úî Tema Tema de la vida Lo que el entrevistador se preocupa por ¬¶
Silencio...
Silencioso **BST fundamentals** ¬øSabes c√≥mo un traversal en orden produce una lista ordenada? ‚Üê Dibujar un peque√±o BST en papel, caminar a trav√©s del orden. Silencio
Silencio **Binary search** Silencio ¬øPuede encontrar el sucesor del predecesor en el tiempo logar√≠tmico? Silencio Aplicar `bisect_left` o `lower_bound` desde cero, a continuaci√≥n, optimizar. Silencio
Silencio ** Optimizaci√≥n del espacio** Silencio ¬øTe das cuenta de almacenar el √°rbol de nuevo (por ejemplo, con `TreeSet`) es desperdicio? Silencio Explicar el intercambio entre un `TreeSet` (inserci√≥n/b√∫squeda por tiempo fijo) vs un √∫nico array clasificado. Silencio
Silencio **Edge-case handling** Silencio ¬øDevuelves **‚Äê1** correctamente? Silencio Mostrar casos de prueba donde la consulta es m√°s peque√±a que todos los nodos o m√°s grande que todos los nodos. Silencio
TEN **Iterative vs recursive** TEN ¬øTu soluci√≥n maneja los √°rboles escarpados? Silencio Usa una pila o traversal iterativa si anticipas una altura de 105. Silencio

‚ñ† **Recuerde**: Las pruebas de LeetCode generalmente generan un √°rbol aleatorio, por lo que la profundidad de recursi√≥n puede alcanzar el l√≠mite de pila predeterminado en Java/Python. Un en orden no recursivo (utilizando una pila expl√≠cita) garantiza la estabilidad.

-...

## 8down‚É£ FAQ (ficha de infidelidad)

Silencio
Silencio...
Silencio **¬øPuedo usar `TreeSet` en lugar de una matriz ordenada?** Silencio S√≠, pero todav√≠a necesitar√≠as llamar `lowerBound`/`ceil` para cada consulta ‚Äì el tiempo es el mismo, pero la memoria es m√°s alta. Silencio
Silencio **¬øEs necesario 'upper_bound'?** Silencio No, `lower_bound` + `idx-1` basta para predecesor y sucesor. Silencio
Silencio **¬øQu√© pasa si el √°rbol contiene valores duplicados?** Silencio El problema garantiza un * √°rbol de b√∫squeda binario*, que por definici√≥n tiene valores distintos; de lo contrario la respuesta ser√≠a ambigua. Silencio
Silencio **¬øPuedo hacer esto en tiempo O(n + m)?** Silencio S√≥lo si usted realiza un solo *parallel* traversal del √°rbol y las consultas (l√≠nea de barrido avanzada). No es necesario para 105 restricciones. Silencio
Silencio **¬øC√≥mo construir el √°rbol de un array?** Silencio Utilice el ayudante habitual de LeetCode que inserta los nodos de nivel por nivel. No es parte de la l√≥gica central. Silencio

-...

## 9Ô∏è Take‚Äêaway for the Job Interview

1. **Mostrar su comprensi√≥n de la estructura de datos** ‚Äì explicar por qu√© en orden da una lista ordenada.
2. **Hablar de la complejidad** ‚Äì ‚ÄúHacemos un √∫nico traversal (O(n)), entonces cada consulta utiliza la b√∫squeda binaria (O(log n)). ‚Äù
3. ** Periferias de menci√≥n** ‚Äì ‚ÄúSi el l√≠mite inferior est√° al principio o al final, volvemos ‚Äê1.‚Äù
4. **Si se pide una soluci√≥n m√°s ‚Äúdin√°mica‚Äù** ‚Äì sugerir el uso de ‚ÄúTreeSet‚Äù o un BST equilibrado que apoye el ‚Äúfloor()‚Äù y el ‚Äúceiling()‚Äù en O(log n).

‚ñ† *Por qu√© esto te hace destacar*
‚ñ† Muestra *la capacidad de reducir una soluci√≥n ingenua O(n ¬∑ m) a una r√°pida O(n + m log n)* ‚Äì un sello distintivo de un ingeniero experimentado.

-...

## üìö Final Code Snapshot

``bash
# Java
Java -leetcode. frasco
# Python
soluci√≥n python3. py
# C++
g++ -std=c+17 solution.cpp "
`` `

Los tres snippets arriba est√°n listos para copiar-paste en el editor de LeetCode y pasar las pruebas proporcionadas.

-...

### ## ritmo Happy Coding!
Si te gust√≥ este paseo, pulsa **üëç** y **Suscribir** para m√°s LeetCode deep‚Äêdives ‚Äì perfecto para tu pr√≥ximo prep de entrevista. üöÄ