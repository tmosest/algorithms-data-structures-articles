-...
T√≠tulo: LeetCode 616. A√±adir Bold Tag en String -
descripci√≥n: Titular
Fecha: 2025-09-21
categor√≠as: []
autor: muses
tags: []
HideToc: verdadero
-...
# Add Bold Tag in String ‚Äì LeetCode 616
**Java, Python & C++ + una gu√≠a de entrevista ‚ÄúGood‚ÄêBad‚ÄêUgly‚Äù**

‚ñ† **Meta-descripci√≥n** ‚Äì ¬øBuscas clavar tu pr√≥xima entrevista de codificaci√≥n? Master LeetCode 616 ‚Äì *Agregar la etiqueta Bold en String*. Sum√©rgete en una implementaci√≥n limpia de Trie, un truco de rayos booleanos y una versi√≥n C++. Obtenga el trabajo listo con las ideas de entrevista ‚Äúbuena, mala y fea‚Äù.

-...

## 1. Declaraci√≥n de problemas

‚ñ† Dada una cuerda `s` y una serie de cuerdas `palabras`, envuelven **todo subestring** de `s` que aparece en `palabras` con un solo par de etiquetas audaces ``. `` ... `Seguido/b ``.
* Si dos subestrings se superponen, fusionarlos en un bloque audaz.
* Si dos bloques audaces son consecutivos, fusionarlos tambi√©n.

*Ejemplo*

`` `
Entrada: s = "aaabbb", palabras = ["aa", "b"]
Producto: "()
`` `

**Constraints* *

- `1 0 = s.length
- `0 0 = palabras. longitud = 100'
- `1 0 = palabras [i].length
- `s` y todas `palabras[i]` contienen s√≥lo letras y d√≠gitos en ingl√©s.

El problema es una pregunta de entrevista cl√°sica de cuerdas; tambi√©n es la base para el LeetCode ‚ÄúBold Words in String‚Äù (problema 758).

-...

## 2. Panorama general de la soluci√≥n

El principal reto es ** encontrar eficientemente todas las ocurrencias de las palabras** en `s` y luego combinar intervalos superpuestos/adyacentes. Dos enfoques populares:

Silencio Silencio Silencio Silencio Silencio Silencio
Silencio-----------------------------Prince----
Silencio **Trie + Scan** Silencio Construye un poco de todas las palabras; en cada √≠ndice de `s` caminar el tr√≠o para encontrar el partido m√°s largo. Marque una matriz booleana para posiciones ‚Äúbold‚Äù. Silencio `O(las vidas eternas * maxLen(words))¬ª Silencio `O(totalLength(words)) + O(las vidas eternas)` Silencio
Silencio **Boolean Array + Na√Øve Buscar** Silencio Por cada palabra, escanee `s` con `indexOf`; marcado rangos emparejados. Silencio `O(las palabras previas sometidas a la pr√°ctica) `O (las vidas eternas)` Silencio

Nos enfocaremos en la implementaci√≥n **Trie** ‚Äì es conciso, corre r√°pido, y demuestra una estructura de datos cl√°sica. Tambi√©n mostraremos la variante **boolean array** para la integridad.

-...

## 3. üìå Good, Bad & Ugly ‚Äì Puntos de conversaci√≥n de entrevistas

TENIDO TERRITORIO T√âpico ANTERIOR Qu√© hacer frente a las Pitfalls
Silencio--------------------------------------------------------
Silencio 1 Silencio **Clarificar el formato de entrada** Silencio ¬øEst√° garantizada "palabras" no vac√≠a? tenci√≥n Olv√≠date de manejar las palabras vac√≠as ‚Üí `O(0)` TENCI√ìN Check `words.length == 0 ' ‚Üí return `s`s
Silencio 2 Silencio **Definir ‚Äúsobrelapso‚Äù justamente** TENIDO Dos intervalos audaces `[l1, r1]` y `[l2, r2]` superposici√≥n si `l2 <= r1`. Silencio Mezclando √≠ndices inclusivos/exclusivos TENIDO Uso √çndices inclusivos basados en 0
Silencio 3 Silencio ** Casos altos con audacia consecutiva** Silenciosos `[0,2]` + `[3,5]` ‚Üí `[0,5]` porque `3 == 2+1` ANTE Olv√≠date de combinar ‚Üí etiquetas colgantes Silencio Despu√©s de marcar, iterate una vez para insertar etiquetas cuando el estado cambia
Silencio 4 Silencio **La justificaci√≥n de la complejidad** Silencio Mostrar c√≥mo la trie reduce el peor de los casos de `O(n*m)` a `O(n * maxLen)` Silencio Sobre-optimizaci√≥n por caching partido m√°s largo por √≠ndice ¬¶ Mantener un solo `maxEnd` durante la exploraci√≥n Silencio
Silencio 5 Silencio **Testing** Silencio Incluir casos con palabras superpuestas, palabras anidadas, y palabras id√©nticas Óåì Prueba de l√≠mite desaparecido ‚Üí > > desaparecidos al final ‚Üê Final check for open tag 

‚ñ† **‚ÄúBueno‚Äù** ‚Äì Una explicaci√≥n limpia del algoritmo, manejo cuidadoso de los √≠ndices y una complejidad comprobada.
‚ñ† **‚ÄúBad‚Äù** ‚Äì Una implementaci√≥n demasiado verbosa que olvida fusionar intervalos o malinterpretar el √∫ltimo bloque audaz.
‚ñ† **‚ÄúUgly‚Äù** ‚Äì Los bucles anidados de fuerza bruta con concatenaci√≥n de cuerdas en el interior; funciona pero el tiempo fuera en el gran set de prueba.

-...

## 4. üîß C√≥digo Snippets

A continuaci√≥n se muestran **full, ready-to-compile** soluciones en **Java**, **Python**, y **C+**. Los tres utilizan el enfoque Trie; la soluci√≥n Python tambi√©n incluye una variante alternativa de rayos booleanos para la comparaci√≥n.

‚ñ™ restablecimiento **Todo el c√≥digo se prueba en la plataforma LeetCode. #
> **Recuerda pegar el c√≥digo en la secci√≥n correspondiente del idioma en LeetCode. #

-...

### 4.1 Java ‚Äì Trie Implementation

``java
// Java 17

importar java.util*;

Clase Soluci√≥n {

--------- Trie Node...
Clase privada TrieNode {}
Mapa seleccionadoCaracter, TrieNode conf√≠a child = new HashMap Quer√≠a();
boolean isWord = false;
}

--------- Trie...
clase privada Trie {
final privado TrieNode root = nuevo TrieNode();

vac√≠o add(String word) {
TrieNode node = root;
para (carc : word.toCharArray()) {}
nodo = nodo.child.computeIfAbsent(c, k - t√≠tulo nuevo TrieNode());
}
Nodo. isWord = true;
}

/* Volver el √∫ltimo √≠ndice (inclusivo) de la palabra m√°s larga
que comienza en la posici√≥n 'start' en 's'.
Si no hay ninguno, regrese -1. */
m√°s largo Match(String s, int start) {
TrieNode node = root;
int end = -1;
(int i = start; i) s.length(); i++) {
char c = s.charAt(i);
nodo = nodo.child.get(c);
si (nodo == nulo) se rompen;
si (node.isWord) termina = i;
}
final de retorno;
}
}

public String addBoldTag(String s, String[] words) {
si (palabras == null ¬¶ 0) retorno s;

Trie trie = nuevo Trie();
for (String w : words) trie.add(w);

int n = s.length();
boolean[] bold = new boolean[n];
int maxEnd = -1; // la posici√≥n m√°s cercana hasta el momento

para (int i = 0; i)
int end = trie.longest Match(s, i); // palabra m√°s larga empezando en i
maxEnd = Math.max(maxEnd, end); // combinar con intervalo previo
bold[i] = maxEnd >= i; // posici√≥n actual es negrita
}

StringBuilder sb = nuevo StringBuilder();
boolean inBold = false;
para (int i = 0; i)
si (bold[i] " sensible !inBold) { // comenzar bold
sb.append("cantab]);
inBold = true;
} si (!bold[i] " golpe inBold) { // end bold
sb.append(" obtenidos/b t√≠tulo");
inBold = false;
}
sb.append(s.charAt(i));
}
si (inBold) sb.append("Seguido/b]); // cerrar al final
devolver sb.toString();
}

--------- Conductor simple para las pruebas locales-------- */
public static void main(String[] args) {
Soluci√≥n sol = nueva soluci√≥n ();
System.out.println(sol.addBoldTag("abcxyz123", nuevo String[]{"abc","123"})
System.out.println(sol.addBoldTag("aaabbb", nuevo String[]{"aaa","b"});
}
}
`` `

**La complejidad* *
- Tiempo: `O(las vidas eternas * maxLen(palabras)' - cada √≠ndice escanea a la palabra m√°s larga.
- Espacio: `O(totalLength(words) + Silencios sufridos)` ‚Äì trie nodes + matriz booleana.

-...

### 4.2 Python ‚Äì Trie & Boolean‚ÄêArray Variant

``python
# Python 3.11

Clase TrieNode:
__slots__ = ("ni√±o", "es_palabra")
def __init__(self):
self.child = {}
self.is_word = Falso

Clase Trie:
def __init__(self):
self.root = TrieNode()

def add(self, word: str):
nodo = self.root
para ch en palabra:
nodo = nodo.child.setdefault(ch, TrieNode())
node.is_word = Verdadero

def longest_match(self, s: str, start: int) int:
nodo = self.root
final = 1
para i en rango(start, len(s)):
nodo = nodo.child.get(s[i])
si el nodo es Ninguno:
descanso
si node.is_word:
final = i
final de retorno

Soluci√≥n de clase:
def addBoldTag(self, s: str, words: list[str]) - confiar str:
si no palabras:
retorno s

trie = Trie()
para w en palabras:
trie.add(w)

n = len(s)
bold = [False] * n
max_end = -1
para i en rango(n):
end = trie.longest_match(s, i)
max_end = max(max_end, end)
bold[i] = max_end >= i

res = []
in_bold = False
para i, ch in enumerate(s):
si atrevidos[i] y no in_bold:
re.append("Seguido]
in_bold = True
Elif no bold[i] and in_bold:
re.append("Seguido/b t√≠tulo")
in_bold = False
re.append(ch)
si in_bold:
re.append("Seguido/b t√≠tulo")
volver ".join(res)

# ---------- Fuerza bruta de rayos booleanos (para comparaci√≥n)--------
def addBoldTag_bruteforce(s: str, words: list[str]) - confiar str:
n = len(s)
bold = [False] * n
para w en palabras:
inicio = s.find(w)
mientras comienza!= -1:
para i en rango(start, start + len(w)):
bold[i] = True
inicio = s.find(w, start + 1)
res, in_bold = [], False
para i, ch in enumerate(s):
si atrevidos[i] y no in_bold:
re.append("Seguido]
in_bold = True
Elif no bold[i] and in_bold:
re.append("Seguido/b t√≠tulo")
in_bold = False
re.append(ch)
si in_bold:
re.append("Seguido/b t√≠tulo")
volver ".join(res)

# -------- Conductor simple...
si __name_ == "__main__":
sol = Soluci√≥n()
print(sol.addBoldTag("abcxyz123", ["abc","123"])
print(sol.addBoldTag("aaabbb", ["aaa","b"])
`` `

**Notas*

- `__slots_' reduce la sobrecarga de memoria para el trie.
- La variante de fuerza bruta es `O(len(words) * len(s))` y debe evitarse en la producci√≥n.

-...

### 4.3 C++ ‚Äì Trie Implementation

``cpp
// C+17 (GNU+17)

#include ◊ôbits/stdc++.h
usando std namespace;

struct TrieNode {}
matriz realizadaTrieNode*, 62 hijos de confianza; // 0-9, A-Z, a-z
bool isWord;
TrieNode() : child{nullptr}, isWord(false) {}
};

clase Trie
TrieNode* root = nuevo TrieNode();
public:
vacio add(cont cadena reducida word) {
TrieNode* node = root;
por (char ch : word) {
int idx = charIndex(ch);
si (!node- conf√≠achild[idx]) node-(idx] = nuevo TrieNode();
nodo = nodo-(idx);
}
node- t√≠tuloisWord = true;
}

/* Regresar el √∫ltimo √≠ndice del partido m√°s largo empezando por 'start'.
Regresa -1 si no hay coincidencia. */
m√°s largo Match(const cord√≥n plaga s, int start) const {
TrieNode* node = root;
int end = -1;
para (int i = start; i) ++i) {
int idx = charIndex(s[i]);
nodo = nodo-(idx);
si (nodo) romper;
si (nodo-clienteisWord) final = i;
}
final de retorno;
}

privado:
// Mapa: '0'-'9' - t√≠tulo 0-9, 'A'-'Z' - t√≠tulo 10-35, 'a'-z' - t√≠tulo 36-61
static int charIndex(char c) {}
si ('0'' 0' 0') devuelto c " &= " ;
si ('A') se entiende= c " c√≠rculo c " = 'Z') devuelve 10 + (c - 'A');
retorno 36 + (c - 'a');
}
};

Clase Soluci√≥n {
public:
string addBoldTag(string s, vector seleccionadostring confianza words) {
si (palabras.empty()) devuelve s;

Trie trie;
para (continuo auto-cliente w : palabras) trie.add(w);

int n = s.size();
vector:
int maxEnd = -1;
para (int i = 0; i) {}
int end = trie.longest Partidos, i);
maxEnd = max(maxEnd, end);
bold[i] = (maxEnd >= i);
}

cadena res;
bool inBold = false;
para (int i = 0; i) {}
si (bold[i] " sensible !inBold) { res += " implicab confianza"; inBold = true; }
si (!bold[i] " sensible inBold " ) { res += " obtenidos/b confidencial"; inBold = false; }
res += s[i];
}
si (inBold) res += "traducido/b confidencial";
restituci√≥n;
}
};
`` `

**La complejidad** ‚Äì id√©ntica a la versi√≥n Java.

En C++ se puede optimizar el trie con un array de 62 ni√±os (10+26+26).

-...

## 5. üéØ Takeaway for the Interview

- **Explicar el algoritmo paso a paso** (compilar, escanear, marcar, combinar).
- ** Casos de bordes validados** (palabras vac√≠as, palabras de caracteres individuales, intervalos superpuestos).
- **Descubre el O(explorando palabras vivas)** espacio/tiempo de intercambio de la trie.
- **Mostrar un controlador m√≠nimo** o 'mantener' funci√≥n si usted est√° codificaci√≥n fuera de LeetCode; demuestra confianza.

Recuerde, los contadores de LeetCode **runtime** y **memory** son estrictos. Una soluci√≥n que fusiona intervalos perezosos (sobre la marcha) y **insertas etiquetas en un solo pase** pasar√° todas las pruebas.

-...

## 6. üöÄ Pensamiento final

‚ñ† **Bold Words in String** es la entrevista ‚Äúestring-matching‚Äù equivalente al problema de la mejor pr√°ctica* de una entrevista de codificaci√≥n. Dominar el escaneo trie + el patr√≥n de fusi√≥n de intervalos no s√≥lo te lleva a trav√©s de LeetCode, sino que tambi√©n demuestra tu capacidad de manejar el preprocesamiento de cadenas, la b√∫squeda eficiente y la l√≥gica de l√≠mites cuidadosos ‚Äî mata a cada ingeniero de software senior debe poseer.

¬°Feliz codificaci√≥n y buena suerte en tu pr√≥xima entrevista! üöÄ

-...

** ¬øTienes preguntas? * *
- ¬øQuieres una soluci√≥n Rust?
- Curioso sobre Aho-Corasick para el emparejamiento multi-pattern?

Av√≠same en los comentarios ‚Äì Actualizar√© el repo con m√°s idiomas!